{"pages":[{"title":"","text":"个人简介 93年生人，从事java服务端开发工作4年，现居上海 Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。","link":"/about/index.html"}],"posts":[{"title":"Java NIO学习与记录（七）： Reactor单线程模型的实现","text":"一、Selector&amp;Channel1.1：各种channel写这个模型需要提前了解Selector以及Channel，之前记录过FileChannel，除此之外还有以下几种Channel： ServerSocketChannel：用于监听新的TCP连接的通道，负责读取&amp;响应，通常用于服务端的实现。 SocketChannel：用于发起TCP连接，读写网络中的数据，通常用于客户端的实现。 DatagramChannel：上述两个通道基于TCP传输协议，而这个通道则基于UDP，用于读写网络中的数据。 FileChannel：从文件读取数据。 本篇重点放在ServerSocketChannel和SocketChannel上，大部分客户端/服务端为了保证数据准确性，都是基于TCP传输协议实现的，由于使用Selector注册必须要求被注册的Channel是非阻塞模式的，因此FileChannel由于没有非阻塞模式（无法设置configureBlocking(false)），没办法和注册到selector。 1.2：selectorSelector是个通道注册器（用法会在程序里标注），是实现Reactor模型的关键，多个通道均可以注册到Selector，Selector负责监听每个Channel的几个事件：连接就绪、写就绪、读就绪，当某个channel注册感兴趣就绪事件到selector时，若发生兴趣事件就绪，则Selector.select()方法不再阻塞，返回兴趣事件集合（可能包含多个channel的），然后按照事件不同进行分发处理。 Selector返回对应的就绪事件，封装为SelectionKey，每个Channel对应一个SelectionKey，这个对象还可以通过attach方法附着处理类（Handler、Acceptor等）。 1.3：一个简单的例子先来看个简单使用Selector做处理的服务端实现，可以简单对Selector和SelectionKey的用法做个了解： 123456789101112131415161718192021222324252627282930313233343536373839public static void main(String[] args) throws IOException { Selector selector = Selector.open(); //打开选择器 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); //打开通道 serverSocketChannel.configureBlocking(false); //设置通道为非阻塞模式 serverSocketChannel.bind(new InetSocketAddress(2333)); //绑定端口 serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); //注册channel到选择器，指定监听该Channel的哪些事件，初始化都是对连接事件监听（因为是入口） while (selector.select() &gt; 0) { // 若收到就绪事件select返回“感兴趣”事件集合，否则阻塞当前线程 Set keys = selector.selectedKeys(); //获取本次拿到的事件集合 Iterator iterator = keys.iterator(); while (iterator.hasNext()) { SelectionKey key = iterator.next(); iterator.remove(); if (key.isAcceptable()) { //当前就绪事件为连接事件 ServerSocketChannel skc = (ServerSocketChannel) key.channel(); //连接就绪触发，说明已经有客户端通道连了过来，这里需要拿服务端通道去获取客户端通道 SocketChannel socketChannel = skc.accept(); //获取客户端通道（连接就绪，说明客户端接下来可能还有别的动作，比如读和写） socketChannel.configureBlocking(false); //同样的需要设置非阻塞模式 System.out.println(String.format(\"收到来自 %s 的连接\", socketChannel.getRemoteAddress())); socketChannel.register(selector, SelectionKey.OP_READ); //将该客户端注册到选择器，感兴趣事件设置为读（客户端连接完毕，很肯能会往服务端写数据，因此这里要注册读事件用以接收这些数据） } else if (key.isReadable()) { //当前事件为读就绪 SocketChannel socketChannel = (SocketChannel) key.channel(); //能触发读就绪，说明客户端已经开始往服务端写数据，通过SelectionKey拿到当前客户端通道 ByteBuffer buffer = ByteBuffer.allocate(1024); int count = socketChannel.read(buffer); //从通道读入数据 if (count &lt; 0) { //若本次读就绪拿到-1，则认为客户端主动断开了连接 socketChannel.close(); //服务端关闭客户端通道 key.cancel(); //断连后就将该事件从选择器的SelectionKey集合中移除（这里说一下，这里不是真正意义上的移除，这里是取消，会将该key放入取消队列里，在下次select函数调用时才负责清空） System.out.println(\"连接关闭\"); continue; } System.out.println(String.format(\"收到来自 %s 的消息: %s\", socketChannel.getRemoteAddress(), new String(buffer.array()))); } keys.remove(key); } } } 代码块1 上面是一个简单的例子，接下来，就利用选择器、通道来实现Reactor单线程模型。 二、单Reactor单线程模型的服务端实现实现服务端，服务端负责接收客户端的连接，接收客户端的请求数据以及响应客户端。 把上一篇的结构图再拿过来展示下，看看需要做的有哪些模块： 通过上图，我们需要实现的模块有Reactor、Acceptor、Handler，下面来逐个编写： 2.1：Reactor核心模块该模块内部包含两个核心方法，select和dispatch，该模块负责监听就绪事件和对事件的分发处理： 123456789101112131415161718192021222324252627282930313233343536373839404142public class Reactor implements Runnable { private final Selector selector; private final ServerSocketChannel serverSocketChannel; public Reactor(int port) throws IOException { //Reactor初始化 selector = Selector.open(); //打开一个Selector serverSocketChannel = ServerSocketChannel.open(); //建立一个Server端通道 serverSocketChannel.socket().bind(new InetSocketAddress(port)); //绑定服务端口 serverSocketChannel.configureBlocking(false); //selector模式下，所有通道必须是非阻塞的 //Reactor是入口，最初给一个channel注册上去的事件都是accept SelectionKey sk = serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); //attach callback object, Acceptor sk.attach(new Acceptor(serverSocketChannel, selector)); } @Override public void run() { try { while (!Thread.interrupted()) { selector.select(); //就绪事件到达之前，阻塞 Set selected = selector.selectedKeys(); //拿到本次select获取的就绪事件 Iterator it = selected.iterator(); while (it.hasNext()) { //这里进行任务分发 dispatch((SelectionKey) (it.next())); } selected.clear(); } } catch (IOException e) { e.printStackTrace(); } } void dispatch(SelectionKey k) { Runnable r = (Runnable) (k.attachment()); //这里很关键，拿到每次selectKey里面附带的处理对象，然后调用其run，这个对象在具体的Handler里会进行创建，初始化的附带对象为Acceptor（看上面构造器） //调用之前注册的callback对象 if (r != null) { r.run(); } }} 代码块2 细节已标注。 2.2：实现Acceptor模块这个模块只负责处理连接就绪事件，有了这个事件就可以拿到客户单的SocketChannel，就可以继续完成接下来的读写任务了： 1234567891011121314151617181920212223242526public class Acceptor implements Runnable { private final Selector selector; private final ServerSocketChannel serverSocketChannel; Acceptor(ServerSocketChannel serverSocketChannel, Selector selector) { this.serverSocketChannel = serverSocketChannel; this.selector = selector; } @Override public void run() { SocketChannel socketChannel; try { socketChannel = serverSocketChannel.accept(); if (socketChannel != null) { System.out.println(String.format(\"收到来自 %s 的连接\", socketChannel.getRemoteAddress())); new Handler(socketChannel, selector); //这里把客户端通道传给Handler，Handler负责接下来的事件处理（除了连接事件以外的事件均可） } } catch (IOException e) { e.printStackTrace(); } }} 代码块3 细节已标注。 2.3：Handler模块的实现这个模块负责接下来的读写操作： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class Handler implements Runnable { private final SelectionKey selectionKey; private final SocketChannel socketChannel; private ByteBuffer readBuffer = ByteBuffer.allocate(1024); private ByteBuffer sendBuffer = ByteBuffer.allocate(2048); private final static int READ = 0; private final static int SEND = 1; private int status = READ; Handler(SocketChannel socketChannel, Selector selector) throws IOException { this.socketChannel = socketChannel; //接收客户端连接 this.socketChannel.configureBlocking(false); //置为非阻塞模式（selector仅允非阻塞模式） selectionKey = socketChannel.register(selector, 0); //将该客户端注册到selector，得到一个SelectionKey，以后的select到的就绪动作全都是由该对象进行封装 selectionKey.attach(this); //附加处理对象，当前是Handler对象，run是对象处理业务的方法 selectionKey.interestOps(SelectionKey.OP_READ); //走到这里，说明之前Acceptor里的建连已完成，那么接下来就是读取动作，因此这里首先将读事件标记为“感兴趣”事件 selector.wakeup(); //唤起select阻塞 } @Override public void run() { try { switch (status) { case READ: read(); break; case SEND: send(); break; default: } } catch (IOException e) { //这里的异常处理是做了汇总，常出的异常就是server端还有未读/写完的客户端消息，客户端就主动断开连接，这种情况下是不会触发返回-1的，这样下面read和write方法里的cancel和close就都无法触发，这样会导致死循环异常（read/write处理失败，事件又未被cancel，因此会不断的被select到，不断的报异常） System.err.println(\"read或send时发生异常！异常信息：\" + e.getMessage()); selectionKey.cancel(); try { socketChannel.close(); } catch (IOException e2) { System.err.println(\"关闭通道时发生异常！异常信息：\" + e2.getMessage()); e2.printStackTrace(); } } } private void read() throws IOException { if (selectionKey.isValid()) { readBuffer.clear(); int count = socketChannel.read(readBuffer); //read方法结束，意味着本次\"读就绪\"变为\"读完毕\"，标记着一次就绪事件的结束 if (count &gt; 0) { System.out.println(String.format(\"收到来自 %s 的消息: %s\", socketChannel.getRemoteAddress(), new String(readBuffer.array()))); status = SEND; selectionKey.interestOps(SelectionKey.OP_WRITE); //注册写方法 } else { //读模式下拿到的值是-1，说明客户端已经断开连接，那么将对应的selectKey从selector里清除，否则下次还会select到，因为断开连接意味着读就绪不会变成读完毕，也不cancel，下次select会不停收到该事件 //所以在这种场景下，（服务器程序）你需要关闭socketChannel并且取消key，最好是退出当前函数。注意，这个时候服务端要是继续使用该socketChannel进行读操作的话，就会抛出“远程主机强迫关闭一个现有的连接”的IO异常。 selectionKey.cancel(); socketChannel.close(); System.out.println(\"read时-------连接关闭\"); } } } void send() throws IOException { if (selectionKey.isValid()) { sendBuffer.clear(); sendBuffer.put(String.format(\"我收到来自%s的信息辣：%s, 200ok;\", socketChannel.getRemoteAddress(), new String(readBuffer.array())).getBytes()); sendBuffer.flip(); int count = socketChannel.write(sendBuffer); //write方法结束，意味着本次写就绪变为写完毕，标记着一次事件的结束 if (count &lt; 0) { //同上，write场景下，取到-1，也意味着客户端断开连接 selectionKey.cancel(); socketChannel.close(); System.out.println(\"send时-------连接关闭\"); } //没断开连接，则再次切换到读 status = READ; selectionKey.interestOps(SelectionKey.OP_READ); } }} 代码块4 细节已标注。 关键模块已实现，下面来启动服务端： 1new Thread(new Reactor(2333)).start(); 代码块5 三、客户端的编写接下来同样利用selector编写客户端，客户端需要做的事情就是发送消息到服务端，等待服务端响应，然后再次发送消息，发够10条消息断开连接： 3.1：Client入口模块1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class NIOClient implements Runnable { private Selector selector; private SocketChannel socketChannel; NIOClient(String ip, int port) { try { selector = Selector.open(); //打开一个Selector socketChannel = SocketChannel.open(); socketChannel.configureBlocking(false); //设置为非阻塞模式 socketChannel.connect(new InetSocketAddress(ip, port)); //连接服务 //入口，最初给一个客户端channel注册上去的事件都是连接事件 SelectionKey sk = socketChannel.register(selector, SelectionKey.OP_CONNECT); //附加处理类，第一次初始化放的是连接就绪处理类 sk.attach(new Connector(socketChannel, selector)); } catch (IOException e) { e.printStackTrace(); } } @Override public void run() { try { while (!Thread.interrupted()) { selector.select(); //就绪事件到达之前，阻塞 Set selected = selector.selectedKeys(); //拿到本次select获取的就绪事件 Iterator it = selected.iterator(); while (it.hasNext()) { //这里进行任务分发 dispatch((SelectionKey) (it.next())); } selected.clear(); } } catch (IOException e) { e.printStackTrace(); } } void dispatch(SelectionKey k) { Runnable r = (Runnable) (k.attachment()); //这里很关键，拿到每次selectKey里面附带的处理对象，然后调用其run，这个对象在具体的Handler里会进行创建，初始化的附带对象为Connector（看上面构造器） //调用之前注册的callback对象 if (r != null) { r.run(); } }} 代码块6 细节已标注。 3.2：Connector模块（建连）123456789101112131415161718192021222324public class Connector implements Runnable { private final Selector selector; private final SocketChannel socketChannel; Connector(SocketChannel socketChannel, Selector selector) { this.socketChannel = socketChannel; this.selector = selector; } @Override public void run() { try { if (socketChannel.finishConnect()) { //这里连接完成（与服务端的三次握手完成） System.out.println(String.format(\"已完成 %s 的连接\", socketChannel.getRemoteAddress())); new Handler(socketChannel, selector); //连接建立完成后，接下来的动作交给Handler去处理（读写等） } } catch (IOException e) { e.printStackTrace(); } }} 代码块7 细节已标注。 3.3：客户端Handler模块实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class Handler implements Runnable { private final SelectionKey selectionKey; private final SocketChannel socketChannel; private ByteBuffer readBuffer = ByteBuffer.allocate(2048); private ByteBuffer sendBuffer = ByteBuffer.allocate(1024); private final static int READ = 0; private final static int SEND = 1; private int status = SEND; //与服务端不同，默认最开始是发送数据 private AtomicInteger counter = new AtomicInteger(); Handler(SocketChannel socketChannel, Selector selector) throws IOException { this.socketChannel = socketChannel; //接收客户端连接 this.socketChannel.configureBlocking(false); //置为非阻塞模式（selector仅允非阻塞模式） selectionKey = socketChannel.register(selector, 0); //将该客户端注册到selector，得到一个SelectionKey，以后的select到的就绪动作全都是由该对象进行封装 selectionKey.attach(this); //附加处理对象，当前是Handler对象，run是对象处理业务的方法 selectionKey.interestOps(SelectionKey.OP_WRITE); //走到这里，说明之前Connect已完成，那么接下来就是发送数据，因此这里首先将写事件标记为“感兴趣”事件 selector.wakeup(); //唤起select阻塞 } @Override public void run() { try { switch (status) { case SEND: send(); break; case READ: read(); break; default: } } catch (IOException e) { //这里的异常处理是做了汇总，同样的，客户端也面临着正在与服务端进行写/读数据时，突然因为网络等原因，服务端直接断掉连接，这个时候客户端需要关闭自己并退出程序 System.err.println(\"send或read时发生异常！异常信息：\" + e.getMessage()); selectionKey.cancel(); try { socketChannel.close(); } catch (IOException e2) { System.err.println(\"关闭通道时发生异常！异常信息：\" + e2.getMessage()); e2.printStackTrace(); } } } void send() throws IOException { if (selectionKey.isValid()) { sendBuffer.clear(); int count = counter.incrementAndGet(); if (count &lt;= 10) { sendBuffer.put(String.format(\"客户端发送的第%s条消息\", count).getBytes()); sendBuffer.flip(); //切换到读模式，用于让通道读到buffer里的数据 socketChannel.write(sendBuffer); //则再次切换到读，用以接收服务端的响应 status = READ; selectionKey.interestOps(SelectionKey.OP_READ); } else { selectionKey.cancel(); socketChannel.close(); } } } private void read() throws IOException { if (selectionKey.isValid()) { readBuffer.clear(); //切换成buffer的写模式，用于让通道将自己的内容写入到buffer里 socketChannel.read(readBuffer); System.out.println(String.format(\"收到来自服务端的消息: %s\", new String(readBuffer.array()))); //收到服务端的响应后，再继续往服务端发送数据 status = SEND; selectionKey.interestOps(SelectionKey.OP_WRITE); //注册写事件 } }} 代码块8 细节已标注。 下面启动客户端去连接之前的服务端： 12new Thread(new NIOClient(\"127.0.0.1\", 2333)).start();new Thread(new NIOClient(\"127.0.0.1\", 2333)).start(); 代码块9 上面模拟了两个客户端同时连到服务端，运行结果如下： 单线程Reactor模型有个致命的缺点，通过上述例子可以看出，整个执行流程都是线性的，客户端请求→服务端读取→服务端响应→客户端收到响应→客户端再次发送请求，那么在这个链路中，如果handler中某个位置存在性能瓶颈，比如我们可以改造下服务端的send方法： 1234567try { Thread.sleep(2000L); //响应2s} catch (InterruptedException e) { e.printStackTrace();}int count = socketChannel.write(sendBuffer); 代码块10 在响应客户端之前睡眠2s，当做是性能瓶颈点，同样的再次开两个客户端同时访问服务端，每个客户端发送10条消息，会发现，程序直接运行了40s，这是大多数情况下不愿意看到的，因此，就有了多线程Reactor模式，跟BIO为了提高性能将读操作放到一个独立线程处理一样，Reactor这样做，也是为了解决上面提到的性能问题，只不过NIO比BIO做异步有个最大的优势就是NIO不会阻塞一个线程，类似read这种操作状态都是由selector负责监听的，不像BIO里都是阻塞的，只要被异步出去，那么一定是非阻塞的业务代码（除非是人为将代码搞成阻塞），而BIO由于read本身阻塞，因此会阻塞掉整个业务线程，这也是同样是异步为什么NIO可以更加高效的原因之一。 那么单线程Reactor适用于什么情况呢？适用于那种程序复杂度很低的系统，例如redis，其大部分操作都是非常高效的，很多命令的时间复杂度直接为O(1)，这种情况下适合这种简单的Reactor模型实现服务端。","link":"/2019/03/27/Java%20NIO%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%20Reactor%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"title":"Redis小记-内存解析&内存消耗篇","text":"前置：redis内存指标 注：本文默认读者已初步学会使用redis了。 首先我们通过info命令查看相关指标，其中几个memory的重要指标整理出来如下： 属性 解释 used_memory redis内部存储的所有数据的内存总占用量（自身内存+对象内存+缓冲内存） used_memory_ress redis进程占用的总物理内存 mem_fragmentation_ratio used_memory_ress与used_memory的比值，即为内存碎片率 mem_allocator 内存分配器，默认为jemalloc 表1 一、碎片率 当内存碎片率 &gt; 1时，说明redis进程占用物理内存的总量大于Redis实际存储数据（表1第一行）的内存占用量，溢出来的部分内存被内存碎片消耗，如果溢出部分过大，则说明内存碎片率严重。 相反的，如果碎片率 &lt; 1时，则说明Redis存储的数据总量已经超出了redis进程占用内存的总量，造成这种情况是因为操作系统把Redis内存交换至硬盘导致（swap），由于硬盘读取速度远远慢与内存，因此这种情况下redis性能极差，可能出现僵死。 二、redis内存消耗的几个来源2.1：自身内存redis启动后自身运行所需内存； 2.2：对象内存内存占用最大的一部分，这里面存储的就是用户自身的数据（业务数据），数据以key-value类型存储，内存消耗可表示为：key内存+value内存。 2.3：缓冲内存主要由客户端缓冲区+复制积压缓冲区+AOF缓冲区组成，具体解释如下： 客户端缓冲区指的是所有接入redis服务器的TCP连接的输入和输出缓冲，输入缓冲无法被控制，最大空间为1G，超过立即断开连接，输出缓冲通过client-output-buffer-limit控制。 复制积压缓冲区指的是redis在2.8版本以后提供了一块可以重复利用的固定大小的缓冲区，用来实现部分复制功能，使用repl-backlog-size参数控制，默认1MB（主从结构下，主节点只存在一个该缓冲区，从节点共用，那时可以设置较大的缓冲区空间），该缓冲区可以避免全量复制。 AOF缓冲区用于存储在redis重写期间保存最近的写入命令，无法控制，通常取决于AOF重写时间以及写入命令量，一般情况下很小。 2.4：内存碎片redis默认的内存分配器是jemalloc，可选的还有glibc和tcmalloc；内存分配器为了更好的管理以及重复利用内存，分配策略一般采用固定范围的内存块进行分配；因此，我们在存储一块5kb的内容时，内存分配器可能会为我们分配8kb的块存储，剩下的3kb不能再次分配给其他对象存储，因而沦为了内存碎片；jemalloc对碎片化问题做了优化，一般来讲碎片化率保持在1.03左右。 可能造成内存碎片率过高的场景： 频繁的更新操作，例如频繁对已存在的键做append、setrange等操作； 大量过期键删除，键对象过期删除后释放的空间无法得到充分的利用，导致碎片率上升。 解决办法： 数据对齐，尽量采用数字类型或固定长度的字符串（大部分业务场景不满足这种方式）； 重启，重启节点可以使内存重整理，利用高可用的结构（节点集群+主从结构），将碎片率过高的节点主节点转换为从节点，然后进行安全重启。 2.5：子进程内存消耗子进程内存消耗指的是执行AOF/RDB重写时redis创建的子进程内存消耗；redis执行fork操作产生的子进程内存占用量对外表现为与父进程相同，理论上需要一倍的物理内存来完成重写的操作。但是linux具备写时复制技术（copy-on-write），父子进程会共享相同的物理内存页，当父进程处理写请求时会对需要修改的页复制出一份副本来完成写操作，而子进程依然读取fork时整个父进程的内存快照，总结： 子进程并不需要消耗一倍的父进程内存，实际消耗根据期间写入命令量决定，但依然要预留出一些内存防止溢出； 需要设置sysctl vm.overcommit_memory = 1允许内核可以分配所有的物理内存，防止redis进程执行fork时因剩余内存不足导致失败； 排查当前系统是否支持开启THP，如果开启建议关闭，防止copy-on-write期间内存过度消耗。","link":"/2017/08/12/Redis%E5%B0%8F%E8%AE%B0-%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90&%E5%86%85%E5%AD%98%E6%B6%88%E8%80%97%E7%AF%87/"},{"title":"ThreadLocal系列（一）-ThreadLocal的使用及原理解析","text":"项目中我们如果想要某个对象在程序运行中的任意位置获取到，就需要借助ThreadLocal来实现，这个对象称作线程的本地变量，下面就介绍下ThreadLocal是如何做到线程内本地变量传递的， 一、基本使用先来看下基本用法： 1234567891011121314private static ThreadLocal tl = new ThreadLocal&lt;&gt;();public static void main(String[] args) throws Exception { tl.set(1); System.out.println(String.format(\"当前线程名称: %s, main方法内获取线程内数据为: %s\", Thread.currentThread().getName(), tl.get())); fc(); new Thread(ThreadLocalTest::fc).start();}private static void fc() { System.out.println(String.format(\"当前线程名称: %s, fc方法内获取线程内数据为: %s\", Thread.currentThread().getName(), tl.get()));} 代码块1 运行结果： 123当前线程名称: main, main方法内获取线程内数据为: 1当前线程名称: main, fc方法内获取线程内数据为: 1当前线程名称: Thread-0, fc方法内获取线程内数据为: null 可以看到，main线程内任意地方都可以通过ThreadLocal获取到当前线程内被设置进去的值，而被异步出去的fc调用，却由于替换了执行线程，而拿不到任何数据值，那么我们现在再来改造下上述代码，在异步发生之前，给Thread-0线程也设置一个上下文数据： 12345678910111213141516171819private static ThreadLocal tl = new ThreadLocal&lt;&gt;(); public static void main(String[] args) throws Exception { tl.set(1); System.out.println(String.format(\"当前线程名称: %s, main方法内获取线程内数据为: %s\", Thread.currentThread().getName(), tl.get())); fc(); new Thread(()-&gt;{ tl.set(2); //在子线程里设置上下文内容为2 fc(); }).start(); Thread.sleep(1000L); //保证下面fc执行一定在上面异步代码之后执行 fc(); //继续在主线程内执行，验证上面那一步是否对主线程上下文内容造成影响 } private static void fc() { System.out.println(String.format(\"当前线程名称: %s, fc方法内获取线程内数据为: %s\", Thread.currentThread().getName(), tl.get())); } 代码块2 运行结果为： 1234当前线程名称: main, main方法内获取线程内数据为: 1当前线程名称: main, fc方法内获取线程内数据为: 1当前线程名称: Thread-0, fc方法内获取线程内数据为: 2当前线程名称: main, fc方法内获取线程内数据为: 1 可以看到，主线程和子线程都可以获取到自己的那份上下文里的内容，而且互不影响。 二、原理分析ok，上面通过一个简单的例子，我们可以了解到ThreadLocal（以下简称TL）具体的用法，这里先不讨论它实质上能给我们带来什么好处，先看看其实现原理，等这些差不多了解完了，我再通过我曾经做过的一个项目，去说明TL的作用以及在企业级项目里的用处。 我以前在不了解TL的时候，想着如果让自己实现一个这种功能的轮子，自己会怎么做，那时候的想法很单纯，觉得通过一个Map就可以解决，Map的key设置为Thread.currentThread()，value设置为当前线程的本地变量即可，但后来想想就觉得不太现实了，实际项目中可能存在大量的异步线程，对于内存的开销是不可估量的，而且还有个严重的问题，线程是运行结束后就销毁的，如果按照上述的实现方案，map内是一直持有这个线程的引用的，导致明明执行结束的线程对象不能被jvm回收，造成内存泄漏，时间久了，会直接OOM。 所以，java里的实现肯定不是这么简单的，下面，就来看看java里的具体实现吧。 先来了解下，TL的基本实现，为了避免上述中出现的问题，TL实际上是把我们设置进去的值以k-v的方式放到了每个Thread对象内（TL对象做k，设置的值做v），也就是说，TL对象仅仅起到一个标记、对Thread对象维护的map赋值的作用。 先从set方法看起： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public void set(T value) { Thread t = Thread.currentThread(); //获取当前线程 ThreadLocal.ThreadLocalMap map = getMap(t); //获取到当前线程持有的ThreadLocalMap对象 if (map != null) map.set(this, value); //直接set值，具体方法在下面 else createMap(t, value); // 为空就给当前线程创建一个ThreadLocalMap对象，赋值给Thread对象，具体方法在下面 } ThreadLocal.ThreadLocalMap getMap(Thread t) { return t.threadLocals; //每个线程都有一个ThreadLocalMap，key为TL对象（其实是根据对象hash计算出来的值），value为该线程在此TL对象下存储的内容值 } private void set(ThreadLocal&lt;?&gt; key, Object value) { ThreadLocal.ThreadLocalMap.Entry[] tab = table; //获取存储k-v对象的数组（散列表） int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); //根据TL对象的hashCode（也是特殊计算出来的，保证每个TL对象的hashCode不同）计算出下标 for (ThreadLocal.ThreadLocalMap.Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { //线性探查法解决哈希冲突问题，发现下标i已经有Entry了，则就查看i+1位置处是否有值，以此类推 ThreadLocal&lt;?&gt; k = e.get(); //获取k if (k == key) { //若k就是当前TL对象，则直接为其value赋值 e.value = value; return; } if (k == null) { //若k为空，则认为是可回收的Entry，则利用当前k和value组成新的Entry替换掉该可回收Entry replaceStaleEntry(key, value, i); return; } } //for循环执行完没有终止程序，说明遇到了空槽，这个时候直接new对象赋值即可 tab[i] = new ThreadLocal.ThreadLocalMap.Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) //这里用来清理掉k为null的废弃Entry rehash(); //如果没有发生清除Entry并且size超过阈值（阈值 = 最大长度 * 2/3），则进行扩容 } //直接为当前Thread初始化它的ThreadLocalMap对象 void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocal.ThreadLocalMap(this, firstValue); } ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) { table = new ThreadLocal.ThreadLocalMap.Entry[INITIAL_CAPACITY]; //初始化数组 int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); //计算初始位置 table[i] = new ThreadLocal.ThreadLocalMap.Entry(firstKey, firstValue); //因为初始化不存在hash冲突，直接new size = 1; setThreshold(INITIAL_CAPACITY); //给阈值赋值，上面已经提及，阈值 = 最大长度 * 2/3 } 代码块3 通过上述代码，我们大致了解了TL在set值的时候发生的一些操作，结合之前说的，我们可以确定的是，TL其实对于线程来说，只是一个标识，而真正线程的本地变量被保存在每个线程对象的ThreadLocalMap里，这个map里维护着一个Entry[]的数组（散列表），Entry是个k-v结构的对象（如图1-1），k为TL对象，v为对应TL保存在该线程内的本地变量值，值得注意的是，这里的k针对TL对象的引用是个弱引用，来看下源码： 123456789static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) { super(k); value = v; } } 代码块4 为什么这里需要弱引用呢？我们先来看一张图，结合上面的介绍和这张图，来了解TL和Thread间的关系： 图中虚线表示弱引用，那么为什么要这么做呢？ 简单来说，一个TL对象被创建出来，并且被一个线程放到自己的ThreadLocalMap里，假如TL对象失去原有的强引用，但是该线程还没有死亡，如果k不是弱引用，那么就意味着TL并不能被回收，现在k为弱引用，那么在TL失去强引用的时候，gc可以直接回收掉它，弱引用失效，这就是上面代码里会进行检查，k=null的清除释放内存的原因（这个可以参考下面expungeStaleEntry方法，而且set、get、remove都会调用该方法，这也是TL防止内存泄漏所做的处理）。 综上，简单来说这个弱引用就是用来解决由于使用TL不当导致的内存泄漏问题的，假如没有弱引用，那么你又用到了线程池（池化后线程不会被销毁），然后TL对象又是局部的，那么就会导致线程池内线程里的ThreadLocalMap存在大量的无意义的TL对象引用，造成过多无意义的Entry对象，因为即便调用了set、get等方法检查k=null，也没有作用，这就导致了内存泄漏，长时间这样最终可能导致OOM，所以TL的开发者为了解决这种问题，就将ThreadLocalMap里对TL对象的引用改为弱引用，一旦TL对象失去强引用，TL对象就会被回收，那么这里的弱引用指向的值就为null，结合上面说的，调用操作方法时会检查k=null的Entry进行回收，从而避免了内存泄漏的可能性。 因为TL解决了内存泄漏的问题，因此即便是局部变量的TL对象且启用线程池技术，也比较难造成内存泄漏的问题，而且我们经常使用的场景就像一开始的示例代码一样，会初始化一个全局的static的TL对象，这就意味着该对象在程序运行期间都不会存在强引用消失的情况，我们可以利用不同的TL对象给不同的Thread里的ThreadLocalMap赋值，通常会set值（覆盖原有值），因此在使用线程池的时候也不会造成问题，异步开始之前set值，用完以后remove，TL对象可以多次得到使用，启用线程池的情况下如果不这样做，很可能业务逻辑也会出问题（一个线程存在之前执行程序时遗留下来的本地变量，一旦这个线程被再次利用，get时就会拿到之前的脏值）； 说完了set，我们再来看下get： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public T get() { Thread t = Thread.currentThread(); ThreadLocal.ThreadLocalMap map = getMap(t); //获取线程内的ThreadLocalMap对象 if (map != null) { ThreadLocal.ThreadLocalMap.Entry e = map.getEntry(this); //根据当前TL对象（key）获取对应的Entry if (e != null) { @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; //直接返回value即可 } } return setInitialValue(); //如果发现当前线程还没有ThreadLocalMap对象，则进行初始化 } private ThreadLocal.ThreadLocalMap.Entry getEntry(ThreadLocal&lt;?&gt; key) { int i = key.threadLocalHashCode &amp; (table.length - 1); //计算下标 ThreadLocal.ThreadLocalMap.Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) //根据下标获取的Entry对象如果key也等于当前TL对象，则直接返回结果即可 return e; else return getEntryAfterMiss(key, i, e); //上面说过，有些情况下存在下标冲突的问题，TL是通过线性探查法来解决的，所以这里也一样，如果上面没找到，则继续通过下标累加的方式继续寻找 } private ThreadLocal.ThreadLocalMap.Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, ThreadLocal.ThreadLocalMap.Entry e) { ThreadLocal.ThreadLocalMap.Entry[] tab = table; int len = tab.length; while (e != null) { ThreadLocal&lt;?&gt; k = e.get(); //继续累加下标的方式一点点的往下找 if (k == key) //找到了就返回出去结果 return e; if (k == null) //这里也会检查k==null的Entry，满足就执行删除操作 expungeStaleEntry(i); else //否则继续累加下标查找 i = nextIndex(i, len); e = tab[i]; } return null; //找不到返回null } //这里也放一下nextIndex方法 private static int nextIndex(int i, int len) { return ((i + 1 &lt; len) ? i + 1 : 0); } 代码块5 最后再来看看remove方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public void remove() { ThreadLocal.ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this); //清除掉当前线程ThreadLocalMap里以当前TL对象为key的Entry } private void remove(ThreadLocal&lt;?&gt; key) { ThreadLocal.ThreadLocalMap.Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); //计算下标 for (ThreadLocal.ThreadLocalMap.Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { if (e.get() == key) { //找到目标Entry e.clear(); //清除弱引用 expungeStaleEntry(i); //通过该方法将自己清除 return; } } } private int expungeStaleEntry(int staleSlot) { //参数为目标下标 ThreadLocal.ThreadLocalMap.Entry[] tab = table; int len = tab.length; tab[staleSlot].value = null; //首先将目标value清除 tab[staleSlot] = null; size--; // Rehash until we encounter null ThreadLocal.ThreadLocalMap.Entry e; int i; // 由目标下标开始往后逐个检查，k==null的清除掉，不等于null的要进行rehash for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) { ThreadLocal&lt;?&gt; k = e.get(); if (k == null) { e.value = null; tab[i] = null; size--; } else { int h = k.threadLocalHashCode &amp; (len - 1); if (h != i) { tab[i] = null; // Unlike Knuth 6.4 Algorithm R, we must scan until // null because multiple entries could have been stale. while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; } } } return i; } 代码块6 目前主要方法set、get、remove已经介绍完了，包含其内部存在的弱引用的作用，以及实际项目中建议的用法，以及为什么要这样用，也进行了简要的说明，下面一篇会进行介绍InheritableThreadLocal的用法以及其原理性分析。","link":"/2019/02/15/ThreadLocal%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89-ThreadLocal%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"},{"title":"ThreadLocal系列（三）-TransmittableThreadLocal的使用及原理解析","text":"一、基本使用首先，TTL是用来解决ITL解决不了的问题而诞生的，所以TTL一定是支持父线程的本地变量传递给子线程这种基本操作的，ITL也可以做到，但是前面有讲过，ITL在线程池的模式下，就没办法再正确传递了，所以TTL做出的改进就是即便是在线程池模式下，也可以很好的将父线程本地变量传递下去，先来看个例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// 需要注意的是，使用TTL的时候，要想传递的值不出问题，线程池必须得用TTL加一层代理（下面会讲这样做的目的） private static ExecutorService executorService = TtlExecutors.getTtlExecutorService(Executors.newFixedThreadPool(2)); private static ThreadLocal tl = new TransmittableThreadLocal&lt;&gt;(); //这里采用TTL的实现 public static void main(String[] args) { new Thread(() -&gt; { String mainThreadName = \"main_01\"; tl.set(1); executorService.execute(() -&gt; { sleep(1L); System.out.println(String.format(\"本地变量改变之前(1), 父线程名称-%s, 子线程名称-%s, 变量值=%s\", mainThreadName, Thread.currentThread().getName(), tl.get())); }); executorService.execute(() -&gt; { sleep(1L); System.out.println(String.format(\"本地变量改变之前(1), 父线程名称-%s, 子线程名称-%s, 变量值=%s\", mainThreadName, Thread.currentThread().getName(), tl.get())); }); executorService.execute(() -&gt; { sleep(1L); System.out.println(String.format(\"本地变量改变之前(1), 父线程名称-%s, 子线程名称-%s, 变量值=%s\", mainThreadName, Thread.currentThread().getName(), tl.get())); }); sleep(1L); //确保上面的会在tl.set执行之前执行 tl.set(2); // 等上面的线程池第一次启用完了，父线程再给自己赋值 executorService.execute(() -&gt; { sleep(1L); System.out.println(String.format(\"本地变量改变之后(2), 父线程名称-%s, 子线程名称-%s, 变量值=%s\", mainThreadName, Thread.currentThread().getName(), tl.get())); }); executorService.execute(() -&gt; { sleep(1L); System.out.println(String.format(\"本地变量改变之后(2), 父线程名称-%s, 子线程名称-%s, 变量值=%s\", mainThreadName, Thread.currentThread().getName(), tl.get())); }); executorService.execute(() -&gt; { sleep(1L); System.out.println(String.format(\"本地变量改变之后(2), 父线程名称-%s, 子线程名称-%s, 变量值=%s\", mainThreadName, Thread.currentThread().getName(), tl.get())); }); System.out.println(String.format(\"线程名称-%s, 变量值=%s\", Thread.currentThread().getName(), tl.get())); }).start(); new Thread(() -&gt; { String mainThreadName = \"main_02\"; tl.set(3); executorService.execute(() -&gt; { sleep(1L); System.out.println(String.format(\"本地变量改变之前(3), 父线程名称-%s, 子线程名称-%s, 变量值=%s\", mainThreadName, Thread.currentThread().getName(), tl.get())); }); executorService.execute(() -&gt; { sleep(1L); System.out.println(String.format(\"本地变量改变之前(3), 父线程名称-%s, 子线程名称-%s, 变量值=%s\", mainThreadName, Thread.currentThread().getName(), tl.get())); }); executorService.execute(() -&gt; { sleep(1L); System.out.println(String.format(\"本地变量改变之前(3), 父线程名称-%s, 子线程名称-%s, 变量值=%s\", mainThreadName, Thread.currentThread().getName(), tl.get())); }); sleep(1L); //确保上面的会在tl.set执行之前执行 tl.set(4); // 等上面的线程池第一次启用完了，父线程再给自己赋值 executorService.execute(() -&gt; { sleep(1L); System.out.println(String.format(\"本地变量改变之后(4), 父线程名称-%s, 子线程名称-%s, 变量值=%s\", mainThreadName, Thread.currentThread().getName(), tl.get())); }); executorService.execute(() -&gt; { sleep(1L); System.out.println(String.format(\"本地变量改变之后(4), 父线程名称-%s, 子线程名称-%s, 变量值=%s\", mainThreadName, Thread.currentThread().getName(), tl.get())); }); executorService.execute(() -&gt; { sleep(1L); System.out.println(String.format(\"本地变量改变之后(4), 父线程名称-%s, 子线程名称-%s, 变量值=%s\", mainThreadName, Thread.currentThread().getName(), tl.get())); }); System.out.println(String.format(\"线程名称-%s, 变量值=%s\", Thread.currentThread().getName(), tl.get())); }).start(); } private static void sleep(long time) { try { Thread.sleep(time); } catch (InterruptedException e) { e.printStackTrace(); } } 代码块1 运行结果： 1234567891011121314线程名称-Thread-2, 变量值=4本地变量改变之前(3), 父线程名称-main_02, 子线程名称-pool-1-thread-1, 变量值=3线程名称-Thread-1, 变量值=2本地变量改变之前(1), 父线程名称-main_01, 子线程名称-pool-1-thread-2, 变量值=1本地变量改变之前(1), 父线程名称-main_01, 子线程名称-pool-1-thread-1, 变量值=1本地变量改变之前(3), 父线程名称-main_02, 子线程名称-pool-1-thread-2, 变量值=3本地变量改变之前(3), 父线程名称-main_02, 子线程名称-pool-1-thread-2, 变量值=3本地变量改变之前(1), 父线程名称-main_01, 子线程名称-pool-1-thread-1, 变量值=1本地变量改变之后(2), 父线程名称-main_01, 子线程名称-pool-1-thread-2, 变量值=2本地变量改变之后(4), 父线程名称-main_02, 子线程名称-pool-1-thread-1, 变量值=4本地变量改变之后(4), 父线程名称-main_02, 子线程名称-pool-1-thread-1, 变量值=4本地变量改变之后(4), 父线程名称-main_02, 子线程名称-pool-1-thread-2, 变量值=4本地变量改变之后(2), 父线程名称-main_01, 子线程名称-pool-1-thread-1, 变量值=2本地变量改变之后(2), 父线程名称-main_01, 子线程名称-pool-1-thread-2, 变量值=2 程序有些啰嗦，为了说明问题，加了很多说明，但至少通过上面的例子，不难发现，两个主线程里都使用线程池异步，而且值在主线程里还发生过改变，测试结果展示一切正常，由此可以知道TTL在使用线程池的情况下，也可以很好的完成传递，而且不会发生错乱。 那么是不是对普通线程异步也有这么好的支撑呢？ 改造下上面的测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192private static ThreadLocal tl = new TransmittableThreadLocal&lt;&gt;(); public static void main(String[] args) { new Thread(() -&gt; { String mainThreadName = \"main_01\"; tl.set(1); new Thread(() -&gt; { sleep(1L); System.out.println(String.format(\"本地变量改变之前(1), 父线程名称-%s, 子线程名称-%s, 变量值=%s\", mainThreadName, Thread.currentThread().getName(), tl.get())); }).start(); new Thread(() -&gt; { sleep(1L); System.out.println(String.format(\"本地变量改变之前(1), 父线程名称-%s, 子线程名称-%s, 变量值=%s\", mainThreadName, Thread.currentThread().getName(), tl.get())); }).start(); new Thread(() -&gt; { sleep(1L); System.out.println(String.format(\"本地变量改变之前(1), 父线程名称-%s, 子线程名称-%s, 变量值=%s\", mainThreadName, Thread.currentThread().getName(), tl.get())); }).start(); sleep(1L); //确保上面的会在tl.set执行之前执行 tl.set(2); // 等上面的线程池第一次启用完了，父线程再给自己赋值 new Thread(() -&gt; { sleep(1L); System.out.println(String.format(\"本地变量改变之后(2), 父线程名称-%s, 子线程名称-%s, 变量值=%s\", mainThreadName, Thread.currentThread().getName(), tl.get())); }).start(); new Thread(() -&gt; { sleep(1L); System.out.println(String.format(\"本地变量改变之后(2), 父线程名称-%s, 子线程名称-%s, 变量值=%s\", mainThreadName, Thread.currentThread().getName(), tl.get())); }).start(); new Thread(() -&gt; { sleep(1L); System.out.println(String.format(\"本地变量改变之后(2), 父线程名称-%s, 子线程名称-%s, 变量值=%s\", mainThreadName, Thread.currentThread().getName(), tl.get())); }).start(); System.out.println(String.format(\"线程名称-%s, 变量值=%s\", Thread.currentThread().getName(), tl.get())); }).start(); new Thread(() -&gt; { String mainThreadName = \"main_02\"; tl.set(3); new Thread(() -&gt; { sleep(1L); System.out.println(String.format(\"本地变量改变之前(3), 父线程名称-%s, 子线程名称-%s, 变量值=%s\", mainThreadName, Thread.currentThread().getName(), tl.get())); }).start(); new Thread(() -&gt; { sleep(1L); System.out.println(String.format(\"本地变量改变之前(3), 父线程名称-%s, 子线程名称-%s, 变量值=%s\", mainThreadName, Thread.currentThread().getName(), tl.get())); }).start(); new Thread(() -&gt; { sleep(1L); System.out.println(String.format(\"本地变量改变之前(3), 父线程名称-%s, 子线程名称-%s, 变量值=%s\", mainThreadName, Thread.currentThread().getName(), tl.get())); }).start(); sleep(1L); //确保上面的会在tl.set执行之前执行 tl.set(4); // 等上面的线程池第一次启用完了，父线程再给自己赋值 new Thread(() -&gt; { sleep(1L); System.out.println(String.format(\"本地变量改变之后(4), 父线程名称-%s, 子线程名称-%s, 变量值=%s\", mainThreadName, Thread.currentThread().getName(), tl.get())); }).start(); new Thread(() -&gt; { sleep(1L); System.out.println(String.format(\"本地变量改变之后(4), 父线程名称-%s, 子线程名称-%s, 变量值=%s\", mainThreadName, Thread.currentThread().getName(), tl.get())); }).start(); new Thread(() -&gt; { sleep(1L); System.out.println(String.format(\"本地变量改变之后(4), 父线程名称-%s, 子线程名称-%s, 变量值=%s\", mainThreadName, Thread.currentThread().getName(), tl.get())); }).start(); System.out.println(String.format(\"线程名称-%s, 变量值=%s\", Thread.currentThread().getName(), tl.get())); }).start(); } 代码块2 相比代码块1，这一段的异步全都是普通异步，未采用线程池的方式进行异步，看下运行结果： 1234567891011121314本地变量改变之后(4), 父线程名称-main_02, 子线程名称-Thread-14, 变量值=4本地变量改变之前(1), 父线程名称-main_01, 子线程名称-Thread-5, 变量值=1线程名称-Thread-1, 变量值=2本地变量改变之前(1), 父线程名称-main_01, 子线程名称-Thread-3, 变量值=1本地变量改变之后(2), 父线程名称-main_01, 子线程名称-Thread-11, 变量值=2本地变量改变之前(3), 父线程名称-main_02, 子线程名称-Thread-6, 变量值=3本地变量改变之后(4), 父线程名称-main_02, 子线程名称-Thread-12, 变量值=4本地变量改变之后(4), 父线程名称-main_02, 子线程名称-Thread-10, 变量值=4本地变量改变之前(3), 父线程名称-main_02, 子线程名称-Thread-8, 变量值=3本地变量改变之前(3), 父线程名称-main_02, 子线程名称-Thread-4, 变量值=3本地变量改变之前(1), 父线程名称-main_01, 子线程名称-Thread-7, 变量值=1线程名称-Thread-2, 变量值=4本地变量改变之后(2), 父线程名称-main_01, 子线程名称-Thread-9, 变量值=2本地变量改变之后(2), 父线程名称-main_01, 子线程名称-Thread-13, 变量值=2 ok，可以看到，达到了跟第一个测试一致的结果。 到这里，通过上述两个例子，TTL的基本使用，以及其解决的问题，我们已经有了初步的了解，下面我们来解析一下其内部原理，看看TTL是怎么完成对ITL的优化的。 二、原理分析先来看TTL里面的几个重要属性及方法 TTL定义： 1public class TransmittableThreadLocal extends InheritableThreadLocal 代码块3 可以看到，TTL继承了ITL，意味着TTL首先具备ITL的功能。 再来看看一个重要属性holder： 12345678910111213141516/** * 这是一个ITL类型的对象，持有一个全局的WeakMap（weakMap的key是弱引用，同TL一样，也是为了解决内存泄漏的问题），里面存放了TTL对象 * 并且重写了initialValue和childValue方法，尤其是childValue，可以看到在即将异步时父线程的属性是直接作为初始化值赋值给子线程的本地变量对象（TTL）的 */ private static InheritableThreadLocal&lt;Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt; holder = new InheritableThreadLocal&lt;Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt;() { @Override protected Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; initialValue() { return new WeakHashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;(); } @Override protected Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; childValue(Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; parentValue) { return new WeakHashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;(parentValue); } }; 代码块4 再来看下set和get： 123456789101112131415161718192021222324//下面的方法均属于TTL类@Override public final void set(T value) { super.set(value); if (null == value) removeValue(); else addValue(); } @Override public final T get() { T value = super.get(); if (null != value) addValue(); return value; } private void removeValue() { holder.get().remove(this); //从holder持有的map对象中移除 } private void addValue() { if (!holder.get().containsKey(this)) { holder.get().put(this, null); //从holder持有的map对象中添加 } } 代码块5 TTL里先了解上述的几个方法及对象，可以看出，单纯的使用TTL是达不到支持线程池本地变量的传递的，通过第一部分的例子，可以发现，除了要启用TTL，还需要通过TtlExecutors.getTtlExecutorService包装一下线程池才可以，那么，下面就来看看在程序即将通过线程池异步的时候，TTL帮我们做了哪些操作（这一部分是TTL支持线程池传递的核心部分）： 首先打开包装类，看下execute方法在执行时做了些什么。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 此方法属于线程池包装类ExecutorTtlWrapper@Override public void execute(@Nonnull Runnable command) { executor.execute(TtlRunnable.get(command)); //这里会把Rannable包装一层，这是关键，有些逻辑处理，需要在run之前执行 } // 对应上面的get方法，返回一个TtlRunnable对象，属于TtLRannable包装类 @Nullable public static TtlRunnable get(@Nullable Runnable runnable) { return get(runnable, false, false); } // 对应上面的get方法 @Nullable public static TtlRunnable get(@Nullable Runnable runnable, boolean releaseTtlValueReferenceAfterRun, boolean idempotent) { if (null == runnable) return null; if (runnable instanceof TtlEnhanced) { // 若发现已经是目标类型了（说明已经被包装过了）直接返回 // avoid redundant decoration, and ensure idempotency if (idempotent) return (TtlRunnable) runnable; else throw new IllegalStateException(\"Already TtlRunnable!\"); } return new TtlRunnable(runnable, releaseTtlValueReferenceAfterRun); //最终初始化 } // 对应上面的TtlRunnable方法 private TtlRunnable(@Nonnull Runnable runnable, boolean releaseTtlValueReferenceAfterRun) { this.capturedRef = new AtomicReference&lt;Object&gt;(capture()); //这里将捕获后的父线程本地变量存储在当前对象的capturedRef里 this.runnable = runnable; this.releaseTtlValueReferenceAfterRun = releaseTtlValueReferenceAfterRun; } // 对应上面的capture方法，用于捕获当前线程（父线程）里的本地变量，此方法属于TTL的静态内部类Transmitter @Nonnull public static Object capture() { Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; captured = new HashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;(); for (TransmittableThreadLocal&lt;?&gt; threadLocal : holder.get().keySet()) { // holder里目前存放的k-v里的key，就是需要传给子线程的TTL对象 captured.put(threadLocal, threadLocal.copyValue()); } return captured; // 这里返回的这个对象，就是当前将要使用线程池异步出来的子线程，所继承的本地变量合集 } // 对应上面的copyValue，简单的将TTL对象里的值返回（结合之前的源码可以知道get方法其实就是获取当前线程（父线程）里的值，调用super.get方法） private T copyValue() { return copy(get()); } protected T copy(T parentValue) { return parentValue; } 代码块6 结合上述代码，大致知道了在线程池异步之前需要做的事情，其实就是把当前父线程里的本地变量取出来，然后赋值给Rannable包装类里的capturedRef属性，到此为止，下面会发生什么，我们大致上可以猜出来了，接下来大概率会在run方法里，将这些捕获到的值赋给子线程的holder赋对应的TTL值，那么我们继续往下看Rannable包装类里的run方法是怎么实现的： 1234567891011121314151617181920//run方法属于Rannable的包装类TtlRunnable@Override public void run() { Object captured = capturedRef.get(); // 获取由之前捕获到的父线程变量集 if (captured == null || releaseTtlValueReferenceAfterRun &amp;&amp; !capturedRef.compareAndSet(captured, null)) { throw new IllegalStateException(\"TTL value reference is released after run!\"); } /** * 重点方法replay，此方法用来给当前子线程赋本地变量，返回的backup是此子线程原来就有的本地变量值（原生本地变量，下面会详细讲）， * backup用于恢复数据（如果任务执行完毕，意味着该子线程会归还线程池，那么需要将其原生本地变量属性恢复） */ Object backup = replay(captured); try { runnable.run(); // 执行异步逻辑 } finally { restore(backup); // 结合上面对于replay的解释，不难理解，这个方法就是用来恢复原有值的 } } 代码块7 根据上述代码，我们看到了TTL在异步任务执行前，会先进行赋值操作（就是拿着异步发生时捕获到的父线程的本地变量，赋给自己），当任务执行完，就恢复原生的自己本身的线程变量值。 下面来具体看这俩方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//下面的方法均属于TTL的静态内部类Transmittable@Nonnull public static Object replay(@Nonnull Object captured) { @SuppressWarnings(\"unchecked\") Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; capturedMap = (Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;) captured; //使用此线程异步时捕获到的父线程里的本地变量值 Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; backup = new HashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;(); //当前线程原生的本地变量，用于使用完线程后恢复用 //注意：这里循环的是当前子线程原生的本地变量集合，与本方法相反，restore方法里循环这个holder是指：该线程运行期间产生的变量+父线程继承来的变量 for (Iterator&lt;? extends Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt; iterator = holder.get().entrySet().iterator(); iterator.hasNext(); ) { Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; next = iterator.next(); TransmittableThreadLocal&lt;?&gt; threadLocal = next.getKey(); backup.put(threadLocal, threadLocal.get()); // 所有原生的本地变量都暂时存储在backup里，用于之后恢复用 /** * 检查，如果捕获到的线程变量里，不包含当前原生变量值，则从当前原生变量里清除掉，对应的线程本地变量也清掉 * 这就是为什么会将原生变量保存在backup里的原因，为了恢复原生值使用 * 那么，为什么这里要清除掉呢？因为从使用这个子线程做异步那里，捕获到的本地变量并不包含原生的变量，当前线程 * 在做任务时的首要目标，是将父线程里的变量完全传递给任务，如果不清除这个子线程原生的本地变量， * 意味着很可能会影响到任务里取值的准确性。 * * 打个比方，有ttl对象tl，这个tl在线程池的某个子线程里存在对应的值2，当某个主线程使用该子线程做异步任务时 * tl这个对象在当前主线程里没有值，那么如果不进行下面这一步的操作，那么在使用该子线程做的任务里就可以通过 * 该tl对象取到值2，不符合预期 */ if (!capturedMap.containsKey(threadLocal)) { iterator.remove(); threadLocal.superRemove(); } } // 这一步就是直接把父线程本地变量赋值给当前线程了（这一步起就刷新了holder里的值了，具体往下看该方法，在异步线程运行期间，还可能产生别的本地变量，比如在真正的run方法内的业务代码，再用一个tl对象设置一个值） setTtlValuesTo(capturedMap); // 这个方法属于扩展方法，ttl本身支持重写异步任务执行前后的操作，这里不再具体赘述 doExecuteCallback(true); return backup; } // 结合之前Rannable包装类的run方法来看，这个方法就是使用上面replay记录下的原生线程变量做恢复用的 public static void restore(@Nonnull Object backup) { @SuppressWarnings(\"unchecked\") Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; backupMap = (Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;) backup; // call afterExecute callback doExecuteCallback(false); // 注意，这里的holder取出来的，实际上是replay方法设置进去的关于父线程里的所有变量（结合上面来看，就是：该线程运行期间产生的变量+父线程继承来的变量） for (Iterator&lt;? extends Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt; iterator = holder.get().entrySet().iterator(); iterator.hasNext(); ) { Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; next = iterator.next(); TransmittableThreadLocal&lt;?&gt; threadLocal = next.getKey(); /** * 同样的，如果子线程原生变量不包含某个父线程传来的对象，那么就删除，可以思考下，这里的清除跟上面replay里的有什么不同？ * 这里会把不属于原生变量的对象给删除掉（这里被删除掉的可能是父线程继承下来的，也可能是异步任务在执行时产生的新值） */ if (!backupMap.containsKey(threadLocal)) { iterator.remove(); threadLocal.superRemove(); } } // 同样调用这个方法，进行值的恢复 setTtlValuesTo(backupMap); } // 真正给当前子线程赋值的方法，对应上面的setTtlValuesTo方法 private static void setTtlValuesTo(@Nonnull Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; ttlValues) { for (Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; entry : ttlValues.entrySet()) { @SuppressWarnings(\"unchecked\") TransmittableThreadLocal&lt;Object&gt; threadLocal = (TransmittableThreadLocal&lt;Object&gt;) entry.getKey(); threadLocal.set(entry.getValue()); //赋值，注意，从这里开始，子线程的holder里的值会被重新赋值刷新，可以参照上面ttl的set方法的实现 } } 代码块8 ok，到这里基本上把TTL比较核心的代码看完了，下面整理下整个流程，这是官方给出的时序图： 上图第一行指的是类名称，下面的流程指的是类所做的事情，根据上面罗列出来的源码，结合这个时序图，可以比较直观一些的理解整个流程。 三、TTL中线程池子线程原生变量的产生这一节是为了验证上面replay和restore，现在通过一个例子来验证下，先把源码down下来，在源码的restore和replay上分别加上输出语句，遍历holder： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//replay前后打印holder里面的值public static Object replay(@Nonnull Object captured) { @SuppressWarnings(\"unchecked\") Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; capturedMap = (Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;) captured; Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; backup = new HashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;(); System.out.println(\"--------------------replay前置，当前拿到的holder里的TTL列表\"); for (Iterator&lt;? extends Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt; iterator = holder.get().entrySet().iterator(); iterator.hasNext(); ) { Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; next = iterator.next(); TransmittableThreadLocal&lt;?&gt; threadLocal = next.getKey(); System.out.println(String.format(\"replay前置里拿到原生的ttl_k=%s, ttl_value=%s\", threadLocal.hashCode(), threadLocal.get())); } for...//代码省略，具体看上面 setTtlValuesTo(capturedMap); doExecuteCallback(true); System.out.println(\"--------------------reply后置，当前拿到的holder里的TTL列表\"); for (Iterator&lt;? extends Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt; iterator = holder.get().entrySet().iterator(); iterator.hasNext(); ) { Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; next = iterator.next(); TransmittableThreadLocal&lt;?&gt; threadLocal = next.getKey(); System.out.println(String.format(\"replay后置里拿到原生的ttl_k=%s, ttl_value=%s\", threadLocal.hashCode(), threadLocal.get())); } return backup; }//restore前后打印holder里面的值public static void restore(@Nonnull Object backup) { @SuppressWarnings(\"unchecked\") Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; backupMap = (Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;) backup; // call afterExecute callback doExecuteCallback(false); System.out.println(\"--------------------restore前置，当前拿到的holder里的TTL列表\"); for (Iterator&lt;? extends Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt; iterator = holder.get().entrySet().iterator(); iterator.hasNext(); ) { Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; next = iterator.next(); TransmittableThreadLocal&lt;?&gt; threadLocal = next.getKey(); System.out.println(String.format(\"restore前置里拿到当前线程内变量，ttl_k=%s, ttl_value=%s\", threadLocal.hashCode(), threadLocal.get())); } for...//省略代码，具体具体看上面 setTtlValuesTo(backupMap); System.out.println(\"--------------------restore后置，当前拿到的holder里的TTL列表\"); for (Iterator&lt;? extends Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt; iterator = holder.get().entrySet().iterator(); iterator.hasNext(); ) { Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; next = iterator.next(); TransmittableThreadLocal&lt;?&gt; threadLocal = next.getKey(); System.out.println(String.format(\"restore后置里拿到当前线程内变量，ttl_k=%s, ttl_value=%s\", threadLocal.hashCode(), threadLocal.get())); } } 代码块9 代码这样做的目的，就是要说明线程池所谓的原生本地变量是怎么产生的，以及replay和restore是怎么设置和恢复的，下面来看个简单的例子： 123456789101112131415161718192021private static ExecutorService executorService = TtlExecutors.getTtlExecutorService(Executors.newFixedThreadPool(1)); private static ThreadLocal tl = new TransmittableThreadLocal(); private static ThreadLocal tl2 = new TransmittableThreadLocal(); public static void main(String[] args) throws InterruptedException { tl.set(1); tl2.set(2); executorService.execute(new Runnable() { @Override public void run() { try { Thread.sleep(1000L); } catch (InterruptedException e) { e.printStackTrace(); } } }); } 代码块10 运行结果如下： 123456789101112--------------------replay前置，当前拿到的holder里的TTL列表replay前置里拿到原生的ttl_k=1259475182, ttl_value=2replay前置里拿到原生的ttl_k=929338653, ttl_value=1--------------------reply后置，当前拿到的holder里的TTL列表replay后置里拿到原生的ttl_k=1259475182, ttl_value=2replay后置里拿到原生的ttl_k=929338653, ttl_value=1--------------------restore前置，当前拿到的holder里的TTL列表restore前置里拿到当前线程内变量，ttl_k=1259475182, ttl_value=2restore前置里拿到当前线程内变量，ttl_k=929338653, ttl_value=1--------------------restore后置，当前拿到的holder里的TTL列表restore后置里拿到当前线程内变量，ttl_k=1259475182, ttl_value=2restore后置里拿到当前线程内变量，ttl_k=929338653, ttl_value=1 我们会发现，原生值产生了，从异步开始，就确定了线程池里的线程具备了1和2的值，那么，再来改动下上面的测试代码： 12345678910111213141516171819202122232425262728293031public static void main(String[] args) throws InterruptedException { tl.set(1); executorService.execute(new Runnable() { @Override public void run() { try { Thread.sleep(100L); } catch (InterruptedException e) { e.printStackTrace(); } } }); Thread.sleep(1000L); tl2.set(2);//较第一次换下位置，换到第一次使用线程池后执行（这意味着下面这次异步不会再触发Thread的init方法了） System.out.println(\"---------------------------------------------------------------------------------\"); executorService.execute(new Runnable() { @Override public void run() { try { Thread.sleep(1000L); } catch (InterruptedException e) { e.printStackTrace(); } } }); } 代码块11 运行结果为： 12345678910111213141516171819--------------------replay前置，当前拿到的holder里的TTL列表replay前置里拿到原生的ttl_k=929338653, ttl_value=1--------------------reply后置，当前拿到的holder里的TTL列表replay后置里拿到原生的ttl_k=929338653, ttl_value=1--------------------restore前置，当前拿到的holder里的TTL列表restore前置里拿到当前线程内变量，ttl_k=929338653, ttl_value=1--------------------restore后置，当前拿到的holder里的TTL列表restore后置里拿到当前线程内变量，ttl_k=929338653, ttl_value=1-----------------------------------------------------------------------------------------------------replay前置，当前拿到的holder里的TTL列表replay前置里拿到原生的ttl_k=929338653, ttl_value=1--------------------reply后置，当前拿到的holder里的TTL列表replay后置里拿到原生的ttl_k=1020371697, ttl_value=2replay后置里拿到原生的ttl_k=929338653, ttl_value=1--------------------restore前置，当前拿到的holder里的TTL列表restore前置里拿到当前线程内变量，ttl_k=1020371697, ttl_value=2restore前置里拿到当前线程内变量，ttl_k=929338653, ttl_value=1--------------------restore后置，当前拿到的holder里的TTL列表restore后置里拿到当前线程内变量，ttl_k=929338653, ttl_value=1 可以发现，第一次异步时，只有一个值被传递了下去，然后第二次异步，新加了一个tl2的值，但是看第二次异步的打印，会发现，restore恢复后，仍然是第一次异步发生时放进去的那个tl的值。 通过上面的例子，基本可以确认，所谓线程池内线程的本地原生变量，其实是第一次使用线程时被传递进去的值，我们之前有说过TTL是继承至ITL的，之前的文章也说过，线程池第一次启用时是会触发Thread的init方法的，也就是说，在第一次异步时拿到的主线程的变量会被传递给子线程，作为子线程的原生本地变量保存起来，后续是replay操作和restore操作也是围绕着这个原生变量（即原生holder里的值）来进行设置、恢复的，设置的是当前父线程捕获到的本地变量，恢复的是子线程原生本地变量。 holder里持有的可以理解就是当前线程内的所有本地变量，当子线程将异步任务执行完毕后，会执行restore进行恢复原生本地变量，具体参照上面的代码和测试代码。 四、总结到这里基本上确认了TTL是如何进行线程池传值的，以及被包装的run方法执行异步任务之前，会使用replay进行设置父线程里的本地变量给当前子线程，任务执行完毕，会调用restore恢复该子线程原生的本地变量（目前原生本地变量的产生，就只碰到上述测试代码中的这一种情况，即线程第一次使用时通过ITL属性以及Thread的init方法传给子线程，还不太清楚有没有其他方式设置）。 其实，正常程序里想要完成线程池上下文传递，使用TL就足够了，我们可以效仿TTL包装线程池对象的原理，进行值传递，异步任务结束后，再remove，以此类推来完成线程池值传递，不过这种方式过于单纯，且要求上下文为只读对象，否则子线程存在写操作，就会发生上下文污染。 TTL项目地址（可以详细了解下它的其他特性和用法）：https://github.com/alibaba/transmittable-thread-local","link":"/2019/02/20/ThreadLocal%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89-TransmittableThreadLocal%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"},{"title":"ThreadLocal系列（二）-InheritableThreadLocal的使用及原理解析","text":"一、基本使用我们继续来看之前写的例子： 123456789101112131415161718private static ThreadLocal tl = new ThreadLocal&lt;&gt;();public static void main(String[] args) throws Exception { tl.set(1); System.out.println(String.format(\"当前线程名称: %s, main方法内获取线程内数据为: %s\", Thread.currentThread().getName(), tl.get())); fc(); new Thread(() -&gt; { fc(); }).start(); Thread.sleep(1000L); //保证下面fc执行一定在上面异步代码之后执行 fc(); //继续在主线程内执行，验证上面那一步是否对主线程上下文内容造成影响 } private static void fc() { System.out.println(String.format(\"当前线程名称: %s, fc方法内获取线程内数据为: %s\", Thread.currentThread().getName(), tl.get())); } 代码块1 输出为： 1234当前线程名称: main, main方法内获取线程内数据为: 1当前线程名称: main, fc方法内获取线程内数据为: 1当前线程名称: Thread-0, fc方法内获取线程内数据为: null当前线程名称: main, fc方法内获取线程内数据为: 1 我们会发现，父线程的本地变量是无法传递给子线程的，这当然是正常的，因为线程本地变量来就不应该相互有交集，但是有些时候，我们的确是需要子线程里仍然可以获取到父线程里的本地变量，现在就需要借助TL的一个子类：InheritableThreadLocal（下面简称ITL），来完成上述要求 现在我们将例子里的 1private static ThreadLocal tl = new ThreadLocal&lt;&gt;(); 代码块2 改为： 1private static ThreadLocal tl = new InheritableThreadLocal&lt;&gt;(); 代码块3 然后我们再来运行下结果： 1234当前线程名称: main, main方法内获取线程内数据为: 1当前线程名称: main, fc方法内获取线程内数据为: 1当前线程名称: Thread-0, fc方法内获取线程内数据为: 1当前线程名称: main, fc方法内获取线程内数据为: 1 可以发现，子线程里已经可以获得父线程里的本地变量了。 结合之前讲的TL的实现，简单理解起来并不难，基本可以认定，是在创建子线程的时候，父线程的ThreadLocalMap（下面简称TLMap）里的值递给了子线程，子线程针对上述tl对象持有的k-v进行了copy，其实这里不是真正意义上对象copy，只是给v的值多了一条子线程TLMap的引用而已，v的值在父子线程里指向的均是同一个对象，因此任意线程改了这个值，对其他线程是可见的，为了验证这一点，我们可以改造以上测试代码： 12345678910111213141516171819202122232425private static ThreadLocal tl = new InheritableThreadLocal&lt;&gt;(); private static ThreadLocal tl2 = new InheritableThreadLocal&lt;&gt;(); public static void main(String[] args) throws Exception { tl.set(1); Hello hello = new Hello(); hello.setName(\"init\"); tl2.set(hello); System.out.println(String.format(\"当前线程名称: %s, main方法内获取线程内数据为: tl = %s，tl2.name = %s\", Thread.currentThread().getName(), tl.get(), tl2.get().getName())); fc(); new Thread(() -&gt; { Hello hello1 = tl2.get(); hello1.setName(\"init2\"); fc(); }).start(); Thread.sleep(1000L); //保证下面fc执行一定在上面异步代码之后执行 fc(); //继续在主线程内执行，验证上面那一步是否对主线程上下文内容造成影响 } private static void fc() { System.out.println(String.format(\"当前线程名称: %s, fc方法内获取线程内数据为: tl = %s，tl2.name = %s\", Thread.currentThread().getName(), tl.get(), tl2.get().getName())); } 代码块4 输出结果为： 1234当前线程名称: main, main方法内获取线程内数据为: tl = 1，tl2.name = init当前线程名称: main, fc方法内获取线程内数据为: tl = 1，tl2.name = init当前线程名称: Thread-0, fc方法内获取线程内数据为: tl = 1，tl2.name = init2当前线程名称: main, fc方法内获取线程内数据为: tl = 1，tl2.name = init2 可以确认，子线程里持有的本地变量跟父线程里那个是同一个对象。 二、原理分析通过上述的测试代码，基本可以确定父线程的TLMap被传递到了下一级，那么我们基本可以确认ITL是TL派生出来专门解决线程本地变量父传子问题的，那么下面通过源码来分析一下ITL到底是怎么完成这个操作的。 先来了解下Thread类，上节说到，其实最终线程本地变量是通过TLMap存储在Thread对象内的，那么来看下Thread对象内关于TLMap的两个属性： 12ThreadLocal.ThreadLocalMap threadLocals = null;ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; 代码块5 Thread类里其实有两个TLMap属性，第一个就是普通TL对象为其赋值，第二个则由ITL对象为其赋值，来看下TL的set方法的实现，这次针对该方法介绍下TL子类的相关方法实现： 123456789101112131415161718192021// TL的set方法，如果是子类的实现，那么获取（getMap）和初始化赋值（createMap）都是ITL对象里的方法 // 其余操作不变（因为hash计算、查找、扩容都是TLMap里需要做的，这里子类ITL只起到一个为Thread对象里哪个TLMap属性赋值的作用） public void set(T value) { Thread t = Thread.currentThread(); ThreadLocal.ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } // ITL里getMap方法的实现 ThreadLocal.ThreadLocalMap getMap(Thread t) { return t.inheritableThreadLocals; //返回的其实是Thread对象的inheritableThreadLocals属性 } // ITL里createMap方法的实现 void createMap(Thread t, T firstValue) { // 也是给Thread的inheritableThreadLocals属性赋值 t.inheritableThreadLocals = new ThreadLocal.ThreadLocalMap(this, firstValue); } 代码块6 而inheritableThreadLocals里的信息通过Thread的init方法是可以被传递下去的： 123456789101112131415161718192021222324252627282930313233343536373839404142// 初始化一个Thread对象时的代码段（Thread类的init方法） Thread parent = currentThread(); if (parent.inheritableThreadLocals != null){ //可以看到，如果父线程存在inheritableThreadLocals的时候，会赋值给子线程（当前正在被初始化的线程） // 利用父线程的TLMap对象，初始化一个TLMap，赋值给自己的inheritableThreadLocals（这就意味着这个TLMap里的值会一直被传递下去） this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); } // 看下TL里对应的方法 static ThreadLocal.ThreadLocalMap createInheritedMap(ThreadLocal.ThreadLocalMap parentMap) { return new ThreadLocal.ThreadLocalMap(parentMap); //这里就开始初始化TLMap对象了 } // 根据parentMap来进行初始化子线程的TLMap对象 private ThreadLocalMap(ThreadLocal.ThreadLocalMap parentMap) { ThreadLocal.ThreadLocalMap.Entry[] parentTable = parentMap.table; //拿到父线程里的哈希表 int len = parentTable.length; setThreshold(len); // 设置阈值（具体方法参考上一篇） table = new ThreadLocal.ThreadLocalMap.Entry[len]; for (int j = 0; j &lt; len; j++) { ThreadLocal.ThreadLocalMap.Entry e = parentTable[j]; //将父线程里的Entry取出 if (e != null) { @SuppressWarnings(\"unchecked\") ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get(); //获取key if (key != null) { Object value = key.childValue(e.value); //获取value ThreadLocal.ThreadLocalMap.Entry c = new ThreadLocal.ThreadLocalMap.Entry(key, value); //根据k-v重新生成一个Entry int h = key.threadLocalHashCode &amp; (len - 1); //计算哈希值 while (table[h] != null) h = nextIndex(h, len); //线性探查解决哈希冲突问题（具体方法参考上一篇） table[h] = c; //找到合适的位置后进行赋值 size++; } } } } // ITL里的childValue的实现 protected T childValue(T parentValue) { return parentValue; //直接将父线程里的值返回 } 代码块7 三、ITL所带来的的问题看过上述代码后，现在关于ITL的实现我们基本上有了清晰的认识了，根据其实现性质，可以总结出在使用ITL时可能存在的问题： 3.1：线程不安全 写在前面：这里讨论的线程不安全对象不包含Integer等类型，因为这种对象被重新赋值，变掉的是整个引用，这里说的是那种不改变对象引用，直接可以修改其内容的对象（典型的就是自定义对象的set方法） 如果说线程本地变量是只读变量不会受到影响，但是如果是可写的，那么任意子线程针对本地变量的修改都会影响到主线程的本地变量（本质上是同一个对象），参考上面的第三个例子，子线程写入后会覆盖掉主线程的变量，也是通过这个结果，我们确认了子线程TLMap里变量指向的对象和父线程是同一个。 3.2：线程池中可能失效按照上述实现，在使用线程池的时候，ITL会完全失效，因为父线程的TLMap是通过init一个Thread的时候进行赋值给子线程的，而线程池在执行异步任务时可能不再需要创建新的线程了，因此也就不会再传递父线程的TLMap给子线程了。 针对上述2，我们来做个实验，来证明下猜想： 123456789101112131415161718192021// 为了方便观察，我们假定线程池里只有一个线程 private static ExecutorService executorService = Executors.newFixedThreadPool(1); private static ThreadLocal tl = new InheritableThreadLocal&lt;&gt;(); public static void main(String[] args) { tl.set(1); System.out.println(String.format(\"线程名称-%s, 变量值=%s\", Thread.currentThread().getName(), tl.get())); executorService.execute(()-&gt;{ System.out.println(String.format(\"线程名称-%s, 变量值=%s\", Thread.currentThread().getName(), tl.get())); }); executorService.execute(()-&gt;{ System.out.println(String.format(\"线程名称-%s, 变量值=%s\", Thread.currentThread().getName(), tl.get())); }); System.out.println(String.format(\"线程名称-%s, 变量值=%s\", Thread.currentThread().getName(), tl.get())); } 代码块8 输出结果为： 1234线程名称-main, 变量值=1线程名称-pool-1-thread-1, 变量值=1线程名称-main, 变量值=1线程名称-pool-1-thread-1, 变量值=1 会发现，并没有什么问题，和我们预想的并不一样，原因是什么呢？因为线程池本身存在一个初始化的过程，第一次使用的时候发现里面的线程数（worker数）少于核心线程数时，会进行创建线程，既然是创建线程，一定会执行Thread的init方法，参考上面提到的源码，在第一次启用线程池的时候，类似做了一次new Thread的操作，因此是没有什么问题的，父线程的TLMap依然可以传递下去。 现在我们改造下代码，把tl.set(1)改到第一次启用线程池的下面一行，然后再看看： 12345678910111213141516public static void main(String[] args) throws Exception{ System.out.println(String.format(\"线程名称-%s, 变量值=%s\", Thread.currentThread().getName(), tl.get())); executorService.execute(()-&gt;{ System.out.println(String.format(\"线程名称-%s, 变量值=%s\", Thread.currentThread().getName(), tl.get())); }); tl.set(1); // 等上面的线程池第一次启用完了，父线程再给自己赋值 executorService.execute(()-&gt;{ System.out.println(String.format(\"线程名称-%s, 变量值=%s\", Thread.currentThread().getName(), tl.get())); }); System.out.println(String.format(\"线程名称-%s, 变量值=%s\", Thread.currentThread().getName(), tl.get())); } 代码块9 输出结果为： 1234线程名称-main, 变量值=null线程名称-main, 变量值=1线程名称-pool-1-thread-1, 变量值=null线程名称-pool-1-thread-1, 变量值=null 很明显，第一次启用时没有递进去的值，在后续的子线程启动时就再也传递不进去了。 尾声但是，在实际项目中我们大多数采用线程池进行做异步任务，假如真的需要传递主线程的本地变量，使用ITL的问题显然是很大的，因为是有极大可能性拿不到任何值的，显然在实际项目中，ITL的位置实在是尴尬，所以在启用线程池的情况下，不建议使用ITL做值传递。为了解决这种问题，阿里做了transmittable-thread-local（TTL）来解决线程池异步值传递问题，下一篇，我们将会分析TTL的用法及原理。","link":"/2019/02/19/ThreadLocal%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89-InheritableThreadLocal%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"},{"title":"java实现二叉树","text":"定义一个节点下面最多拥有两个子节点，并且两个子节点分为左值和右值，左值比父节点要小，右值比父节点要大 java实现下面，我们来利用java实现一棵如下图中的二叉树： 大家可以根据我的描述分析一下这棵二叉树 下面就来写代码实现这棵二叉树： 首先是要建立一个节点类Node： 123456789101112131415161718192021222324252627282930313233343536package Tree;/** * 节点类 * @author javadaodechengxuyuan * */public class Node { private long value; private Node leftNode;//节点下面的左节点 private Node RightNode;//节点下面的右节点 //构造器 public Node(long value){ this.value=value; } public long getValue() { return value; } public void setValue(long value) { this.value = value; } public Node getLeftNode() { return leftNode; } public void setLeftNode(Node leftNode) { this.leftNode = leftNode; } public Node getRightNode() { return RightNode; } public void setRightNode(Node rightNode) { RightNode = rightNode; }} 代码块1 这是二叉树类，就是这个类用来操作节点类的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package Tree;/** * @author javadaodechengxuyuan * 二叉树：每个节点有最多两个分叉， * 分别作为父节点的左值和右值，遵循左小右大的规则进行分叉 */public class Tree { private Node root; private Node current; private Node parent; /** * @author javadaodechengxuyuan * 为一颗二叉树添加节点 */ public void insert(long value){//为二叉树插入新的节点 //创建新的节点 Node newNode=new Node(value); //创建完后就该考虑把这个节点放在哪里了，下面这些代码就是用来判断将这个节点放在哪里的 if(root==null){ this.root=newNode;//如果root为空，那么第一次调用添加时应给root初始化 }else{ this.current=root;//初始化current while(true){//进入死循环，一直等到给newNode找到合适的位置时进行终止死循环 if(this.current.getValue()&gt;value){//比root小，放在左侧 this.parent=this.current;//让parent一直保留本次的current this.current=this.current.getLeftNode(); if(this.current==null){//如果当前的左值为空，那么就终止循环并赋值给这个左值 this.parent.setLeftNode(newNode);//将这个新节点放在这个位置 return;//最终找到合适位置，死循环终止 } }else{//比root大，放在右侧 this.parent=this.current;//让parent一直保留本次的current this.current=this.current.getRightNode();//将当前的节点重新赋值给下一次需要比较的节点 if(this.current==null){//如果当前的右值为空，那么就终止循环并赋值给这个左值 this.parent.setRightNode(newNode);//将这个新节点放在这个位置 return;//最终找到合适位置，死循环终止 } } } } } public Node getRoot() { return root; } public void setRoot(Node root) { this.root = root; }} 代码块2 这是测试类： 12345678910111213141516171819202122package Tree;/** * 测试类 * @author javadaodechengxuyuan * */public class Test { public static void main(String args[]){ Tree t=new Tree(); t.insert(10);//根节点 t.insert(20); t.insert(15); t.insert(9); t.insert(35); System.out.print(t.getRoot().getValue()+\"、\");//第0层：根节点 System.out.print(t.getRoot().getLeftNode().getValue()+\"、\");//第一层左值 System.out.print(t.getRoot().getRightNode().getValue()+\"、\");//第一层右值 System.out.print(t.getRoot().getRightNode().getLeftNode().getValue()+\"、\");//第二层左值 System.out.print(t.getRoot().getRightNode().getRightNode().getValue());//第二层右值 //输出结果应为：10、9、20、15、35 }} 代码块3 输出结果应该为： 110、9、20、15、35 这只是简单的插入功能，下一节我会写如何查找二叉树的节点以及删除节点、还有如何遍历一棵二叉树","link":"/2014/07/04/java%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"java性能火焰图的生成","text":"一、前言开始之前，你需要准备的环境： Linux系统机器或者虚拟机一台，里面需要安装的软件：git、jdk、perl。 二、简单介绍java性能分析火焰图的所做的事情就是能够分析出java程序运行期间存在的性能问题，因为某段代码拖慢整个程序执行是不允许的，因此靠火焰图的绘制和分析就可以找出类似的“问题代码段”。 那么这个图是怎么来的呢？首先跟大多数监控系统一样，数据采集+前端绘图，这个图也是根据某些数据绘制而成的，绘图工具本篇文章采用FlameGraph，而负责收集这些数据的工具，本篇采用async-profiler，这个工具会在程序运行期间向jvm发送信号采集其运行期数据（简单来说就是通过该工具可以找出程序中占用CPU资源时间最长的代码块，这里async-profiler的实现使用了jvmti，戳这里简单了解一下），然后生成相应的数据格式文件，而FlameGraph则负责读取和解析数据文件生成对应的火焰图（svg文件）。 三、使用&amp;安装🔥3.1：环境搭建确认你的机器已经安装了git、jdk、perl、c++编译器，部分可参考：安装杂记 🔥3.2：clone相关项目下载下来所需要的两个项目（这里建议放到data目录下）： 12git clone https://github.com/jvm-profiling-tools/async-profilergit clone https://github.com/brendangregg/FlameGraph 🔥3.3：编译下载好以后，需要打开async-profiler文件，输入make指令进行编译： 12cd async-profilermake 🔥3.4：编写测试程序编译完成后，我们来写一个简单的java程序： 123456789101112131415161718192021222324public class Test { public static void main(String[] args) throws Exception { Test test = new Test(); while (true) { test.func1(); test.func2(); test.func3(); } } public void func1() throws Exception { //调用第一个方法，需要100ms Thread.sleep(100L); } public void func2() throws Exception { //调用第二个方法，需要500ms Thread.sleep(500L); } public void func3() throws Exception { //调用第三个方法，需要1500ms Thread.sleep(1500L); }} 代码块1 非常简单的一个java类，main方法里所做的事情也很简单，现在把这个文件搞到data目录下，javac命令编译，java命令启动。 然后找到这个java程序的进程id： 123ps -ef | grep javaroot 30937 17605 0 19:12 pts/0 00:00:00 java Testroot 30961 23135 0 19:12 pts/1 00:00:00 /bin/grep --color=auto java 可以确认此时Test类运行时的java进程pid = 30937，当然也可以使用jps命令直接查看java进程，效果是一样的。 🔥3.5：生成火焰图数据ok，上述步骤完成后，现在进入async-profiler那个项目的目录下，然后输入如下指令： 1./profiler.sh -d 60 -o collapsed -f /tmp/test_01.txt ${pid} 上面的-d表示的是持续时长，后面60代表持续采集时间60s，-o表示的是采集规范，这里用的是collapsed，-f后面的路径，表示的是数据采集后生成的数据存放的文件路径（这里放在了/tmp/test_01.txt），${pid}表示的是采集目标进程的pid，也就是上面提到的30937 回车运行，运行期间阻塞，知道约定时间完成。运行完成后，现在去tmp下看看有没有对应文件： 🔥3.6：生成svg文件上一步产生的文件里的内容，肉眼是很难看懂的，所以现在FlameGraph的作用就体现出来了，它可以读取该文件并生成直观的火焰图，现在进入该项目目录下面，执行如下语句： 1perl flamegraph.pl --colors=java /tmp/test_01.txt &gt; test_01.svg 因为是perl文件，这里使用perl指令运行该文件，后面--colors表示着色风格，这里是java，后面的是数据文件的路径，这里是刚刚上面生成的那个文件/tmp/test_01.txt，最后的test_01.svg就是最终生成的火焰图文件存放的路径和文件命名，这里是命名为test_01.svg并保存在当前路径，运行后看到该文件已经存在于当前目录下： 🔥3.7：展示现在下载下来该文件，使用浏览器打开，效果如下： 果然还是看不懂啊-_-|| 后续会更新这东西怎么看和分析，或者说我这篇文章里的java例子可能并不能很好的体现出什么。 续更续更，公司内部火焰图已经上线，通过更为复杂的业务场景生成的图反而看起来更容易理解一些，因为业务代码的调用也会打印出来，下面贴一下内部某业务系统火焰图： 这张图是在某个业务系统运行时，采样60s生成的火焰图，通过这样一张图可以看出，x轴为调用顺序，y轴为栈深，线条颜色无实际意义（并不是越红性能越差之类的），线条长度代表CPU执行该方法时所花费的时间占比，一般来说需要关注的就是栈顶，且宽度比较大的那个。因为一般处于栈顶的，而且宽度比较大的调用栈，说明其存在性能问题，这样分析的原因如下： 栈深度与y轴高度成正比，一般造成性能问题的都在调用栈的栈顶位置，因为栈顶位置的性能问题会间接拖慢整个调用栈，比如上图中每个栈底的线条都很长，这是因为越往上栈越深，对下层的影响就越大，可以简单抽象成方法调用：A调用B，B调用C，C慢会间接导致B慢，从而导致A慢，当然符合这种情况就适合之前说的看栈顶分析瓶颈的方法，如果A本身就慢呢？通过火焰图也是可以看出来的，比如栈底的线条宽度很宽，但是建立在该栈底的调用链上，线条都很窄，火焰图呈现┻型，那么就可以认定，栈底方法存在性能问题，一般情况下都是从栈顶看起，视情况而定~","link":"/2019/03/22/java%E6%80%A7%E8%83%BD%E7%81%AB%E7%84%B0%E5%9B%BE%E7%9A%84%E7%94%9F%E6%88%90/"},{"title":"【杂记】linux下各种软件安装方法（持续记录）","text":"1.安装jdk网上一堆说先从windows下压缩包，然后通过共享文件夹copy到linux系统里，然后解压安装，emmmmm 首先进入usr文件夹，新建java文件夹： 1mkdir java 直接通过wget命令下载压缩包（如果找不到wget工具，可以通过apt-get install wget安装此工具）： 1wget --no-cookies --no-check-certificate --header \"Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie\" \"http://download.oracle.com/otn-pub/java/jdk/8u141-b15/336fa29ff2bb4ef291e347e091f7f4a7/jdk-8u141-linux-x64.tar.gz\" 后面url需要按照自己需要调整。 进入所在文件夹（这里指java文件夹）解压： 1tar -zxvf jdk-8u141-linux-x64.tar.gz 解压好了如下： 12root@xxx-xxx-xxx-01:/usr/java # ls -a. .. jdk1.8.0_141 jdk-8u141-linux-x64.tar.gz 接着配置环境变量，输入指令： 1vim /etc/profile 然后编辑： 1234export JAVA_HOME=/usr/java/jdk1.8.0_141 export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport JRE_HOME=$JAVA_HOME/jre 然后让其生效： 1source /etc/profile 最后进行测试看看是否生效了： 1234root@xxx-xxx1-xxx-01:~# java -versionjava version \"1.8.0_141\"Java(TM) SE Runtime Environment (build 1.8.0_141-b15)Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode) 出现版本号，视为安装配置成功。 2.安装Perl1234567wget http://www.cpan.org/src/5.0/perl-5.26.1.tar.gztar zxvf perl-5.26.1.tar.gzcd perl-5.26.1./Configure -demakemake testmake install wget后面的路径可以按需更改。安装过程比较耗时间，安装完成后可通过perl -version查看是否安装成功。 3.tcpdump抓包工具12apt-get updateapt-get install tcpdump 抓包工具tcpdump可以抓到容器内的网络请求，具体用法如下： 1tcpdump -i any -A -n port 80 | grep -C 50 'path' 上面是抓取端口为80的网络交互，且过滤出包含path关键词的交互，展示50行。 比如你想抓取http请求，知道http请求端口是80，还知道http请求具体的path，那么就可以抓取一个接口的请求信息（包含请求报文、响应报文），redis等同理，知道端口，知道关键词，就可以抓到交互。 4.C++编译器1apt-get install g++ 一般用于编译c++程序，缺少这个编译器进行make编译c++代码时，会报g++: not found的错误。 5.zookeeper的安装&amp;启动先下载zookeeper的安装包，然后解压： 1tar -zxvf zookeeper-3.4.6.tar.gz 解压后进入该包路径，然后进入conf目录修改zoo_sample.cfg的名字为zoo.cfg： 1mv zoo_sample.cfg zoo.cfg 然后打开该文件： 12345678910111213141516171819202122232425262728# The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial # synchronization phase can takeinitLimit=10# The number of ticks that can pass between # sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just # example sakes.dataDir=/tmp/zookeeper# the port at which the clients will connectclientPort=2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns=60## Be sure to read the maintenance section of the # administrator guide before turning on autopurge.## http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount=3# Purge task interval in hours# Set to \"0\" to disable auto purge feature#autopurge.purgeInterval=1 重要解释： tickTime：这个时间是作为 Zookeeper服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime时间就会发送一个心跳。dataDir：顾名思义就是Zookeeper保存数据的目录，默认情况下，Zookeeper的日志文件是在bin目录下，有一个zookeeper.out文件。clientPort：这个端口就是客户端连接 Zookeeper服务器的端口，Zookeeper会监听这个端口，接受客户端的访问请求。伪集群模式下，这个端口需要配置成不同的。如果是多台虚拟机或者服务器下，则无需更改。 接下来，我们来标记下该zk节点的id（节点号），在dataDir显示的路径下新建myid文件，写上一个数字（1~255间），这里写的是1： 123vim myid1:wq 然后继续回到conf目录下，编辑zoo.cfg，在下面添加如下配置： 1server.1=xx.xx.xxx.xx:8881:7771 前面的server.1里的1就是之前在myid里写的id号，zk节点唯一标识，后面的xx.xx.xxx.xx标识本机ip； 再往后的8881表示的是这个服务器与集群中的 Leader 服务器交换信息的端口（自定义）； 再后面的7771表示的是万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。 接下来返回到zk的bin目录，进行启动这个zk服务： 1./zkServer.sh start 看到下面的打印说明启动成功： 123JMX enabled by defaultUsing config: /usr/zk/zookeeper-3.4.6/bin/../conf/zoo.cfgStarting zookeeper ... STARTED 集群搭建比较简单，直接改下配置，把zoo.cfg下面的ip+port往下面加节点就行了，例子： 123server.x=yyy.yy.yyy.yy:8881:7771server.x=yyy.yy.yyy.yy:8881:7771server.x=yyy.yy.yyy.yy:8881:7771 注意，集群里的每一个节点都要加上上面的配置，上面配置里的x就是指之前单机的myid文件放的id号，需要注意的是集群模式下，这些id是不允许有重复的，后面的yy.yy指的是节点ip地址，再往后的8881和7771之前有解释过，上翻查看。 这样配置后，将所有节点重启一遍即可，期间会进行Leader的选举，完成后可以运行bin目录下的zkServer.sh status查看其身份。","link":"/2019/03/22/%E3%80%90%E6%9D%82%E8%AE%B0%E3%80%91linux%E4%B8%8B%E5%90%84%E7%A7%8D%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95%EF%BC%88%E6%8C%81%E7%BB%AD%E8%AE%B0%E5%BD%95%EF%BC%89/"},{"title":"利用ReentrantLock简单实现一个阻塞队列","text":"借助juc里的ReentrantLock实现一个阻塞队列结构： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package demo.concurrent.lock.queue;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;/** * @author sunqinwen * @version \\: SimpleQueue.java,v 0.1 2019-01-16 14:47 * 利用重入锁和重入锁的线程调度实现的简单阻塞队列 */public class SimpleQueue { private static ReentrantLock lock = new ReentrantLock(); private T[] nodes; private int tail = 0; // 入元素下标 private int count = 0; // 元素个数 private int head = 0; // 出元素下标 public SimpleQueue(int size) { nodes = (T[]) new Object[size]; } private static Condition notFull = lock.newCondition(); private static Condition notEmpty = lock.newCondition(); public void put(T t) { try { lock.lock(); if (count == nodes.length) { // 队列已满，阻塞 System.out.println(\"目前队列已满，等待取值中\"); notFull.await(); } if (tail &gt; (nodes.length - 1)) { // 当前游标值已经大于数组游标最大值了，则从0开始计算 tail = 0; } nodes[tail] = t; // 给当前游标位赋值 count++; // 入元素元素个数+1 tail++; // 游标值+1 notEmpty.signalAll(); // 走到这里说明队列内至少有一个元素，则唤醒取值 } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } } public T take() { T t = null; try { lock.lock(); if (count == 0) { // 队列已空，等待加值 System.out.println(\"目前队列已空，等待入值中\"); notEmpty.await(); } if (head &gt; (nodes.length - 1)) { // 若取值游标大于游标最大值，则从0开始计算 head = 0; } t = nodes[head]; // 拿到元素值 nodes[head] = null; // 清空原有位置上的值 head++; // 取值游标+1 count--; // 元素个数-1 notFull.signalAll(); // 走到这里说明队列至少有一个空位，则唤醒入值 } catch (Exception e) { e.printStackTrace(); } finally { lock.unlock(); } return t; }} 代码块1 以上为主要代码，下面进行简单的测试： 12345678910111213141516171819202122232425262728293031@Testpublic void simpleQueueTest() throws Exception { executorService.execute(() -&gt; { simpleQueue.put(1); simpleQueue.put(2); simpleQueue.put(3); simpleQueue.put(4); simpleQueue.put(5); simpleQueue.put(6); simpleQueue.put(7); simpleQueue.put(8); simpleQueue.put(9); simpleQueue.put(10); simpleQueue.put(11); simpleQueue.put(12); }); Thread.sleep(5000L); executorService.execute(() -&gt; { Integer r; while ((r = simpleQueue.take()) != null) { System.out.println(r); } }); Thread.sleep(5000L);} 代码块2 运行结果： 123456789101112131415161718目前队列已满，等待取值中目前队列已满，等待取值中12目前队列已满，等待取值中3目前队列已满，等待取值中456789目前队列已空，等待入值中101112目前队列已空，等待入值中","link":"/2019/02/12/%E5%88%A9%E7%94%A8ReentrantLock%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"},{"title":"利用java实现一个简单的链表结构","text":"定义所谓链表就是指在某节点存储数据的过程中还要有一个属性用来指向下一个链表节点，这样的数据存储方式叫做链表 链表的优缺点优点：易于存储和删除 缺点：查询起来较麻烦 java实现下面我们用java来实现如下链表结构： 首先定义节点类： 123456789101112131415161718192021222324252627282930package LinkTest;/** * 链表节点类 * @author admin * */public class Node { private int value;//存储数据 private Node next;//下一个节点 /** * 定义构造器 * @param vlaue * @param value */ public Node(int value){ this.value=value; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } public Node getNext() { return next; } public void setNext(Node next) { this.next = next; }} 代码块1 然后定义一个链表类： 注意：遍历链表定义了两个方法，一个是普通方法，一个是递归方法，都可以遍历出来 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package LinkTest;/** * 链表 * @author admin * */public class Link { private Node current; private Node root; public void insert(int vlaue){ Node newNode=new Node(vlaue); if(this.current==null){ this.current=newNode; this.root=this.current; }else{ this.current.setNext(newNode); this.current=this.current.getNext(); } } //普通遍历 public void getList(){ this.current=this.root; while(this.current!=null){ System.out.print(this.current.getValue()); this.current=this.current.getNext(); if(this.current!=null){ System.out.print(\"-------&gt;\"); } } } //递归遍历 public void getList2(){ DG(this.root); } //递归方法 public void DG(Node node){ System.out.print(node.getValue()+\"-----&gt;\"); if(node.getNext()!=null){ DG(node.getNext()); }else{ return; } }} 代码块2 测试类： 123456789101112131415161718package LinkTest;/** * 测试类 * @author admin * */public class Test { public static void main(String[] args){ Link l=new Link(); l.insert(1); l.insert(4); l.insert(5); l.insert(6); l.insert(9); l.insert(8); l.getList(); }} 代码块3 测试类运行结果： 11-------&gt;4-------&gt;5-------&gt;6-------&gt;9-------&gt;8 这样我们就用java实现了一个简单的链表结构。","link":"/2014/07/04/%E5%88%A9%E7%94%A8java%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84/"},{"title":"图解java多线程设计模式（一）","text":"去年看完的《图解java多线程设计模式》，可惜当时没做笔记，导致后来忘了许多东西，打算再温习下这本书，顺便在这里记录一下~ 一、顺序执行、并行、并发 顺序执行：多个操作按照顺序依次执行。 并行：多个任务同时进行，同一时间内可以执行多个任务，这种方式，叫做并行执行，比如多核处理器，多个核可以同时处理多个任务。 并发：多个任务通过切分时间段，来达到“同时进行”的效果，比如单核处理器，在“同时”处理多个任务时，就会不停的切换来执行不同的任务，不可能有同一时间执行不同任务的情况。 下面引用别人的一句话来说明下并行和并发： 并发是两个任务可以在重叠的时间段内启动，运行和完成。并行是任务在同一时间运行，例如，在多核处理器上，并发是独立执行过程的组合，而并行是同时执行（可能相关的）计算。 并发是一次处理很多事情，并行是同时做很多事情。 应用程序可以是并发的，但不是并行的，这意味着它可以同时处理多个任务，但是没有两个任务在同一时刻执行。应用程序可以是并行的，但不是并发的，这意味着它同时处理多核CPU中的任务的多个子任务。一个应用程序可以即不是并行的，也不是并发的，这意味着它一次一个地处理所有任务。应用程序可以即是并行的也是并发的，这意味着它同时在多核CPU中同时处理多个任务。 二、synchronized修饰符当我们说一个线程获得锁以后，则意味着这个线程可以执行当前对象（或类）里的synchronized方法，而且他线程则需要排队等待该线程释放锁以后才可能获得锁，进而执行锁里面的程序。 synchronized修饰后，存在对象锁和类锁两种类型。 2.1：对象锁123synchronized (this){ ...略} 代码块1 2.2：类锁123synchronized (XXX.class){ ...略} 代码块2 2.3：区别和作用域对象锁指的是当前线程获得了某个实例的锁，假如有个Word类，有A、B两个同步方法，C属于普通方法，如图所示： 可以发现，对象锁的作用域只针对当前对象生效，就像w1和w2里的A方法可以被不同的线程同时执行，但是同一个对象内的同步块，却只允许持有当前对象锁的线程执行，如t2、t3均被挡在了外面，当t1释放锁以后，t2、t3才会重新竞争锁，竞争到锁以后就会执行自己想要执行的同步逻辑。 类锁指的是当前线程获得了某个类的锁，还是Word类，有A、B两个static方法（静态方法属于类方法，加synchronized修饰符后等效于上面提到的synchronized(Word.class))，C属于普通static方法，如图所示： 跟上面相比较，这里的t5受到了t1的影响，因为t1获得了Word类的锁，w1和w2共属一个类，因此t1获得类锁以后，其他线程想要访问这个类里的同步块，就得等到t1释放锁以后才可以继续竞争锁然后执行自己想要执行的同步逻辑。 三、线程间的通信3.1：Wait这几个方法是属于每个实例对象的，所有实例都拥有一个“等待队列”（虚拟概念，实例里并不存在该字段），它是在实例的wait方法调用后存放停止操作线程的队列。执行wait方法后，线程进入当前实例的“等待队列”，以下几种情况可以让线程退出“等待队列”： 其他线程调用notify、notifyAll方法来将其唤醒 其他线程调用interrupt来将其唤醒 wait方法本身超时 当执行了下面的代码： 1obj.wait(); 代码块3 我们可以说当前线程在obj上发生了等待，当前线程进入了obj的“等待队列”，此时当前线程会让出锁，让其他线程继续竞争获得该实例的锁（因此这里有个规则，调用wait的线程必须持有当前实例对象的锁） 过程如下图： 3.2：notify现在先来介绍下notify，该方法会将等待队列里的线程取出，让其退出等待并参与锁竞争然后继续执行上次wait后没有执行完的语句。整体过程如下图所示： 可以看到，t1在被挂起后，会因为t2调用了同实例的notify方法，而让t1被从等待队列里释放，重新加入到所得竞争力，t2执行完毕后释放锁，锁又再次被t1竞争到，t1将继续执行上次被挂起时后面未执行完的语句。 需要指出的是，如果等待队列里的线程是多个，那么被唤醒的那一个，将会是等待队列里所有线程随机的一个，不会特定哪一个线程会被唤起。 3.3：notifyAll接下来介绍notifyAll方法，顾名思义，就是将等待队列里的线程全部唤起，然后这些线程将全部加入到锁竞争，竞争到，继续完成上次被挂起时未执行完毕的操作，流程图如下： 说明，当线程调用实例的wait、notify、notifyAll方法有个大前提，就是必须要求该线程拥有该实例的锁，否则会抛IllegalMonitorStateException异常。 在编写程序时，是该选择notify还是选择notifyAll？这个可以指出的是，notifyAll往往更加健壮，而notify由于唤起的线程少，因此效率会更高，但是存在程序停止的风险。 附上使用wait、notify进行线程通信的例子： 利用ReentrantLock简单实现一个阻塞队列 java设计模式：简单实现生产者和消费者模式","link":"/2019/02/26/%E5%9B%BE%E8%A7%A3java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"数据库事务的隔离级别","text":"一、数据库事务的几个特性1.1：原子性最基本的特性，意思是在一个事务内里所有关于数据库的操作，要么全部成功，要么全部失败；成功时意味着本次操作所有数据库相关的写操作全部持久化，无法更改，失败意味着本次操作相对于操作前对数据库没有任何影响和改变。 1.2：一致性指的是一次完整的事务必须将数据库的一个一致状态转变到另外一个一致状态。 一致性写 例如：事务A要做的操作是将A、B、C三个记录修改为D、E、F，那么A、B、C—–&gt;D、E、F的过程就满足了事务一致性，但是如果出现类似：A、B、C—-&gt;D、E、C（A、B修改成功，但是C未修改）则认定违背了事务的一致性，简单理解一致性就是指事务的“初始状态”到“修改完成状态”与“目标状态一致”。 一致性读 事务A在某一刻发起查询请求，那么查询结果是以那一刻为准，保证了数据在查询一刻的一致性。 1.3：持久性指一次事务的成功提交对数据库造成的修改是永久性的。 1.4：隔离性当多个用户并发访问数据库时，数据库为每一个用户开启的事务不可以被其他事务所影响，也就是说并发事务间要相互独立不受到干扰。关于隔离性分了集中隔离等级，本篇文章将详细介绍这几种隔离等级。 二、事务并发时的隔离级别2.1：Read Uncommitted（读未提交）这个隔离级别下未被提交的事务下所做的任何操作都可以被其他事务所读取到，这时候会造成数据的脏读、幻读、不可重复读问题。 2.2：Read Committed（读已提交）这个隔离级别下未被提交的操作不可以被其他事务所读取到，简单来讲就是单个事务里的内容在事务成功提交之前，是不会被其他事务所读取（发现）到的，但是这样同样会出现幻读、不可重复读现象。 举个栗子：事务T1要对C表做添加操作，同时事务T2里要读取C表，T2第一次读取C表时返回1条数据，这时T1执行完毕，那么T2如果再次取一次C表数据就会发现多出一条数据。 2.3：Repeatable Read（可重读）Mysql默认的隔离级别，这个隔离级别下同一事务读取到的数据一致（简单点说就是T1一旦开始，读取到数据如果中间被T2修改，那么T1再次读取该数据是和第一次读取时一样的），因此，在该隔离级别下，不会造成脏读、不可重复读，但依旧会造成幻读现象。 2.4：Serializable（串行）最高隔离级别，会为每个事务排序（为每条数据都加上锁），使之执行串行化，不可能产生冲突，因此解决了脏读、幻读、不可重复读问题，但是会造成锁竞争甚至超时，一般不会采用这种极端的隔离机制。 三、事务并发过程中产生的问题3.1：脏读一个事务读取到了另外一个事务中未提交的数据。 3.2：不可重复读一个事务读取到了另外一个事务中提交的修改掉的数据。 3.3：幻读一个事务读取到了另外一个事务中添加的数据。 Tip：不可重复读和幻读的区别在于着重点一个是update，一个是insert 四、各种隔离级别下对应的问题通过设置不同的事务隔离级别，可以避免事务并发时所造成的部分问题。 总结四种隔离级别所造成和避免的问题（请先看以上内容后再看此表）： 隔离级别 脏读 不可重复读 幻读 Read Uncommitted 是 是 是 Read Committed 否 是 是 Repeatable Read 否 否 是 Serializable 否 否 否 表1","link":"/2017/04/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"},{"title":"深入理解map系列-HashMap（一）","text":"Map系列之HashMap（源码基于java8） HashMap是我们最常用的map实现之一，这篇文章将会介绍HashMap内部是如何工作的，以及内部的数据结构是怎样的 一、数据结构简图 二、源码解析首先看下Map接口里常用的几个方法： 1234V put(K key, V value);V get(Object key);V remove(Object key);boolean containsKey(Object key); 代码块1 上面是常用的主要操作方法，下面来看下map的基本存储单位Entry： 12345678910111213interface Entry&lt;K,V&gt; { K getKey(); //返回当前存储数据里的key V getValue(); //返回当前存储数据里的value V setValue(V value); //给value赋值 boolean equals(Object o); //重写equals方法 int hashCode(); //重写hashCode方法 } 代码块2 然后我们来看下HashMap里对该接口的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243// 基本存储结构，可以看出来这是一个简单的链表结构，这里的实现类叫Nodestatic class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; //根据key计算出来的哈希值 final K key; //数据键 V value; //数据值 Node&lt;K,V&gt; next; //下一个数据节点 Node(int hash, K key, V value, Node&lt;K,V&gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + \"=\" + value; } public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value); } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } // 判等，要求k，v必须满足相等才行 public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) { Map.Entry e = (Map.Entry)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; } return false; } } 代码块3 我们再来看看hash值的计算，在哈希表中，哈希值取决了散列度，最终插入的数据会分布到哪个数组下标下，hash值起着至关重要的作用： 1234static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); } 代码块4 下面我们来看看具体插入数据时做的操作，具体解释已经加上注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { HashMap.Node&lt;K,V&gt;[] tab; //存储链表的数组结构 HashMap.Node&lt;K,V&gt; p; //被插入的元素链表头部元素 int n, i; //n表示当前哈希表数组长度，i表示本次插入元素被分配的下标 if ((tab = table) == null || (n = tab.length) == 0) { //表示哈希表数组还未被初始化 n = (tab = resize()).length; //初始化，resize用来扩容 } //表示当前（下标由最大下标值和当前元素哈希值位运算得出）位置还没有任何链表结构，这时直接初始化即可 if ((p = tab[i = (n - 1) &amp; hash]) == null) { tab[i] = newNode(hash, key, value, null); } else { // 否则，需要进行链表数据插入的操作，注意现在p已经是计算出来的链表头元素了 HashMap.Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) { e = p; // 若发现插入的数据跟p哈希值、key完全一致，则直接让新插入的数据等于p即可 } else if (p instanceof HashMap.TreeNode){ // 结合下面的代码，链表深度大于8后，就是个红黑树结构了，这时启用下面的代码加入新数据 e = ((HashMap.TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); } else { // 说明插入的是新元素 for (int binCount = 0; ; ++binCount) { // 遍历链表 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); //插入链表尾部 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // java8新引入的概念，当链表深度大于8时，就转换为红黑树结构了 treeifyBin(tab, hash); break; } if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { break; // 若发现遍历过程中存在与插入值一致的，直接break } p = e; } } if (e != null) { // 说明未成功插入 V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; // 返回已存在的旧值 } } ++modCount; if (++size &gt; threshold) { //新插入值后，满足扩容条件则进行扩容 resize(); //扩容 } afterNodeInsertion(evict); return null; } 代码块5 由于java8做了根据元素数量，转换成红黑树结构的优化处理，所以上述代码中会掺杂一些相关的代码，这里先不用关心，我们按照最基本的哈希表结构来看就行，下一讲将会分析红黑树结构。 我们接下来来看下get方法： 1234public V get(Object key) { Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;} 代码块6 然后getNode方法： 1234567891011121314151617181920212223242526final HashMap.Node&lt;K,V&gt; getNode(int hash, Object key) { HashMap.Node&lt;K,V&gt;[] tab; //哈希表数组 HashMap.Node&lt;K,V&gt; first, e; //根据hash查找数组内的第一个元素 int n; K k; // n表示数组长度 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { // 根据下标（下标由最大下标值和当前元素哈希值位运算得出）获取当前对应第一个元素（链表或者红黑树的根元素） if (first.hash == hash &amp;&amp; // 检查第一个节点的key是否等于当前查找的key，若等，直接返回 ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))){ return first; } // 否则继续遍历查找 if ((e = first.next) != null) { if (first instanceof HashMap.TreeNode) { //红黑树结构的查询 return ((HashMap.TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); } // 普通链表结构遍历查询，查到直接返回 do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))){ return e; } } while ((e = e.next) != null); } } return null; } 代码块7 ok,上面说完了put和get，现在我们来看下remove，也是先抛开红黑树不谈，只看链表部分，会很容易： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public V remove(Object key) { HashMap.Node&lt;K, V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; }final HashMap.Node&lt;K, V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) { HashMap.Node&lt;K, V&gt;[] tab; //哈希表数组 HashMap.Node&lt;K, V&gt; p; //需要被移除的元素所属的根元素 int n, index; //n表示数组长度，index表示需要被移除元素根元素位于数组的下标值 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) { HashMap.Node&lt;K, V&gt; node = null, e; // node表示最终需要被移除的元素 K k; V v; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) { node = p; // 若根元素就等于需要被移除的元素，则直接将node赋值为p } else if ((e = p.next) != null) { // 否则继续往下查找，结构依然分为两种，红黑树暂不看 if (p instanceof HashMap.TreeNode) { node = ((HashMap.TreeNode&lt;K, V&gt;) p).getTreeNode(hash, key); } else { do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { node = e; break; // 找到对应的元素，break } p = e; // 找不到对应元素时，让p一直下移（e.next） } while ((e = e.next) != null); } } if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) { if (node instanceof HashMap.TreeNode) { //红黑树移除 ((HashMap.TreeNode&lt;K, V&gt;) node).removeTreeNode(this, tab, movable); } else if (node == p) { // 待移除元素等于根元素时，直接让对应下标下的数组元素赋值为根元素的下一个值 tab[index] = node.next; } else { //否则，就进行链表正常删除逻辑，让被移除元素的前一个元素（为什么现在的p是前一个元素呢？因为在上述do while操作时已经重新赋值了）的下一个值指向被移除元素的下一个值 p.next = node.next; } ++modCount; --size; afterNodeRemoval(node); return node; } } return null; } 代码块8 好了，目前基本上把重要的一些操作给介绍完了，现在再看下containsKay这个方法，这个方法极度简单，直接调用getNode方法判空即可： 123public boolean containsKey(Object key) { return getNode(hash(key), key) != null;} 代码块9 本篇的侧重点在于HashMap在使用纯链表时的插入、移除、查找方式，下一篇将会介绍HashMap如何扩容数组、以及在启用红黑树结构下，会如何做插入、移除、查找这几种操作方式。","link":"/2019/02/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3map%E7%B3%BB%E5%88%97-HashMap%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"简单实现生产者和消费者模式","text":"本实例中单独为生产者和消费者各开辟一个线程作为生产者和消费者的执行线程，在生产者消费者设计模式中存在一个数据缓冲区，使生产者和消费者的“生产”和“消费”动作都在该缓冲区进行，这样做的目的就是保证了生产者和消费者的完美解耦，试想一下如果没了这个缓冲区，生产者和消费者中的方法互调，那么两个类的关联度（耦合度）就会很高，一旦一个发生变化，势必会影响另外一个； 下面开始我们的实例： 首先是生产者的代码： 12345678910111213141516171819202122/** * 生产者 */public class Product implements Runnable{ private Queue queue; public Product(Queue queue){ this.queue = queue; } @Override public void run() { try{ for(int i = 0; i &lt; 10; i++){ queue.product(\"Product------\" + \"No.\" + i);//开始生产 } }catch (Exception e){ e.printStackTrace(); } }} 代码块1 这是消费者： 12345678910111213141516171819202122/** * 消费者 */public class Consumer implements Runnable{ private Queue queue; public Consumer(Queue queue){ this.queue = queue; } @Override public void run() { try{ for(int i = 0; i &lt; 10; i++){ System.out.println(\"already gone : \" + queue.consumer());//开始消费 } }catch (Exception e){ e.printStackTrace(); } }} 代码块2 这是缓冲区，几乎所有的逻辑都是在这里实现的： 123456789101112131415161718192021222324252627282930313233343536373839/** * 队列缓冲区 */public class Queue { private Object signal = new Object();//当前线程的挂起和执行标记 private boolean isFull = false;//队列是否已满 private List list = new ArrayList&lt;&gt;();//队列 public void product(String msg) throws Exception{ synchronized (signal){ if(!isFull){//如果没有满，执行如下代码 list.add(msg);//加进队列 isFull = true; System.out.println(\"Product One !\"); signal.notify();//唤醒当前消费者里面被挂起的线程 } signal.wait();//否则，如果当前满了，说明消费者正在消费，挂起当前生产线程 } } public String consumer() throws Exception{ synchronized (signal){ if(!isFull){ //不满，说明生产者正在生产，应当挂起consumer线程 System.out.println(\"Empty Product !\"); signal.wait(); } isFull = false;//已消费，队列被标记为不满状态 signal.notify();//通知生产者 } //消费（读取） String result = \"\"; if(list.size() &gt; 0){ result = this.list.get(list.size() - 1); this.list.remove(list.size() - 1); } return result; }} 代码块3 上面这个模式利用java现有的阻塞队列很容易实现，可以避免上述代码中很大一部分代码（线程的挂起、唤醒、队列弹出数据等）","link":"/2016/04/15/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"title":"简单工厂模式&策略模式-简介与区别","text":"前言：两种模式的相似点与不同点不得不说，这两种模式真的很像。 相似点：都用到了面向对象的继承、多态、抽象，都拥有相似的结构。 不同点：工厂模式仅提供具体的实例对象，怎么使用这个对象是client的自由，策略模式client可以通过策略类来决定使用哪个实例的哪个方法。 一、两种模式的公共相同部分下面，我们假设有一台红白机，里面有一些游戏，每个游戏拥有play（玩）和uninstall（卸载）两个方法。 按照工厂和策略模式，我们抽象出来一个Game接口： 1234567public interface Game { void play(); void uninstall();} 代码块1 然后，我们假设游戏机里有魂斗罗、马戏团、默认的俄罗斯方块三款游戏，每个游戏有不同的玩法和卸载算法： 123456789101112131415161718192021222324252627282930313233343536373839404142// 魂斗罗，实现Gamepublic class Hundouluo implements Game { @Override public void play() { System.out.println(\"游戏：魂斗罗...playing\"); } @Override public void uninstall() { System.out.println(\"游戏：魂斗罗...卸载\"); }}// 马戏团，实现Gamepublic class Maxituan implements Game { @Override public void play() { System.out.println(\"游戏：马戏团...playing\"); } @Override public void uninstall() { System.out.println(\"游戏：马戏团...卸载\"); }}// 默认的俄罗斯方块，实现Gamepublic class Default implements Game { @Override public void play() { System.out.println(\"游戏：俄罗斯方块...playing\"); } @Override public void uninstall() { System.out.println(\"游戏：俄罗斯方块...卸载\"); }} 代码块2 ok，工厂模式和策略模式的相同部分就已经写好了，通过上面的代码，我们可以发现这两种模式都是需要把相同的部分抽象出来，通过多态来实例化不同的对象，调用其对应的实现。 二、两种模式的不同部分的实现2.1：工厂模式工厂需要一个工厂类，用来返回具体的实例对象用，代码如下： 1234567891011121314public class GameFactory { public static Game getGame(String name) { switch (name) { //根据传来的游戏名（这里偷懒用了首字母），来实例化具体的对象 case \"hdl\": return new Hundouluo(); case \"mxt\": return new Maxituan(); default: return new Default(); } }} 代码块3 2.2：策略模式策略模式需要策略类来封装具体的行为（方法），并且还可以指定使用哪个实例的哪个行为，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839// 为了和工厂做充分的区分，这里定义了两个类型的context，分别维护一个行为算法（也就是方法函数，其次建立两个context是为了说明问题，实际使用时可能不需要这么多）// 用来维护play这个算法的实现public class PlayContext { private Game game; public PlayContext() { this.game = new Default(); } public PlayContext(Game game) { this.game = game; // 这里根据传入的具体实例赋值 } public void trigger() { this.game.play(); // 这里是对行为的封装，只提供play方法的触发 }}// 用来维护uninstall这个算法的实现public class UninstallContext { private Game game; public UninstallContext() { this.game = new Default(); } public UninstallContext(Game game) { this.game = game; // 这里根据传入的具体实例赋值 } public void trigger() { this.game.uninstall(); // 这里是对行为的封装，只提供uninstall方法的触发 }} 代码块4 测试代码： 1234new PlayContext(new Hundouluo()).trigger();new UninstallContext(new Hundouluo()).trigger();new PlayContext(new Maxituan()).trigger();new UninstallContext(new Maxituan()).trigger(); 代码块5 运行结果： 1234游戏：魂斗罗...playing游戏：魂斗罗...卸载游戏：马戏团...playing游戏：马戏团...卸载 通过上面的实验，和对比，会发现，工厂模式是简单的对实例的封装，而策略模式更在意的是对具体实例的具体行为（方法）的封装。 还有一种情况就是利用工厂模式的思想，实现的策略模式，我们现在来改造下上面的PlayContext源码： 1234567891011121314151617181920212223242526public class PlayContext { private Game game; public PlayContext() { this.game = new Default(); } public PlayContext(String name) { switch (name) { //根据传来的游戏名（这里偷懒用了首字母），来实例化具体的对象 case \"hdl\": this.game = new Hundouluo(); break; case \"mxt\": this.game = new Maxituan(); break; default: this.game = new Default(); } } public void trigger() { this.game.play(); // 这里是对行为的封装，只提供play方法的触发 }} 代码块6 测试类： 1234new PlayContext(\"hdl\").trigger();new UninstallContext(new Hundouluo()).trigger();new PlayContext(\"mxt\").trigger();new UninstallContext(new Maxituan()).trigger(); 代码块7 测试结果： 1234游戏：魂斗罗...playing游戏：魂斗罗...卸载游戏：马戏团...playing游戏：马戏团...卸载 三、总结策略模式是一种定义一系列算法的方法，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有算法，减少了各种算法类与使用算法类之间的耦合。 工厂模式仅提供对应的实例，不对其方法做封装，减少了具体实现的实例与使用实例的业务方的耦合。 （↑描述待改进）","link":"/2019/02/27/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F&%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%8C%BA%E5%88%AB/"},{"title":"简单模拟spring的ioc和aop","text":"spring最核心的部分莫过于ioc和aop了，下面来简单模拟下这两种思想 ps：如果有哪里理解的不对或者代码上有瑕疵的地方欢迎大家指正，大家互相学习，还有就是这只是模仿一下spring思想，只是把事务管理和bean管理简单模仿一下，完全不代表spring，如果想深入理解请看spring源码 下面就开始进行简单的模拟。 这个项目不是web项目，只是一个简单的java项目，测试用junit，废话不多说了，下面上代码： 项目的目录结构： 说明：图中划红线的部分都是核心部分 红线部分说明： BeanFactory：所有bean的核心生成器（spring容器） ConnBean：jdbc连接生成器（没用连接池哦~） Transaction：事务管理的代理类 beans.properties：配置文件 其余的没划线的就是domain、dao、service、controller这些web基本层次结构，待会会说 主要几个类的代码： ① BeanFactory： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package sun.juwin.factory;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.HashMap;/** * 本类用来读取配置文件中的信息对每个接口对象生成具体的实现 * 主要是将接口作为key，实例作为value存储进去，这是个单例， * spring默认为每个层次生成实现也是单例，但可以通过@Scope * 来指定，我们简单模仿一下，只是单例 */public class BeanFactory { private static HashMap&lt;String, Object&gt; mapResult; public static HashMap&lt;String, Object&gt; getBean() { if (mapResult == null) { synchronized (BeanFactory.class) {//双重检查的单例，防止多线程访问时多次new对象 if (mapResult == null) { BufferedReader bf = null; String line = null; try { /** *下面这句代码通过流来读取资源包下面的配置文件，为了省去不必要的麻烦， * 我们没有用xml，而是用了properties */ InputStreamReader inputStreamReader = new InputStreamReader(BeanFactory.class.getClassLoader().getResourceAsStream(\"beans.properties\")); bf = new BufferedReader(inputStreamReader); mapResult = new HashMap&lt;&gt;(); while ((line = bf.readLine()) != null) {//每次仅读一行 if (\"\".equals(line)){//有可能读到换行时隔了一行（即只有一个换行符） continue; } String[] point = line.trim().split(\"=\");//按照等号拼接 if (point.length &gt; 2) { throw new Exception(\"beans文件格式不对！\"); } Object obj = Class.forName(point[1].trim()).newInstance();//反射实例化出目标对象 mapResult.put(point[0].trim(), obj);//然后以键值对的形式存入 } } catch (Exception e) { e.printStackTrace(); } } } } return mapResult; }} 代码块1 上面的类可以通过配置文件来实例化不同的对象，符合ioc最基本的思想，下面让我们来看看配置文件beans.properties的内容吧： 12userDao = sun.juwin.dao.impl.UserDaoImpluserDetailDao = sun.juwin.dao.impl.UserDetailDaoImpl 这里面只有两句话，指定dao层接口对象的实现类的路径，其实已经很接近spring的xml里对bean的配置了，只不过这里是properties文件，简化了许多 ② TransactionProxy代理类： 123456789101112131415161718192021222324252627282930313233343536package sun.juwin.proxy.transctional;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.sql.Connection;/** * 事务代理类，通过这个类可以为要执行的方法加上事务管理 */public class TransactionProxy implements InvocationHandler { private Object targetObj; public Object getTargetObj(Object targetObj){ this.targetObj = targetObj; return Proxy.newProxyInstance(this.targetObj.getClass().getClassLoader(), this.targetObj.getClass().getInterfaces(), this); } /*下面这个方法会在被代理类执行方法时调用，拿到被代理类的要执行的method对象*/ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object result = null; Connection connection = (Connection)args[0];//要求第一个参数必须是conn try{ connection.setAutoCommit(false);//开启事务 result = method.invoke(this.targetObj, args);//执行目标方法 connection.commit();//事务提交 System.out.print(\"commit success!\"); }catch (Exception e){ connection.rollback();//事务回滚 System.err.println(\"rollback!\"); e.printStackTrace(); }finally { connection.close();//关闭连接 System.out.println(\"connection closed!\"); } return result; }} 代码块2 说明：java在1.3版本的时候就为我们提供了一个用作代理类实现的接口InvacationHandler，通过实现这个接口可以很随意的写一个耦合度特别低的动态代理类（即这一个代理类可以代理任何类） ③ ConnBean，用来生成一个数据库连接对象，在不用连接池的情况下，我们用ThreadLocal进行封装，代码如下： 123456789101112131415161718192021222324package sun.juwin.db;import java.sql.Connection;import java.sql.DriverManager;/*原始产生数据库连接的类*/public class ConnBean { private static ThreadLocal conn = new ThreadLocal&lt;&gt;(); private ConnBean(){} public static Connection getConn(){ Connection connection = conn.get(); if(connection == null){ synchronized (ConnBean.class){//由于用到了ThreadLocal，因此该单例仅仅相对于当前线程是单例的 if(connection == null){ try{ Connection realConn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db_useradd\", \"root\", \"\"); conn.set(realConn); }catch (Exception e){ e.printStackTrace(); } } } } return conn.get();//返回给当前线程一个Connection对象 }} 代码块3 以上就是核心的一些实现代码，下面让我们来看一下我们的业务吧： 实体类：User，UserDetail，要求添加一个User的同时要添加一个UserDetail User： 1234private Long id;private String userName;private String address;private int money; 代码块4 UserDetail： 123private Long id;private int age;private String realname; 代码块5 dao层的接口和实现： UserDao： 123public interface UserDao { public void save(User user, Connection conn)throws Exception;} 代码块6 UserDaoImpl： 123456789101112public class UserDaoImpl implements UserDao{ @Override public void save(User user, Connection conn) throws Exception { Statement statement = conn.createStatement();//为了省去不必要的麻烦，我们不用预编译语句 String sql = \"insert into tb_user (userName, address, money) values ('\" + user.getUserName() + \"', '\" + user.getAddress() + \"', \" + user.getMoney() + \")\"; statement.executeUpdate(sql); statement.close(); }} 代码块7 UserDetailDao： 123public interface UserDetailDao { public void save(UserDetail userDetail, Connection connection) throws Exception;} 代码块8 UserDetailDaoImpl： 12345678910public class UserDetailDaoImpl implements UserDetailDao { @Override public void save(UserDetail userDetail, Connection connection) throws Exception { Statement statement = connection.createStatement(); String sql = \"insert into user_detail (age, realname) values (\" +userDetail.getAge()+\", '\" +userDetail.getRealname()+\"')\"; statement.executeUpdate(sql); }} 代码块9 UserService： 123public interface UserService { public void saveService(Connection connection, User user) throws Exception;} 代码块10 UserServiceImpl： 123456789101112131415161718192021222324/** * 业务层 * juwin * 2015-12-04 */public class UserServiceImpl implements UserService { //下面的dao层实例由BeanFactory通过properties配置文件帮我们生成对应的实例对象 private UserDao userDao = (UserDao) BeanFactory.getBean().get(\"userDao\"); private UserDetailDao userDetailDao = (UserDetailDao) BeanFactory.getBean().get(\"userDetailDao\"); @Override public void saveService( Connection connection, User user)throws Exception { /** * 这个业务层方法执行了两个dao层方法，可以看做一个事务， * 任意一个dao层调用过程中如果发生异常，整个业务方法进行的所有dao层操作就会回滚 */ userDao.save(user, connection); /*要求在添加user的同时生产一个对应的detail，这里偷个懒，就自己new一个UserDetail对象吧*/ UserDetail userDetail = new UserDetail(); userDetail.setAge(22); userDetail.setRealname(\"juwin\"); userDetailDao.save(userDetail, connection); throw new Exception(\"拦-路-虎\");//这个异常是用来测试事务会不会回滚的，正常情况下不加这个 }} 代码块11 UserController： 12345678910111213141516171819202122/** * 程序入口，类似于controller层 */public class UserController { public void SaveUser(User user)throws Exception{ /** * 这一步很关键，为每一个执行这个操作的线程分配一个connection连接对象 * 说明：在实际web开发中客户端通过发送http请求到业务后台，这时候tomcat会为这次请求分配一个线程 * 因此就出现了并发甚至并行的现象，假象一下，我们如果只是利用单例写一个生成connection对象的方法， * 那么多线程并发访问的时候就有可能出现：线程1利用完connection对象将其状态修改为close，而此时线程2 * 也要用connection，这时候就会报“connection已经关闭”的异常 * 因此我们采用ThreadLocal，为单独一个线程生成一个单例的connection对象 */ Connection connection = ConnBean.getConn(); /** * 下面这个实例要加一层事务代理，就是让TransactionProxy这个代理类搅合一下， * 这样我们再利用service层对象调用任何方法时，都会加上事务管理了 */ UserService userService = (UserService) new TransactionProxy().getTargetObj(new UserServiceImpl()); userService.saveService(connection,user); }} 代码块12 测试类： 123456789101112public class UserAddTest { @Test public void Test1() throws Exception{ User user = new User(); user.setUserName(\"weixiaojie1993\"); user.setAddress(\"beijing\"); user.setMoney(1); UserController userController = new UserController(); userController.SaveUser(user); System.out.print(\"Done !\"); }} 代码块13 ok，大功告成了，现在让我们用junit来测试一下吧： service层不加： 1throw new Exception(\"拦-路-虎\"); 代码块14 执行结果： 可以看出来事务已经提交了，我们来看看数据库里面的变化： tb_user表： user_detail表： 然后在业务层加上： 1throw new Exception(\"拦-路-虎\"); 代码块15 运行结果： 仔细观察划绿色线的部分就能发现，事务已经回滚了，看数据库表也是没有记录的 我们主键id由于是递增的，因此我们还要确定一下事务是不是真的回滚了，我们把异常代码去掉，然后再往里面插入成功一次数据，运行后的数据库表记录如下： tb_user： user_detail： 大家仔细看id，已经是3了，说明原来事务成功回滚了 说明：其实connection对象不必每次都作为参数传递给方法，这里只是为了更清楚的展示connection的流向，其实我们用ThreadLocal封装成一个单例的时候就已经注定了本次访问（即当前线程从controller层调用到dao层）所有get到的connection对象都是同一个； 最后，个人感觉这个程序有个非常要命的地方，就是我要给service层加事务代理，这样就导致了sevice层的对象不能通过配置文件来实例化，正在纠结中。。以后还会优化，这只是简单实现以下，真正的spring要复杂的多得多，第一次在开源中国发表博客，以后也会多发一些，大家互相学习~","link":"/2015/12/04/%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9Fspring%E7%9A%84ioc%E5%92%8Caop/"},{"title":"致十年后的我-歌词","text":"这是由doriko制作、初音ミク演唱的一首歌，2015年初遇这首歌，转眼间到了2019年。 歌词 好きな人と歩いた場所も曾和喜欢的人一起走过的地方その時見た景色も那时曾看到的景色振り返らず 今を駆け抜け统统抛掉 不再回头 向前飞奔私は何と出会うの我将会遇见些什么呢 立ち止まるほど驻足不前意味を問うほど探索意义きっとまだ大人ではなくて一定是我还不够成熟今見てるもの现在看到的事物今出会う人现在遇见的人その中でただ前だけを見てる在这片纷繁喧嚣之中 我只会看向前方10年後の私へ致十年以后的我今は幸せでしょうか现在的你感到幸福么？それとも悲しみで还是正沉浸在悲伤中泣いているのでしょうか默默地流着泪？けどあなたの傍に不过在你的身旁変わらないものがあり依然会有不变的存在気付いていないだけで未能察觉的你守られていませんか依然在被守护着吧過ぎし日々に 想いを预け把思念寄托于流逝的日子里時間だけ ただ追いかけてく只有时间在不停的追赶背に寄り添った 誰かの夢に托付在我肩上的 是谁的梦想振り向ける日がいつか来るのかな总有一天必须要面对的吧10年後の私へ致十年以后的我今は誰を好きですか现在的你喜欢着谁呢？それとも変わらずに还是和以前一样あの人が好きですか继续喜欢着那个人呢？けどいつか不过 现在的你知らない誰かを爱する前に在爱上某个人之前自分のことを好きと“喜欢自己”这句话言えるようになりましたか能否先说出来呢大切な人たちは我所珍爱的朋友们今も変わらずいますか依然在反复平凡的生活吗？それとも遠く離れ还是已经远去それぞれ歩んでますか踏上了各自的旅途けど そんな出会いを但是在重复了无数次的相遇别れを 缲り返して和离别之后今の私よりも是否比现在的我すてきになっていますか更有魅力呢？10年後の私へ致十年后的我今がもし幸せなら如果现在的你是幸福的あの日の私のこと从前的我思い出してくれますか能否请你想起来呢そこにはつらいことに回忆中的我泣いた私がいるけど一定在伤心的哭泣吧その涙を優しく请将这温柔的泪水思い出に変えてください融入记忆的海洋","link":"/2019/02/12/%E8%87%B4%E5%8D%81%E5%B9%B4%E5%90%8E%E7%9A%84%E6%88%91-%E6%AD%8C%E8%AF%8D/"},{"title":"顾村的樱花-20190323","text":"记录于2019年3月23日，上海，多云，7~16℃ 下午从杨浦出发去顾村公园，据说撒苦辣开了，兴奋的骑车过去，骑行1.5小时，逛了1.5小时，回来时找不到共享单车，坐了528路公交，因为顾村连个地铁站都没有==，公交到站，又骑了一小时的车回家。 BGM：夜の向日葵","link":"/2019/03/23/%E9%A1%BE%E6%9D%91%E7%9A%84%E6%A8%B1%E8%8A%B1-20190323/"}],"tags":[{"name":"NIO","slug":"NIO","link":"/tags/NIO/"},{"name":"网络编程","slug":"网络编程","link":"/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"nosql","slug":"nosql","link":"/tags/nosql/"},{"name":"ThreadLocal","slug":"ThreadLocal","link":"/tags/ThreadLocal/"},{"name":"并发编程","slug":"并发编程","link":"/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"树","slug":"树","link":"/tags/%E6%A0%91/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"火焰图","slug":"火焰图","link":"/tags/%E7%81%AB%E7%84%B0%E5%9B%BE/"},{"name":"阻塞队列","slug":"阻塞队列","link":"/tags/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"},{"name":"juc","slug":"juc","link":"/tags/juc/"},{"name":"ReentrantLock","slug":"ReentrantLock","link":"/tags/ReentrantLock/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"事务","slug":"事务","link":"/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"map","slug":"map","link":"/tags/map/"},{"name":"散列表","slug":"散列表","link":"/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"},{"name":"集合类","slug":"集合类","link":"/tags/%E9%9B%86%E5%90%88%E7%B1%BB/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"生产者消费者模式","slug":"生产者消费者模式","link":"/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"},{"name":"工厂模式","slug":"工厂模式","link":"/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"name":"策略模式","slug":"策略模式","link":"/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"ioc","slug":"ioc","link":"/tags/ioc/"},{"name":"aop","slug":"aop","link":"/tags/aop/"},{"name":"miku","slug":"miku","link":"/tags/miku/"},{"name":"letter song","slug":"letter-song","link":"/tags/letter-song/"},{"name":"顾村公园","slug":"顾村公园","link":"/tags/%E9%A1%BE%E6%9D%91%E5%85%AC%E5%9B%AD/"},{"name":"樱花","slug":"樱花","link":"/tags/%E6%A8%B1%E8%8A%B1/"},{"name":"旅行","slug":"旅行","link":"/tags/%E6%97%85%E8%A1%8C/"}],"categories":[{"name":"网络编程","slug":"网络编程","link":"/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"并发编程","slug":"并发编程","link":"/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"NIO","slug":"网络编程/NIO","link":"/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/NIO/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"NoSQL","slug":"数据库/NoSQL","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/"},{"name":"服务治理","slug":"服务治理","link":"/categories/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/"},{"name":"杂记","slug":"杂记","link":"/categories/%E6%9D%82%E8%AE%B0/"},{"name":"ThreadLocal","slug":"并发编程/ThreadLocal","link":"/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadLocal/"},{"name":"图解多线程设计模式","slug":"并发编程/图解多线程设计模式","link":"/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%9B%BE%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"关系型数据库","slug":"数据库/关系型数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"框架","slug":"框架","link":"/categories/%E6%A1%86%E6%9E%B6/"},{"name":"日常","slug":"日常","link":"/categories/%E6%97%A5%E5%B8%B8/"},{"name":"树","slug":"数据结构/树","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"},{"name":"redis","slug":"数据库/NoSQL/redis","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/redis/"},{"name":"火焰图","slug":"服务治理/火焰图","link":"/categories/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E7%81%AB%E7%84%B0%E5%9B%BE/"},{"name":"链表","slug":"数据结构/链表","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"},{"name":"mysql","slug":"数据库/关系型数据库/mysql","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"},{"name":"散列表","slug":"数据结构/散列表","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%A3%E5%88%97%E8%A1%A8/"},{"name":"生产&消费模式","slug":"设计模式/生产-消费模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%94%9F%E4%BA%A7-%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F/"},{"name":"spring","slug":"框架/spring","link":"/categories/%E6%A1%86%E6%9E%B6/spring/"},{"name":"划水","slug":"日常/划水","link":"/categories/%E6%97%A5%E5%B8%B8/%E5%88%92%E6%B0%B4/"},{"name":"旅行","slug":"日常/旅行","link":"/categories/%E6%97%A5%E5%B8%B8/%E6%97%85%E8%A1%8C/"},{"name":"framework","slug":"框架/spring/framework","link":"/categories/%E6%A1%86%E6%9E%B6/spring/framework/"}]}