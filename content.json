{"pages":[{"title":"","text":"个人简介 93年生人，从事java服务端开发工作4年，现居上海 Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。","link":"/about/index.html"}],"posts":[{"title":"Redis小记-内存解析&内存消耗篇","text":"前置：redis内存指标 注：本文默认读者已初步学会使用redis了。 首先我们通过info命令查看相关指标，其中几个memory的重要指标整理出来如下： 属性 解释 used_memory redis内部存储的所有数据的内存总占用量（自身内存+对象内存+缓冲内存） used_memory_ress redis进程占用的总物理内存 mem_fragmentation_ratio used_memory_ress与used_memory的比值，即为内存碎片率 mem_allocator 内存分配器，默认为jemalloc 表1 一、碎片率 当内存碎片率 &gt; 1时，说明redis进程占用物理内存的总量大于Redis实际存储数据（表1第一行）的内存占用量，溢出来的部分内存被内存碎片消耗，如果溢出部分过大，则说明内存碎片率严重。 相反的，如果碎片率 &lt; 1时，则说明Redis存储的数据总量已经超出了redis进程占用内存的总量，造成这种情况是因为操作系统把Redis内存交换至硬盘导致（swap），由于硬盘读取速度远远慢与内存，因此这种情况下redis性能极差，可能出现僵死。 二、redis内存消耗的几个来源2.1：自身内存redis启动后自身运行所需内存； 2.2：对象内存内存占用最大的一部分，这里面存储的就是用户自身的数据（业务数据），数据以key-value类型存储，内存消耗可表示为：key内存+value内存。 2.3：缓冲内存主要由客户端缓冲区+复制积压缓冲区+AOF缓冲区组成，具体解释如下： 客户端缓冲区指的是所有接入redis服务器的TCP连接的输入和输出缓冲，输入缓冲无法被控制，最大空间为1G，超过立即断开连接，输出缓冲通过client-output-buffer-limit控制。 复制积压缓冲区指的是redis在2.8版本以后提供了一块可以重复利用的固定大小的缓冲区，用来实现部分复制功能，使用repl-backlog-size参数控制，默认1MB（主从结构下，主节点只存在一个该缓冲区，从节点共用，那时可以设置较大的缓冲区空间），该缓冲区可以避免全量复制。 AOF缓冲区用于存储在redis重写期间保存最近的写入命令，无法控制，通常取决于AOF重写时间以及写入命令量，一般情况下很小。 2.4：内存碎片redis默认的内存分配器是jemalloc，可选的还有glibc和tcmalloc；内存分配器为了更好的管理以及重复利用内存，分配策略一般采用固定范围的内存块进行分配；因此，我们在存储一块5kb的内容时，内存分配器可能会为我们分配8kb的块存储，剩下的3kb不能再次分配给其他对象存储，因而沦为了内存碎片；jemalloc对碎片化问题做了优化，一般来讲碎片化率保持在1.03左右。 可能造成内存碎片率过高的场景： 频繁的更新操作，例如频繁对已存在的键做append、setrange等操作； 大量过期键删除，键对象过期删除后释放的空间无法得到充分的利用，导致碎片率上升。 解决办法： 数据对齐，尽量采用数字类型或固定长度的字符串（大部分业务场景不满足这种方式）； 重启，重启节点可以使内存重整理，利用高可用的结构（节点集群+主从结构），将碎片率过高的节点主节点转换为从节点，然后进行安全重启。 2.5：子进程内存消耗子进程内存消耗指的是执行AOF/RDB重写时redis创建的子进程内存消耗；redis执行fork操作产生的子进程内存占用量对外表现为与父进程相同，理论上需要一倍的物理内存来完成重写的操作。但是linux具备写时复制技术（copy-on-write），父子进程会共享相同的物理内存页，当父进程处理写请求时会对需要修改的页复制出一份副本来完成写操作，而子进程依然读取fork时整个父进程的内存快照，总结： 子进程并不需要消耗一倍的父进程内存，实际消耗根据期间写入命令量决定，但依然要预留出一些内存防止溢出； 需要设置sysctl vm.overcommit_memory = 1允许内核可以分配所有的物理内存，防止redis进程执行fork时因剩余内存不足导致失败； 排查当前系统是否支持开启THP，如果开启建议关闭，防止copy-on-write期间内存过度消耗。","link":"/2017/08/12/Redis%E5%B0%8F%E8%AE%B0-%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90&%E5%86%85%E5%AD%98%E6%B6%88%E8%80%97%E7%AF%87/"},{"title":"java实现二叉树","text":"定义一个节点下面最多拥有两个子节点，并且两个子节点分为左值和右值，左值比父节点要小，右值比父节点要大 java实现下面，我们来利用java实现一棵如下图中的二叉树： 大家可以根据我的描述分析一下这棵二叉树 下面就来写代码实现这棵二叉树： 首先是要建立一个节点类Node： 123456789101112131415161718192021222324252627282930313233343536package Tree;/** * 节点类 * @author javadaodechengxuyuan * */public class Node { private long value; private Node leftNode;//节点下面的左节点 private Node RightNode;//节点下面的右节点 //构造器 public Node(long value){ this.value=value; } public long getValue() { return value; } public void setValue(long value) { this.value = value; } public Node getLeftNode() { return leftNode; } public void setLeftNode(Node leftNode) { this.leftNode = leftNode; } public Node getRightNode() { return RightNode; } public void setRightNode(Node rightNode) { RightNode = rightNode; }} 代码块1 这是二叉树类，就是这个类用来操作节点类的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package Tree;/** * @author javadaodechengxuyuan * 二叉树：每个节点有最多两个分叉， * 分别作为父节点的左值和右值，遵循左小右大的规则进行分叉 */public class Tree { private Node root; private Node current; private Node parent; /** * @author javadaodechengxuyuan * 为一颗二叉树添加节点 */ public void insert(long value){//为二叉树插入新的节点 //创建新的节点 Node newNode=new Node(value); //创建完后就该考虑把这个节点放在哪里了，下面这些代码就是用来判断将这个节点放在哪里的 if(root==null){ this.root=newNode;//如果root为空，那么第一次调用添加时应给root初始化 }else{ this.current=root;//初始化current while(true){//进入死循环，一直等到给newNode找到合适的位置时进行终止死循环 if(this.current.getValue()&gt;value){//比root小，放在左侧 this.parent=this.current;//让parent一直保留本次的current this.current=this.current.getLeftNode(); if(this.current==null){//如果当前的左值为空，那么就终止循环并赋值给这个左值 this.parent.setLeftNode(newNode);//将这个新节点放在这个位置 return;//最终找到合适位置，死循环终止 } }else{//比root大，放在右侧 this.parent=this.current;//让parent一直保留本次的current this.current=this.current.getRightNode();//将当前的节点重新赋值给下一次需要比较的节点 if(this.current==null){//如果当前的右值为空，那么就终止循环并赋值给这个左值 this.parent.setRightNode(newNode);//将这个新节点放在这个位置 return;//最终找到合适位置，死循环终止 } } } } } public Node getRoot() { return root; } public void setRoot(Node root) { this.root = root; }} 代码块2 这是测试类： 12345678910111213141516171819202122package Tree;/** * 测试类 * @author javadaodechengxuyuan * */public class Test { public static void main(String args[]){ Tree t=new Tree(); t.insert(10);//根节点 t.insert(20); t.insert(15); t.insert(9); t.insert(35); System.out.print(t.getRoot().getValue()+\"、\");//第0层：根节点 System.out.print(t.getRoot().getLeftNode().getValue()+\"、\");//第一层左值 System.out.print(t.getRoot().getRightNode().getValue()+\"、\");//第一层右值 System.out.print(t.getRoot().getRightNode().getLeftNode().getValue()+\"、\");//第二层左值 System.out.print(t.getRoot().getRightNode().getRightNode().getValue());//第二层右值 //输出结果应为：10、9、20、15、35 }} 代码块3 输出结果应该为： 110、9、20、15、35 这只是简单的插入功能，下一节我会写如何查找二叉树的节点以及删除节点、还有如何遍历一棵二叉树","link":"/2014/07/04/java%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"利用java实现一个简单的链表结构","text":"定义所谓链表就是指在某节点存储数据的过程中还要有一个属性用来指向下一个链表节点，这样的数据存储方式叫做链表 链表的优缺点优点：易于存储和删除 缺点：查询起来较麻烦 java实现下面我们用java来实现如下链表结构： 首先定义节点类： 123456789101112131415161718192021222324252627282930package LinkTest;/** * 链表节点类 * @author admin * */public class Node { private int value;//存储数据 private Node next;//下一个节点 /** * 定义构造器 * @param vlaue * @param value */ public Node(int value){ this.value=value; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } public Node getNext() { return next; } public void setNext(Node next) { this.next = next; }} 代码块1 然后定义一个链表类： 注意：遍历链表定义了两个方法，一个是普通方法，一个是递归方法，都可以遍历出来 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package LinkTest;/** * 链表 * @author admin * */public class Link { private Node current; private Node root; public void insert(int vlaue){ Node newNode=new Node(vlaue); if(this.current==null){ this.current=newNode; this.root=this.current; }else{ this.current.setNext(newNode); this.current=this.current.getNext(); } } //普通遍历 public void getList(){ this.current=this.root; while(this.current!=null){ System.out.print(this.current.getValue()); this.current=this.current.getNext(); if(this.current!=null){ System.out.print(\"-------&gt;\"); } } } //递归遍历 public void getList2(){ DG(this.root); } //递归方法 public void DG(Node node){ System.out.print(node.getValue()+\"-----&gt;\"); if(node.getNext()!=null){ DG(node.getNext()); }else{ return; } }} 代码块2 测试类： 123456789101112131415161718package LinkTest;/** * 测试类 * @author admin * */public class Test { public static void main(String[] args){ Link l=new Link(); l.insert(1); l.insert(4); l.insert(5); l.insert(6); l.insert(9); l.insert(8); l.getList(); }} 代码块3 测试类运行结果： 11-------&gt;4-------&gt;5-------&gt;6-------&gt;9-------&gt;8 这样我们就用java实现了一个简单的链表结构。","link":"/2014/07/04/%E5%88%A9%E7%94%A8java%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84/"},{"title":"数据库事务的隔离级别","text":"一、数据库事务的几个特性1.1：原子性最基本的特性，意思是在一个事务内里所有关于数据库的操作，要么全部成功，要么全部失败；成功时意味着本次操作所有数据库相关的写操作全部持久化，无法更改，失败意味着本次操作相对于操作前对数据库没有任何影响和改变。 1.2：一致性指的是一次完整的事务必须将数据库的一个一致状态转变到另外一个一致状态。 一致性写 例如：事务A要做的操作是将A、B、C三个记录修改为D、E、F，那么A、B、C—–&gt;D、E、F的过程就满足了事务一致性，但是如果出现类似：A、B、C—-&gt;D、E、C（A、B修改成功，但是C未修改）则认定违背了事务的一致性，简单理解一致性就是指事务的“初始状态”到“修改完成状态”与“目标状态一致”。 一致性读 事务A在某一刻发起查询请求，那么查询结果是以那一刻为准，保证了数据在查询一刻的一致性。 1.3：持久性指一次事务的成功提交对数据库造成的修改是永久性的。 1.4：隔离性当多个用户并发访问数据库时，数据库为每一个用户开启的事务不可以被其他事务所影响，也就是说并发事务间要相互独立不受到干扰。关于隔离性分了集中隔离等级，本篇文章将详细介绍这几种隔离等级。 二、事务并发时的隔离级别2.1：Read Uncommitted（读未提交）这个隔离级别下未被提交的事务下所做的任何操作都可以被其他事务所读取到，这时候会造成数据的脏读、幻读、不可重复读问题。 2.2：Read Committed（读已提交）这个隔离级别下未被提交的操作不可以被其他事务所读取到，简单来讲就是单个事务里的内容在事务成功提交之前，是不会被其他事务所读取（发现）到的，但是这样同样会出现幻读、不可重复读现象。 举个栗子：事务T1要对C表做添加操作，同时事务T2里要读取C表，T2第一次读取C表时返回1条数据，这时T1执行完毕，那么T2如果再次取一次C表数据就会发现多出一条数据。 2.3：Repeatable Read（可重读）Mysql默认的隔离级别，这个隔离级别下同一事务读取到的数据一致（简单点说就是T1一旦开始，读取到数据如果中间被T2修改，那么T1再次读取该数据是和第一次读取时一样的），因此，在该隔离级别下，不会造成脏读、不可重复读，但依旧会造成幻读现象。 2.4：Serializable（串行）最高隔离级别，会为每个事务排序（为每条数据都加上锁），使之执行串行化，不可能产生冲突，因此解决了脏读、幻读、不可重复读问题，但是会造成锁竞争甚至超时，一般不会采用这种极端的隔离机制。 三、事务并发过程中产生的问题3.1：脏读一个事务读取到了另外一个事务中未提交的数据。 3.2：不可重复读一个事务读取到了另外一个事务中提交的修改掉的数据。 3.3：幻读一个事务读取到了另外一个事务中添加的数据。 Tip：不可重复读和幻读的区别在于着重点一个是update，一个是insert 四、各种隔离级别下对应的问题通过设置不同的事务隔离级别，可以避免事务并发时所造成的部分问题。 总结四种隔离级别所造成和避免的问题（请先看以上内容后再看此表）： 隔离级别 脏读 不可重复读 幻读 Read Uncommitted 是 是 是 Read Committed 否 是 是 Repeatable Read 否 否 是 Serializable 否 否 否 表1","link":"/2017/04/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"},{"title":"简单模拟spring的ioc和aop","text":"spring最核心的部分莫过于ioc和aop了，下面来简单模拟下这两种思想 ps：如果有哪里理解的不对或者代码上有瑕疵的地方欢迎大家指正，大家互相学习，还有就是这只是模仿一下spring思想，只是把事务管理和bean管理简单模仿一下，完全不代表spring，如果想深入理解请看spring源码 下面就开始进行简单的模拟。 这个项目不是web项目，只是一个简单的java项目，测试用junit，废话不多说了，下面上代码： 项目的目录结构： 说明：图中划红线的部分都是核心部分 红线部分说明： BeanFactory：所有bean的核心生成器（spring容器） ConnBean：jdbc连接生成器（没用连接池哦~） Transaction：事务管理的代理类 beans.properties：配置文件 其余的没划线的就是domain、dao、service、controller这些web基本层次结构，待会会说 主要几个类的代码： ① BeanFactory： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package sun.juwin.factory;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.HashMap;/** * 本类用来读取配置文件中的信息对每个接口对象生成具体的实现 * 主要是将接口作为key，实例作为value存储进去，这是个单例， * spring默认为每个层次生成实现也是单例，但可以通过@Scope * 来指定，我们简单模仿一下，只是单例 */public class BeanFactory { private static HashMap&lt;String, Object&gt; mapResult; public static HashMap&lt;String, Object&gt; getBean() { if (mapResult == null) { synchronized (BeanFactory.class) {//双重检查的单例，防止多线程访问时多次new对象 if (mapResult == null) { BufferedReader bf = null; String line = null; try { /** *下面这句代码通过流来读取资源包下面的配置文件，为了省去不必要的麻烦， * 我们没有用xml，而是用了properties */ InputStreamReader inputStreamReader = new InputStreamReader(BeanFactory.class.getClassLoader().getResourceAsStream(\"beans.properties\")); bf = new BufferedReader(inputStreamReader); mapResult = new HashMap&lt;&gt;(); while ((line = bf.readLine()) != null) {//每次仅读一行 if (\"\".equals(line)){//有可能读到换行时隔了一行（即只有一个换行符） continue; } String[] point = line.trim().split(\"=\");//按照等号拼接 if (point.length &gt; 2) { throw new Exception(\"beans文件格式不对！\"); } Object obj = Class.forName(point[1].trim()).newInstance();//反射实例化出目标对象 mapResult.put(point[0].trim(), obj);//然后以键值对的形式存入 } } catch (Exception e) { e.printStackTrace(); } } } } return mapResult; }} 代码块1 上面的类可以通过配置文件来实例化不同的对象，符合ioc最基本的思想，下面让我们来看看配置文件beans.properties的内容吧： 12userDao = sun.juwin.dao.impl.UserDaoImpluserDetailDao = sun.juwin.dao.impl.UserDetailDaoImpl 这里面只有两句话，指定dao层接口对象的实现类的路径，其实已经很接近spring的xml里对bean的配置了，只不过这里是properties文件，简化了许多 ② TransactionProxy代理类： 123456789101112131415161718192021222324252627282930313233343536package sun.juwin.proxy.transctional;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.sql.Connection;/** * 事务代理类，通过这个类可以为要执行的方法加上事务管理 */public class TransactionProxy implements InvocationHandler { private Object targetObj; public Object getTargetObj(Object targetObj){ this.targetObj = targetObj; return Proxy.newProxyInstance(this.targetObj.getClass().getClassLoader(), this.targetObj.getClass().getInterfaces(), this); } /*下面这个方法会在被代理类执行方法时调用，拿到被代理类的要执行的method对象*/ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object result = null; Connection connection = (Connection)args[0];//要求第一个参数必须是conn try{ connection.setAutoCommit(false);//开启事务 result = method.invoke(this.targetObj, args);//执行目标方法 connection.commit();//事务提交 System.out.print(\"commit success!\"); }catch (Exception e){ connection.rollback();//事务回滚 System.err.println(\"rollback!\"); e.printStackTrace(); }finally { connection.close();//关闭连接 System.out.println(\"connection closed!\"); } return result; }} 代码块2 说明：java在1.3版本的时候就为我们提供了一个用作代理类实现的接口InvacationHandler，通过实现这个接口可以很随意的写一个耦合度特别低的动态代理类（即这一个代理类可以代理任何类） ③ ConnBean，用来生成一个数据库连接对象，在不用连接池的情况下，我们用ThreadLocal进行封装，代码如下： 123456789101112131415161718192021222324package sun.juwin.db;import java.sql.Connection;import java.sql.DriverManager;/*原始产生数据库连接的类*/public class ConnBean { private static ThreadLocal conn = new ThreadLocal&lt;&gt;(); private ConnBean(){} public static Connection getConn(){ Connection connection = conn.get(); if(connection == null){ synchronized (ConnBean.class){//由于用到了ThreadLocal，因此该单例仅仅相对于当前线程是单例的 if(connection == null){ try{ Connection realConn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db_useradd\", \"root\", \"\"); conn.set(realConn); }catch (Exception e){ e.printStackTrace(); } } } } return conn.get();//返回给当前线程一个Connection对象 }} 代码块3 以上就是核心的一些实现代码，下面让我们来看一下我们的业务吧： 实体类：User，UserDetail，要求添加一个User的同时要添加一个UserDetail User： 1234private Long id;private String userName;private String address;private int money; 代码块4 UserDetail： 123private Long id;private int age;private String realname; 代码块5 dao层的接口和实现： UserDao： 123public interface UserDao { public void save(User user, Connection conn)throws Exception;} 代码块6 UserDaoImpl： 123456789101112public class UserDaoImpl implements UserDao{ @Override public void save(User user, Connection conn) throws Exception { Statement statement = conn.createStatement();//为了省去不必要的麻烦，我们不用预编译语句 String sql = \"insert into tb_user (userName, address, money) values ('\" + user.getUserName() + \"', '\" + user.getAddress() + \"', \" + user.getMoney() + \")\"; statement.executeUpdate(sql); statement.close(); }} 代码块7 UserDetailDao： 123public interface UserDetailDao { public void save(UserDetail userDetail, Connection connection) throws Exception;} 代码块8 UserDetailDaoImpl： 12345678910public class UserDetailDaoImpl implements UserDetailDao { @Override public void save(UserDetail userDetail, Connection connection) throws Exception { Statement statement = connection.createStatement(); String sql = \"insert into user_detail (age, realname) values (\" +userDetail.getAge()+\", '\" +userDetail.getRealname()+\"')\"; statement.executeUpdate(sql); }} 代码块9 UserService： 123public interface UserService { public void saveService(Connection connection, User user) throws Exception;} 代码块10 UserServiceImpl： 123456789101112131415161718192021222324/** * 业务层 * juwin * 2015-12-04 */public class UserServiceImpl implements UserService { //下面的dao层实例由BeanFactory通过properties配置文件帮我们生成对应的实例对象 private UserDao userDao = (UserDao) BeanFactory.getBean().get(\"userDao\"); private UserDetailDao userDetailDao = (UserDetailDao) BeanFactory.getBean().get(\"userDetailDao\"); @Override public void saveService( Connection connection, User user)throws Exception { /** * 这个业务层方法执行了两个dao层方法，可以看做一个事务， * 任意一个dao层调用过程中如果发生异常，整个业务方法进行的所有dao层操作就会回滚 */ userDao.save(user, connection); /*要求在添加user的同时生产一个对应的detail，这里偷个懒，就自己new一个UserDetail对象吧*/ UserDetail userDetail = new UserDetail(); userDetail.setAge(22); userDetail.setRealname(\"juwin\"); userDetailDao.save(userDetail, connection); throw new Exception(\"拦-路-虎\");//这个异常是用来测试事务会不会回滚的，正常情况下不加这个 }} 代码块11 UserController： 12345678910111213141516171819202122/** * 程序入口，类似于controller层 */public class UserController { public void SaveUser(User user)throws Exception{ /** * 这一步很关键，为每一个执行这个操作的线程分配一个connection连接对象 * 说明：在实际web开发中客户端通过发送http请求到业务后台，这时候tomcat会为这次请求分配一个线程 * 因此就出现了并发甚至并行的现象，假象一下，我们如果只是利用单例写一个生成connection对象的方法， * 那么多线程并发访问的时候就有可能出现：线程1利用完connection对象将其状态修改为close，而此时线程2 * 也要用connection，这时候就会报“connection已经关闭”的异常 * 因此我们采用ThreadLocal，为单独一个线程生成一个单例的connection对象 */ Connection connection = ConnBean.getConn(); /** * 下面这个实例要加一层事务代理，就是让TransactionProxy这个代理类搅合一下， * 这样我们再利用service层对象调用任何方法时，都会加上事务管理了 */ UserService userService = (UserService) new TransactionProxy().getTargetObj(new UserServiceImpl()); userService.saveService(connection,user); }} 代码块12 测试类： 123456789101112public class UserAddTest { @Test public void Test1() throws Exception{ User user = new User(); user.setUserName(\"weixiaojie1993\"); user.setAddress(\"beijing\"); user.setMoney(1); UserController userController = new UserController(); userController.SaveUser(user); System.out.print(\"Done !\"); }} 代码块13 ok，大功告成了，现在让我们用junit来测试一下吧： service层不加： 1throw new Exception(\"拦-路-虎\"); 代码块14 执行结果： 可以看出来事务已经提交了，我们来看看数据库里面的变化： tb_user表： user_detail表： 然后在业务层加上： 1throw new Exception(\"拦-路-虎\"); 代码块15 运行结果： 仔细观察划绿色线的部分就能发现，事务已经回滚了，看数据库表也是没有记录的 我们主键id由于是递增的，因此我们还要确定一下事务是不是真的回滚了，我们把异常代码去掉，然后再往里面插入成功一次数据，运行后的数据库表记录如下： tb_user： user_detail： 大家仔细看id，已经是3了，说明原来事务成功回滚了 说明：其实connection对象不必每次都作为参数传递给方法，这里只是为了更清楚的展示connection的流向，其实我们用ThreadLocal封装成一个单例的时候就已经注定了本次访问（即当前线程从controller层调用到dao层）所有get到的connection对象都是同一个； 最后，个人感觉这个程序有个非常要命的地方，就是我要给service层加事务代理，这样就导致了sevice层的对象不能通过配置文件来实例化，正在纠结中。。以后还会优化，这只是简单实现以下，真正的spring要复杂的多得多，第一次在开源中国发表博客，以后也会多发一些，大家互相学习~","link":"/2015/12/04/%E7%AE%80%E5%8D%95%E6%A8%A1%E6%8B%9Fspring%E7%9A%84ioc%E5%92%8Caop/"},{"title":"简单实现生产者和消费者模式","text":"本实例中单独为生产者和消费者各开辟一个线程作为生产者和消费者的执行线程，在生产者消费者设计模式中存在一个数据缓冲区，使生产者和消费者的“生产”和“消费”动作都在该缓冲区进行，这样做的目的就是保证了生产者和消费者的完美解耦，试想一下如果没了这个缓冲区，生产者和消费者中的方法互调，那么两个类的关联度（耦合度）就会很高，一旦一个发生变化，势必会影响另外一个； 下面开始我们的实例： 首先是生产者的代码： 12345678910111213141516171819202122/** * 生产者 */public class Product implements Runnable{ private Queue queue; public Product(Queue queue){ this.queue = queue; } @Override public void run() { try{ for(int i = 0; i &lt; 10; i++){ queue.product(\"Product------\" + \"No.\" + i);//开始生产 } }catch (Exception e){ e.printStackTrace(); } }} 代码块1 这是消费者： 12345678910111213141516171819202122/** * 消费者 */public class Consumer implements Runnable{ private Queue queue; public Consumer(Queue queue){ this.queue = queue; } @Override public void run() { try{ for(int i = 0; i &lt; 10; i++){ System.out.println(\"already gone : \" + queue.consumer());//开始消费 } }catch (Exception e){ e.printStackTrace(); } }} 代码块2 这是缓冲区，几乎所有的逻辑都是在这里实现的： 123456789101112131415161718192021222324252627282930313233343536373839/** * 队列缓冲区 */public class Queue { private Object signal = new Object();//当前线程的挂起和执行标记 private boolean isFull = false;//队列是否已满 private List list = new ArrayList&lt;&gt;();//队列 public void product(String msg) throws Exception{ synchronized (signal){ if(!isFull){//如果没有满，执行如下代码 list.add(msg);//加进队列 isFull = true; System.out.println(\"Product One !\"); signal.notify();//唤醒当前消费者里面被挂起的线程 } signal.wait();//否则，如果当前满了，说明消费者正在消费，挂起当前生产线程 } } public String consumer() throws Exception{ synchronized (signal){ if(!isFull){ //不满，说明生产者正在生产，应当挂起consumer线程 System.out.println(\"Empty Product !\"); signal.wait(); } isFull = false;//已消费，队列被标记为不满状态 signal.notify();//通知生产者 } //消费（读取） String result = \"\"; if(list.size() &gt; 0){ result = this.list.get(list.size() - 1); this.list.remove(list.size() - 1); } return result; }} 代码块3 上面这个模式利用java现有的阻塞队列很容易实现，可以避免上述代码中很大一部分代码（线程的挂起、唤醒、队列弹出数据等）","link":"/2016/04/15/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"nosql","slug":"nosql","link":"/tags/nosql/"},{"name":"树","slug":"树","link":"/tags/%E6%A0%91/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"事务","slug":"事务","link":"/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"ioc","slug":"ioc","link":"/tags/ioc/"},{"name":"aop","slug":"aop","link":"/tags/aop/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"生产者消费者模式","slug":"生产者消费者模式","link":"/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"关系型数据库","slug":"数据库/关系型数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"NoSQL","slug":"数据库/NoSQL","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/"},{"name":"框架","slug":"框架","link":"/categories/%E6%A1%86%E6%9E%B6/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"树","slug":"数据结构/树","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"},{"name":"链表","slug":"数据结构/链表","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"},{"name":"mysql","slug":"数据库/关系型数据库/mysql","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"},{"name":"redis","slug":"数据库/NoSQL/redis","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/redis/"},{"name":"spring","slug":"框架/spring","link":"/categories/%E6%A1%86%E6%9E%B6/spring/"},{"name":"生产&消费模式","slug":"设计模式/生产-消费模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%94%9F%E4%BA%A7-%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F/"},{"name":"framework","slug":"框架/spring/framework","link":"/categories/%E6%A1%86%E6%9E%B6/spring/framework/"}]}