{"pages":[{"title":"","text":"个人简介 93年生人，从事java服务端开发工作4年，现居上海 Icarus 主题以白色的简洁为主，但有时候我们希望在文章中用特别的样式注明一些内容，markdown 语法就不够用了，所以在此分享一下我的高级玩法。","link":"/about/index.html"}],"posts":[{"title":"Redis小记-内存解析&内存消耗篇","text":"前置：redis内存指标 注：本文默认读者已初步学会使用redis了。 首先我们通过info命令查看相关指标，其中几个memory的重要指标整理出来如下： 属性 解释 used_memory redis内部存储的所有数据的内存总占用量（自身内存+对象内存+缓冲内存） used_memory_ress redis进程占用的总物理内存 mem_fragmentation_ratio used_memory_ress与used_memory的比值，即为内存碎片率 mem_allocator 内存分配器，默认为jemalloc 表1 一、碎片率 当内存碎片率 &gt; 1时，说明redis进程占用物理内存的总量大于Redis实际存储数据（表1第一行）的内存占用量，溢出来的部分内存被内存碎片消耗，如果溢出部分过大，则说明内存碎片率严重。 相反的，如果碎片率 &lt; 1时，则说明Redis存储的数据总量已经超出了redis进程占用内存的总量，造成这种情况是因为操作系统把Redis内存交换至硬盘导致（swap），由于硬盘读取速度远远慢与内存，因此这种情况下redis性能极差，可能出现僵死。 二、redis内存消耗的几个来源2.1：自身内存redis启动后自身运行所需内存； 2.2：对象内存内存占用最大的一部分，这里面存储的就是用户自身的数据（业务数据），数据以key-value类型存储，内存消耗可表示为：key内存+value内存。 2.3：缓冲内存主要由客户端缓冲区+复制积压缓冲区+AOF缓冲区组成，具体解释如下： 客户端缓冲区指的是所有接入redis服务器的TCP连接的输入和输出缓冲，输入缓冲无法被控制，最大空间为1G，超过立即断开连接，输出缓冲通过client-output-buffer-limit控制。 复制积压缓冲区指的是redis在2.8版本以后提供了一块可以重复利用的固定大小的缓冲区，用来实现部分复制功能，使用repl-backlog-size参数控制，默认1MB（主从结构下，主节点只存在一个该缓冲区，从节点共用，那时可以设置较大的缓冲区空间），该缓冲区可以避免全量复制。 AOF缓冲区用于存储在redis重写期间保存最近的写入命令，无法控制，通常取决于AOF重写时间以及写入命令量，一般情况下很小。 2.4：内存碎片redis默认的内存分配器是jemalloc，可选的还有glibc和tcmalloc；内存分配器为了更好的管理以及重复利用内存，分配策略一般采用固定范围的内存块进行分配；因此，我们在存储一块5kb的内容时，内存分配器可能会为我们分配8kb的块存储，剩下的3kb不能再次分配给其他对象存储，因而沦为了内存碎片；jemalloc对碎片化问题做了优化，一般来讲碎片化率保持在1.03左右。 可能造成内存碎片率过高的场景： 频繁的更新操作，例如频繁对已存在的键做append、setrange等操作； 大量过期键删除，键对象过期删除后释放的空间无法得到充分的利用，导致碎片率上升。 解决办法： 数据对齐，尽量采用数字类型或固定长度的字符串（大部分业务场景不满足这种方式）； 重启，重启节点可以使内存重整理，利用高可用的结构（节点集群+主从结构），将碎片率过高的节点主节点转换为从节点，然后进行安全重启。 2.5：子进程内存消耗子进程内存消耗指的是执行AOF/RDB重写时redis创建的子进程内存消耗；redis执行fork操作产生的子进程内存占用量对外表现为与父进程相同，理论上需要一倍的物理内存来完成重写的操作。但是linux具备写时复制技术（copy-on-write），父子进程会共享相同的物理内存页，当父进程处理写请求时会对需要修改的页复制出一份副本来完成写操作，而子进程依然读取fork时整个父进程的内存快照，总结： 子进程并不需要消耗一倍的父进程内存，实际消耗根据期间写入命令量决定，但依然要预留出一些内存防止溢出； 需要设置sysctl vm.overcommit_memory = 1允许内核可以分配所有的物理内存，防止redis进程执行fork时因剩余内存不足导致失败； 排查当前系统是否支持开启THP，如果开启建议关闭，防止copy-on-write期间内存过度消耗。","link":"/2017/08/12/Redis%E5%B0%8F%E8%AE%B0-%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90&%E5%86%85%E5%AD%98%E6%B6%88%E8%80%97%E7%AF%87/"},{"title":"java实现二叉树","text":"定义一个节点下面最多拥有两个子节点，并且两个子节点分为左值和右值，左值比父节点要小，右值比父节点要大 java实现下面，我们来利用java实现一棵如下图中的二叉树： 大家可以根据我的描述分析一下这棵二叉树 下面就来写代码实现这棵二叉树： 首先是要建立一个节点类Node： 123456789101112131415161718192021222324252627282930313233343536package Tree;/** * 节点类 * @author javadaodechengxuyuan * */public class Node { private long value; private Node leftNode;//节点下面的左节点 private Node RightNode;//节点下面的右节点 //构造器 public Node(long value){ this.value=value; } public long getValue() { return value; } public void setValue(long value) { this.value = value; } public Node getLeftNode() { return leftNode; } public void setLeftNode(Node leftNode) { this.leftNode = leftNode; } public Node getRightNode() { return RightNode; } public void setRightNode(Node rightNode) { RightNode = rightNode; }} 代码块1 这是二叉树类，就是这个类用来操作节点类的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package Tree;/** * @author javadaodechengxuyuan * 二叉树：每个节点有最多两个分叉， * 分别作为父节点的左值和右值，遵循左小右大的规则进行分叉 */public class Tree { private Node root; private Node current; private Node parent; /** * @author javadaodechengxuyuan * 为一颗二叉树添加节点 */ public void insert(long value){//为二叉树插入新的节点 //创建新的节点 Node newNode=new Node(value); //创建完后就该考虑把这个节点放在哪里了，下面这些代码就是用来判断将这个节点放在哪里的 if(root==null){ this.root=newNode;//如果root为空，那么第一次调用添加时应给root初始化 }else{ this.current=root;//初始化current while(true){//进入死循环，一直等到给newNode找到合适的位置时进行终止死循环 if(this.current.getValue()&gt;value){//比root小，放在左侧 this.parent=this.current;//让parent一直保留本次的current this.current=this.current.getLeftNode(); if(this.current==null){//如果当前的左值为空，那么就终止循环并赋值给这个左值 this.parent.setLeftNode(newNode);//将这个新节点放在这个位置 return;//最终找到合适位置，死循环终止 } }else{//比root大，放在右侧 this.parent=this.current;//让parent一直保留本次的current this.current=this.current.getRightNode();//将当前的节点重新赋值给下一次需要比较的节点 if(this.current==null){//如果当前的右值为空，那么就终止循环并赋值给这个左值 this.parent.setRightNode(newNode);//将这个新节点放在这个位置 return;//最终找到合适位置，死循环终止 } } } } } public Node getRoot() { return root; } public void setRoot(Node root) { this.root = root; }} 代码块2 这是测试类： 12345678910111213141516171819202122package Tree;/** * 测试类 * @author javadaodechengxuyuan * */public class Test { public static void main(String args[]){ Tree t=new Tree(); t.insert(10);//根节点 t.insert(20); t.insert(15); t.insert(9); t.insert(35); System.out.print(t.getRoot().getValue()+\"、\");//第0层：根节点 System.out.print(t.getRoot().getLeftNode().getValue()+\"、\");//第一层左值 System.out.print(t.getRoot().getRightNode().getValue()+\"、\");//第一层右值 System.out.print(t.getRoot().getRightNode().getLeftNode().getValue()+\"、\");//第二层左值 System.out.print(t.getRoot().getRightNode().getRightNode().getValue());//第二层右值 //输出结果应为：10、9、20、15、35 }} 代码块3 输出结果应该为： 110、9、20、15、35 这只是简单的插入功能，下一节我会写如何查找二叉树的节点以及删除节点、还有如何遍历一棵二叉树","link":"/2014/07/04/java%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"利用java实现一个简单的链表结构","text":"定义所谓链表就是指在某节点存储数据的过程中还要有一个属性用来指向下一个链表节点，这样的数据存储方式叫做链表 链表的优缺点优点：易于存储和删除 缺点：查询起来较麻烦 java实现下面我们用java来实现如下链表结构： 首先定义节点类： 123456789101112131415161718192021222324252627282930package LinkTest;/** * 链表节点类 * @author admin * */public class Node { private int value;//存储数据 private Node next;//下一个节点 /** * 定义构造器 * @param vlaue * @param value */ public Node(int value){ this.value=value; } public int getValue() { return value; } public void setValue(int value) { this.value = value; } public Node getNext() { return next; } public void setNext(Node next) { this.next = next; }} 代码块1 然后定义一个链表类： 注意：遍历链表定义了两个方法，一个是普通方法，一个是递归方法，都可以遍历出来 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package LinkTest;/** * 链表 * @author admin * */public class Link { private Node current; private Node root; public void insert(int vlaue){ Node newNode=new Node(vlaue); if(this.current==null){ this.current=newNode; this.root=this.current; }else{ this.current.setNext(newNode); this.current=this.current.getNext(); } } //普通遍历 public void getList(){ this.current=this.root; while(this.current!=null){ System.out.print(this.current.getValue()); this.current=this.current.getNext(); if(this.current!=null){ System.out.print(\"-------&gt;\"); } } } //递归遍历 public void getList2(){ DG(this.root); } //递归方法 public void DG(Node node){ System.out.print(node.getValue()+\"-----&gt;\"); if(node.getNext()!=null){ DG(node.getNext()); }else{ return; } }} 代码块2 测试类： 123456789101112131415161718package LinkTest;/** * 测试类 * @author admin * */public class Test { public static void main(String[] args){ Link l=new Link(); l.insert(1); l.insert(4); l.insert(5); l.insert(6); l.insert(9); l.insert(8); l.getList(); }} 代码块3 测试类运行结果： 11-------&gt;4-------&gt;5-------&gt;6-------&gt;9-------&gt;8 这样我们就用java实现了一个简单的链表结构。","link":"/2014/07/04/%E5%88%A9%E7%94%A8java%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84/"},{"title":"数据库事务的隔离级别","text":"一、数据库事务的几个特性1.1：原子性最基本的特性，意思是在一个事务内里所有关于数据库的操作，要么全部成功，要么全部失败；成功时意味着本次操作所有数据库相关的写操作全部持久化，无法更改，失败意味着本次操作相对于操作前对数据库没有任何影响和改变。 1.2：一致性指的是一次完整的事务必须将数据库的一个一致状态转变到另外一个一致状态。 一致性写 例如：事务A要做的操作是将A、B、C三个记录修改为D、E、F，那么A、B、C—–&gt;D、E、F的过程就满足了事务一致性，但是如果出现类似：A、B、C—-&gt;D、E、C（A、B修改成功，但是C未修改）则认定违背了事务的一致性，简单理解一致性就是指事务的“初始状态”到“修改完成状态”与“目标状态一致”。 一致性读 事务A在某一刻发起查询请求，那么查询结果是以那一刻为准，保证了数据在查询一刻的一致性。 1.3：持久性指一次事务的成功提交对数据库造成的修改是永久性的。 1.4：隔离性当多个用户并发访问数据库时，数据库为每一个用户开启的事务不可以被其他事务所影响，也就是说并发事务间要相互独立不受到干扰。关于隔离性分了集中隔离等级，本篇文章将详细介绍这几种隔离等级。 二、事务并发时的隔离级别2.1：Read Uncommitted（读未提交）这个隔离级别下未被提交的事务下所做的任何操作都可以被其他事务所读取到，这时候会造成数据的脏读、幻读、不可重复读问题。 2.2：Read Committed（读已提交）这个隔离级别下未被提交的操作不可以被其他事务所读取到，简单来讲就是单个事务里的内容在事务成功提交之前，是不会被其他事务所读取（发现）到的，但是这样同样会出现幻读、不可重复读现象。 举个栗子：事务T1要对C表做添加操作，同时事务T2里要读取C表，T2第一次读取C表时返回1条数据，这时T1执行完毕，那么T2如果再次取一次C表数据就会发现多出一条数据。 2.3：Repeatable Read（可重读）Mysql默认的隔离级别，这个隔离级别下同一事务读取到的数据一致（简单点说就是T1一旦开始，读取到数据如果中间被T2修改，那么T1再次读取该数据是和第一次读取时一样的），因此，在该隔离级别下，不会造成脏读、不可重复读，但依旧会造成幻读现象。 2.4：Serializable（串行）最高隔离级别，会为每个事务排序（为每条数据都加上锁），使之执行串行化，不可能产生冲突，因此解决了脏读、幻读、不可重复读问题，但是会造成锁竞争甚至超时，一般不会采用这种极端的隔离机制。 三、事务并发过程中产生的问题3.1：脏读一个事务读取到了另外一个事务中未提交的数据。 3.2：不可重复读一个事务读取到了另外一个事务中提交的修改掉的数据。 3.3：幻读一个事务读取到了另外一个事务中添加的数据。 Tip：不可重复读和幻读的区别在于着重点一个是update，一个是insert 四、各种隔离级别下对应的问题通过设置不同的事务隔离级别，可以避免事务并发时所造成的部分问题。 总结四种隔离级别所造成和避免的问题（请先看以上内容后再看此表）： 隔离级别 脏读 不可重复读 幻读 Read Uncommitted 是 是 是 Read Committed 否 是 是 Repeatable Read 否 否 是 Serializable 否 否 否 表1","link":"/2017/04/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"}],"tags":[{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"nosql","slug":"nosql","link":"/tags/nosql/"},{"name":"树","slug":"树","link":"/tags/%E6%A0%91/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"事务","slug":"事务","link":"/tags/%E4%BA%8B%E5%8A%A1/"}],"categories":[{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"关系型数据库","slug":"数据库/关系型数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"NoSQL","slug":"数据库/NoSQL","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/"},{"name":"树","slug":"数据结构/树","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"},{"name":"链表","slug":"数据结构/链表","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"},{"name":"mysql","slug":"数据库/关系型数据库/mysql","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"},{"name":"redis","slug":"数据库/NoSQL/redis","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/NoSQL/redis/"}]}