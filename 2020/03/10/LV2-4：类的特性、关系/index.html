<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><meta name="keywords" content="[object Object]"><meta name="description" content="一、继承和多态1.1：一个例子参考之前的Cat类，如果我现在让你设计一个Dog类，它仍然具备眼睛、性别等属性，也会跑、吃等动作，这个时候你一定会发现，单独再为Dog搞一套跟Cat差不多的类定义吗？就没有更聪明的办法吗？"><meta name="author" content="exceting"><title>LV2-4：类的特性、关系 - S-Virus</title><meta description="一、继承和多态1.1：一个例子参考之前的Cat类，如果我现在让你设计一个Dog类，它仍然具备眼睛、性别等属性，也会跑、吃等动作，这个时候你一定会发现，单独再为Dog搞一套跟Cat差不多的类定义吗？就没有更聪明的办法吗？"><meta property="og:type" content="article"><meta property="og:title" content="LV2-4：类的特性、关系"><meta property="og:url" content="http://yoursite.com/2020/03/10/LV2-4%EF%BC%9A%E7%B1%BB%E7%9A%84%E7%89%B9%E6%80%A7%E3%80%81%E5%85%B3%E7%B3%BB/"><meta property="og:site_name" content="S-Virus"><meta property="og:description" content="一、继承和多态1.1：一个例子参考之前的Cat类，如果我现在让你设计一个Dog类，它仍然具备眼睛、性别等属性，也会跑、吃等动作，这个时候你一定会发现，单独再为Dog搞一套跟Cat差不多的类定义吗？就没有更聪明的办法吗？"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://myblog.sharemer.com/avatar_2.png"><meta property="article:published_time" content="2020-03-10T03:18:00.000Z"><meta property="article:modified_time" content="2020-05-08T16:53:24.922Z"><meta property="article:author" content="exceting"><meta property="article:tag" content="教程"><meta property="article:tag" content="基础知识"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://myblog.sharemer.com/avatar_2.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2020/03/10/LV2-4%EF%BC%9A%E7%B1%BB%E7%9A%84%E7%89%B9%E6%80%A7%E3%80%81%E5%85%B3%E7%B3%BB/"},"headline":"LV2-4：类的特性、关系","image":["http://myblog.sharemer.com/avatar_2.png"],"datePublished":"2020-03-10T03:18:00.000Z","dateModified":"2020-05-08T16:53:24.922Z","author":{"@type":"Person","name":"exceting"},"description":"一、继承和多态1.1：一个例子参考之前的Cat类，如果我现在让你设计一个Dog类，它仍然具备眼睛、性别等属性，也会跑、吃等动作，这个时候你一定会发现，单独再为Dog搞一套跟Cat差不多的类定义吗？就没有更聪明的办法吗？"}</script><link rel="alternative" href="/atom.xml" title="S-Virus" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.12/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/css/style.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="http://myblog.sharemer.com/logooo.png" alt="S-Virus" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/categories/%E6%97%A5%E5%B8%B8/">日常</a><a class="navbar-item" href="/course">教程</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/timeline">时间轴</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/exceting"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2020-03-10  <a class="commentCountImg" href="/2020/03/10/LV2-4%EF%BC%9A%E7%B1%BB%E7%9A%84%E7%89%B9%E6%80%A7%E3%80%81%E5%85%B3%E7%B3%BB/#comment-container"><span class="display-none-class">b45f407d8078e5ad1221352fe16e44df</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="b45f407d8078e5ad1221352fe16e44df">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>1 小时  <i class="fas fa-pencil-alt"> </i>9.7k</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">LV2-4：类的特性、关系</h1><div class="content"><h2 id="一、继承和多态"><a href="#一、继承和多态" class="headerlink" title="一、继承和多态"></a>一、继承和多态</h2><h3 id="1-1：一个例子"><a href="#1-1：一个例子" class="headerlink" title="1.1：一个例子"></a>1.1：一个例子</h3><p>参考之前的Cat类，如果我现在让你设计一个Dog类，它仍然具备眼睛、性别等属性，也会跑、吃等动作，这个时候你一定会发现，单独再为Dog搞一套跟Cat差不多的类定义吗？就没有更聪明的办法吗？</p>
<a id="more"></a>

<p>此时java里允许的类继承就可以起到作用了，想想我们的目标，我们的目标是让这些重复的属性不再重复定义一遍，那么像眼睛、毛色这种属性，或者跑、吃饭这类的操作就可以再拆出一个类：动物类</p>
<p>现在我们来定义下动物类：</p>
<figure class="highlight java"><figcaption><span>代码块1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"xx"</span>; <span class="comment">//动物学名，动物们都有学名，这里默认为xx，因为动物类是用来描述动物的，动物有学名，但你并不知道是那种动物，name只能未知</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age; <span class="comment">//动物们的年龄</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123; <span class="comment">//控制叫声的方法</span></span><br><span class="line">        System.out.println(<span class="string">"叫声为：未知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; <span class="comment">//负责吃饭的方法</span></span><br><span class="line">        System.out.println(name + <span class="string">"正在吃东西"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//用来给name赋值的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用来给age赋值的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再定义一下Cat和Dog类：</p>
<figure class="highlight java"><figcaption><span>代码块2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; <span class="comment">//让Cat类继承Animal类</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><figcaption><span>代码块3</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; <span class="comment">//让Dog类继承Animal类</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cat和Dog都是一个”空“类，但是分别利用extends关键词继承了Animal类，现在让我们进行如下测试：</p>
<figure class="highlight java"><figcaption><span>代码块4</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//造一只9岁的猫</span></span><br><span class="line">    Cat cat = <span class="keyword">new</span> Cat();</span><br><span class="line">    cat.setAge(<span class="number">9</span>);</span><br><span class="line">    cat.setName(<span class="string">"猫"</span>);</span><br><span class="line">    <span class="comment">//让这只猫叫一声，再吃一口东西</span></span><br><span class="line">    cat.cry();</span><br><span class="line">    cat.eat();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//造一只10岁的狗</span></span><br><span class="line">    Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">    dog.setAge(<span class="number">10</span>);</span><br><span class="line">    dog.setName(<span class="string">"狗"</span>);</span><br><span class="line">    <span class="comment">//让这只狗叫一声，再吃一口东西</span></span><br><span class="line">    dog.cry();</span><br><span class="line">    dog.eat();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//造一只10岁的狗，但不设置学名</span></span><br><span class="line">    Dog dog2 = <span class="keyword">new</span> Dog();</span><br><span class="line">    dog2.setAge(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//让这只狗叫一声，再吃一口东西</span></span><br><span class="line">    dog2.cry();</span><br><span class="line">    dog2.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序输出结果如下：</p>
<figure class="highlight bash"><figcaption><span>代码块5</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">叫声为：未知</span><br><span class="line">猫正在吃东西</span><br><span class="line">叫声为：未知</span><br><span class="line">狗正在吃东西</span><br><span class="line">叫声为：未知</span><br><span class="line">xx正在吃东西</span><br></pre></td></tr></table></figure>

<p>可以看到，Cat和Dog虽然啥都没定义，但仍然可以使用Animal类里的方法，我们此时管Cat和Dog叫做Animal的子类，相反的Animal叫做Cat和Dog的父类。</p>
<p>可以通过这个例子发现，子类通过继承，可以得到父类的一些功能，需要确认的一个点是：在初始化完成一个子类初始化的同时其父类信息也会自动加载进子类，然后子类可以共享父类里的方法和属性。</p>
<p>这里说一下<code>this</code>关键词，它表示的是本类所产生的具体对象对其内部内容做访问时用的一个标识，你甚至可以省略不写。</p>
<h3 id="1-2：父类方法覆盖"><a href="#1-2：父类方法覆盖" class="headerlink" title="1.2：父类方法覆盖"></a>1.2：父类方法覆盖</h3><p>通过上面的输出，我们发现，猫狗的cry方法输出的是Animal默认的内容，这时我们需要猫和狗能有自己的叫声，那么这时就可以选择重写父类的方法：</p>
<p>Cat类重写父类的<code>cry</code>方法：</p>
<figure class="highlight java"><figcaption><span>代码块6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span>  <span class="comment">//加上@Override标识为方法重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"喵喵喵~"</span>); <span class="comment">//这里重新定义方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dog类重写父类cry方法：</p>
<figure class="highlight java"><figcaption><span>代码块7</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"汪汪汪~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在再运行下测试代码输出如下：</p>
<figure class="highlight bash"><figcaption><span>代码块8</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">喵喵喵~</span><br><span class="line">猫正在吃东西</span><br><span class="line">汪汪汪~</span><br><span class="line">狗正在吃东西</span><br></pre></td></tr></table></figure>

<p>通过这个例子，我们可以知道，如果子类不想要父类里的实现，那么可以通过重写的方式重新设计对应的方法，例子中通过重写<code>cry</code>方法，让Cat和Dog都拥有了自己的<code>cry</code>方法。</p>
<h3 id="1-3：子类方法扩展"><a href="#1-3：子类方法扩展" class="headerlink" title="1.3：子类方法扩展"></a>1.3：子类方法扩展</h3><p>经过上面一步，我们知道猫和狗都是动物，所以它们离不开动物类里定义的属性和方法，但是猫和狗仍存在一些不太一样的地方，比如猫具有捕鼠的能力，但不具备看家的能力，而狗具有看家能力，却没有捕鼠的能力，这种相对比较独立的能力就可以用来扩展：</p>
<p>Cat类新增捕鼠方法</p>
<figure class="highlight java"><figcaption><span>代码块9</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span>  <span class="comment">//加上@Override标识为方法重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"喵喵喵~"</span>); <span class="comment">//这里重新定义方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catchMice</span><span class="params">()</span> </span>&#123; <span class="comment">//扩展方法：捕鼠</span></span><br><span class="line">        System.out.println(<span class="string">"我会捉老鼠"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dog类新增看家方法：</p>
<figure class="highlight java"><figcaption><span>代码块10</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"汪汪汪~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">houseKeeping</span><span class="params">()</span> </span>&#123; <span class="comment">//扩展方法：看家</span></span><br><span class="line">        System.out.println(<span class="string">"我会看家"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过本例我们知道，子类是可以自由扩展的，通过子类的引用变量依然可以完成调用：</p>
<figure class="highlight java"><figcaption><span>代码块11</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    Cat cat = <span class="keyword">new</span> Cat();</span><br><span class="line">    cat.catchMice();</span><br><span class="line">     </span><br><span class="line">    Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">    dog.houseKeeping();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><figcaption><span>代码块12</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我会捉老鼠</span><br><span class="line">我会看家</span><br></pre></td></tr></table></figure>

<h3 id="1-4：多态"><a href="#1-4：多态" class="headerlink" title="1.4：多态"></a>1.4：多态</h3><p>现在来介绍下多态，多态是一种类和类之间的一种引用关系，因为有了继承，才有了多态这种特性，我们现在来改造下<code>代码块4</code>：</p>
<figure class="highlight java"><figcaption><span>代码块13</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Animal cat = <span class="keyword">new</span> Cat(); <span class="comment">//声明变量时，改成父类类型</span></span><br><span class="line">    cat.setAge(<span class="number">9</span>);</span><br><span class="line">    cat.setName(<span class="string">"猫"</span>);</span><br><span class="line">     </span><br><span class="line">    cat.cry();</span><br><span class="line">    cat.eat();</span><br><span class="line">     </span><br><span class="line">    Animal dog = <span class="keyword">new</span> Dog(); <span class="comment">//声明变量时，改成父类类型</span></span><br><span class="line">    dog.setAge(<span class="number">10</span>);</span><br><span class="line">    dog.setName(<span class="string">"狗"</span>);</span><br><span class="line">     </span><br><span class="line">    dog.cry();</span><br><span class="line">    dog.eat();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行如下：</p>
<figure class="highlight bash"><figcaption><span>代码块14</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">喵喵喵~</span><br><span class="line">猫正在吃东西</span><br><span class="line">汪汪汪~</span><br><span class="line">狗正在吃东西</span><br></pre></td></tr></table></figure>

<p>仍然可以正常运行，并且被重写的方法<code>cry</code>仍然执行的是子类里的那个。</p>
<p>这就是多态，如果不太好理解，我们可以通过下图来加深一下记忆：</p>
<p><img src="http://myblog.sharemer.com/2020/03/10/20200310-2-1.png?imageView2/0/w/1024" alt="图1" title="图1"></p>
<p>这种使用父类修饰的引用变量，可以指向其任意子类对象的行为，我们称为类的多态，可以发现父类接收的子类对象无法访问扩展内容，但仍然可以访问父类所具备的内容，哪怕被重写的方法cry，但这时由于父类指向的还是子类对象，因此所触发的内容均属于子类，这里先不探讨多态的好处，你只需要加深对<code>代码块13</code>和<code>图1</code>的理解类的这种特性即可。</p>
<article class="message is-danger"><div class="message-body">
<p>❓ 疑问点1：为什么通过Animal的引用变量指向的Cat对象，无法调用其catchMice方法？为什么cry方法可以调用触发的却是Cat里的cry方法？</p>
</div></article>

<h3 id="1-5：如何直接访问父类的内容？"><a href="#1-5：如何直接访问父类的内容？" class="headerlink" title="1.5：如何直接访问父类的内容？"></a>1.5：如何直接访问父类的内容？</h3><h4 id="1-5-1：直接new"><a href="#1-5-1：直接new" class="headerlink" title="1.5.1：直接new"></a>1.5.1：直接new</h4><p>父类也是一个普通的类嘛，要想不受子类的任何影响，直接<code>new</code>不就完事儿了。但一般父类都不太可能直接new，在多子类的情况下，又该怎样直接访问自己的资源呢？来接着往下看<code>1.5.2</code>吧。</p>
<h4 id="1-5-2：super关键词"><a href="#1-5-2：super关键词" class="headerlink" title="1.5.2：super关键词"></a>1.5.2：super关键词</h4><p>通过上面的介绍，我们了解了类的继承和多态，子类在继承了父类的功能和属性之后，可以自定义方法实现对父类的扩展，针对实现不合子类要求的方法，子类也可以通过方法重写来覆盖原父类方法，然后就是多态，多态简单来说就是通过一个父类引用变量直接指向一个子类对象，还是结合图1理解。</p>
<p>那么我们现在再来做一个实验，现在我想让Cat和Dog在吃饭的时候自带叫声，现在我们来继续改造下这些类：</p>
<p>首先把Animal里的eat方法改造下，让它的逻辑执行之前，先调用下cry方法：</p>
<figure class="highlight java"><figcaption><span>代码块15</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"xx"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"叫声为：未知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cry(); <span class="comment">//吃饭之前先叫两嗓子</span></span><br><span class="line">        System.out.println(name + <span class="string">"正在吃东西"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>别的代码不动，单独测试下eat方法：</p>
<figure class="highlight java"><figcaption><span>代码块16</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Animal cat = <span class="keyword">new</span> Cat();</span><br><span class="line">    cat.eat();</span><br><span class="line"> </span><br><span class="line">    Animal dog = <span class="keyword">new</span> Dog();</span><br><span class="line">    dog.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终输出：</p>
<figure class="highlight bash"><figcaption><span>代码块17</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">喵喵喵~</span><br><span class="line">xx正在吃东西</span><br><span class="line">汪汪汪~</span><br><span class="line">xx正在吃东西</span><br></pre></td></tr></table></figure>

<p>这里说一下，即便代码块16直接用Cat和Dog接收对应的类对象，结果都是一致的。</p>
<blockquote>
<p>🦩 结论：new出来具体的子类之后，父类里即便使用this调用它内部的被子类重写的方法，实际触发的仍然是子类的方法。</p>
</blockquote>
<article class="message is-danger"><div class="message-body">
<p>❓ 疑问点2：为什么呢？我明明是在Animal对象里调用的this.cry，为什么执行的却是子类的？</p>
</div></article>

<p>ok，那我们怎么直接访问父类里的方法呢？借助<code>super关键词</code>即可，同this关键词一样用来描述类对象内部引用的，与this不同的是，子类利用super可以调用父类资源，注意，这里说了，想用super，就得在某子类内，我们现在如果想调用Animal本身的cry方法，那么就需要在Cat或Dog里，通过super触发：</p>
<p>首先把Animal里面的eat方法还原：</p>
<figure class="highlight java"><figcaption><span>代码块18</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    ...省略...</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; <span class="comment">//负责吃饭的方法</span></span><br><span class="line">        System.out.println(name + <span class="string">"正在吃东西"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    ...省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后改造下Cat类，让它重写eat方法，我们目标是让这个eat方法先调用一遍父类原始的cry方法，再调用一次父类原始的eat方法：</p>
<figure class="highlight java"><figcaption><span>代码块19</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    ...省略...</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; <span class="comment">//这里重写eat，同时使用super直接调用父类的cry和eat方法</span></span><br><span class="line">        <span class="keyword">super</span>.cry();</span><br><span class="line">        <span class="keyword">super</span>.eat();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ...省略...</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在再次调用eat方法，输出结果如下：</p>
<figure class="highlight bash"><figcaption><span>代码块20</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">叫声为：未知</span><br><span class="line">xx正在吃东西</span><br></pre></td></tr></table></figure>

<p>你会发现，现在的调用就是父类里面原生的方法。</p>
<p>现在，让我们把<code>代码块19</code>里的cry的super关键词去掉（之前说过，去掉相当于使用<code>this</code>关键词调用）：</p>
<figure class="highlight java"><figcaption><span>代码块21</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    ...省略...</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cry(); <span class="comment">//这里把super去掉</span></span><br><span class="line">        <span class="keyword">super</span>.eat(); <span class="comment">//等看完这一块的内容之后，结合Cat类的代码，分析一下这里eat的super关键词去掉会发生什么？</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ...省略...</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用eat的结果如下：</p>
<figure class="highlight bash"><figcaption><span>代码块22</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">喵喵喵~</span><br><span class="line">xx正在吃东西</span><br></pre></td></tr></table></figure>

<p>可见，Cat里使用this调用cry方法，当然是调用的它自己的咯。</p>
<article class="message is-danger"><div class="message-body">
<p>❓ 疑问点3：为什么父类的被子类重写过的方法可怜到只能通过子类的super关键词才能触发？为什么父类里也有的方法要优先执行子类里重写后的？不管在父类还是子类，用this关键词调用的资源都是优先以子类为准吗？找不到的资源才去考虑找父类吗？</p>
</div></article>

<h3 id="1-6：继承链"><a href="#1-6：继承链" class="headerlink" title="1.6：继承链"></a>1.6：继承链</h3><p>首先请记住现在的Animal类：</p>
<figure class="highlight java"><figcaption><span>代码块23</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"xx"</span>; <span class="comment">//动物学名，动物们都有学名，这里默认为xx，因为动物类是用来描述动物的，动物有学名，但你并不知道是那种动物，name只能未知</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age; <span class="comment">//动物们的年龄</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123; <span class="comment">//控制叫声的方法</span></span><br><span class="line">        System.out.println(<span class="string">"叫声为：未知"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; <span class="comment">//负责吃饭的方法</span></span><br><span class="line">        System.out.println(name + <span class="string">"正在吃东西"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//用来给name赋值的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//用来给age赋值的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cat类清理一下之前的测试代码，记住现在的Cat类：</p>
<figure class="highlight java"><figcaption><span>代码块24</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span>  <span class="comment">//加上@Override标识为方法重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"喵喵喵~"</span>); <span class="comment">//这里重新定义方法的实现</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catchMice</span><span class="params">()</span> </span>&#123; <span class="comment">//扩展方法：捕鼠</span></span><br><span class="line">        System.out.println(<span class="string">"我会捉老鼠"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java语法里，只允许一个类继承一个类，也就是说，extends关键词只能在一个类定义里出现一次，根据这个规则，父类也是一个类，类允许继承一个别的类（套娃警告），描述起来是越来越乱，不如再改造下前面的例子来说明问题；现在我们发现Cat也只是定义了猫的基本概念，包括被它重写后的cry，确实，猫都是喵喵喵的叫，猫都会捕鼠，但是不同品种的猫，也存在差异，例如相比其它猫，橘猫的食量惊人，它还可以扮猪，如果这时定义一个橘猫类，首先它也是猫，那就让它继承Cat类，那么eat这个方法就可以单独拎出来再被重写一次，以显示橘猫特有的食量，其次应该单独加一个橘猫特有技能：扮猪，看代码：</p>
<figure class="highlight java"><figcaption><span>代码块25</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrangeCat</span> <span class="keyword">extends</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; <span class="comment">//重写eat方法</span></span><br><span class="line">        System.out.println(<span class="string">"我寻思你不能因为我吃的多就专门为我量身定做一个eat方法吧？。。。。。。艾玛真香~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//假装自己是头猪</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playAPig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我说我是🐷，你能怎么办？（🤪）"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ok，至少通过橘猫类，我们知道了，java虽然不允许一个类继承多个类，但可以间接继承多个类，现在的继承链为：</p>
<p><img src="http://myblog.sharemer.com/2020/03/10/20200310-2-2.png?imageView2/0/w/800" alt="图2" title="图2"></p>
<p>那么一样的，我们前面了解了java的继承和多态，这种继承链也是符合上述所有的继承相关的特性，比如我们来利用OrangeCat做个试验：</p>
<figure class="highlight java"><figcaption><span>代码块26</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//继承链仍符合多态规则，看下方的代码，我用Animal和Cat都可以接收OrangeCat对象，因为它们俩都是OrangeCat的父类</span></span><br><span class="line">    Animal orangeCat1 = <span class="keyword">new</span> OrangeCat();</span><br><span class="line">    Cat orangeCat2 = <span class="keyword">new</span> OrangeCat();</span><br><span class="line">    OrangeCat orangeCat3 = <span class="keyword">new</span> OrangeCat();</span><br><span class="line"> </span><br><span class="line">    orangeCat1.cry();</span><br><span class="line">    orangeCat1.eat();</span><br><span class="line"> </span><br><span class="line">    orangeCat2.cry();</span><br><span class="line">    orangeCat2.eat();</span><br><span class="line"> </span><br><span class="line">    orangeCat3.cry();</span><br><span class="line">    orangeCat3.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight bash"><figcaption><span>代码块27</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">喵喵喵~</span><br><span class="line">我寻思你不能因为我吃的多就专门为我量身定做一个eat方法吧？。。。。。。艾玛真香~</span><br><span class="line">喵喵喵~</span><br><span class="line">我寻思你不能因为我吃的多就专门为我量身定做一个eat方法吧？。。。。。。艾玛真香~</span><br><span class="line">喵喵喵~</span><br><span class="line">我寻思你不能因为我吃的多就专门为我量身定做一个eat方法吧？。。。。。。艾玛真香~</span><br></pre></td></tr></table></figure>

<p>可以看到，不管用谁去接收OrangeCat对象，最终输出结果都是正确的，首先OrangeCat没有重写cry方法，因此触发的是父类Cat里的cry方法，又因为自己重写了eat对象，所以eat调用时就直接触发了自己的eat方法。</p>
<p>同样的，playAPig方法属于OrangeCat自定义的扩展方法，它只能由OrangeCat类型的引用变量触发，因此<code>代码块26</code>里，只有orangeCat3可以调用这个方法，由于OrangeCat继承了Cat，所以它也会捕鼠（catchMice）了。</p>
<p>我们再来看看OrangeCat具备了哪些能力：</p>
<figure class="highlight java"><figcaption><span>代码块28</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    OrangeCat orangeCat3 = <span class="keyword">new</span> OrangeCat();</span><br><span class="line">    orangeCat3.setAge(<span class="number">9</span>); <span class="comment">//其直系父类Cat继承了Animal，因此它也可以调用Animal的setAge方法</span></span><br><span class="line">    orangeCat3.setName(<span class="string">"橘猫"</span>); <span class="comment">//同上</span></span><br><span class="line">    orangeCat3.cry(); <span class="comment">//其直系父类Cat有cry方法（虽然是重写Animal的cry来的），因此这里触发的是Cat里那个cry方法</span></span><br><span class="line">    orangeCat3.eat(); <span class="comment">//因为自己有eat方法，因此这里触发的是自己的eat方法</span></span><br><span class="line">    orangeCat3.catchMice(); <span class="comment">//其直系父类Cat有catchMice方法，因此这里触发的是Cat里那个catchMice方法</span></span><br><span class="line">    orangeCat3.playAPig(); <span class="comment">//这是OrangeCat特有的方法，自然可以调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到了吗，经过一层层的继承，OrangeCat拥有的技能要比俩父类加起来还多，这是因为继承的特性，就是父类所有的东西都是可以给子类的（当然能不能访问就是另一回事了，下面会说访问权限相关的内容），而子类又可以重写父类的方法，如果不重写，则按照就近原则触发对应的方法，比如例子里虽然OrangeCat没有重写cry方法，但它调用cry的输出结果却是Cat类里的那个，因此，在重写方法调用上，一般遵循就近原则，此外子类也可以扩展自己的内容，比如Cat相比Animal，可以捕鼠，再比如OrangeCat相比Cat和Animal，可以扮猪。</p>
<h3 id="1-7：巩固继承-amp-多态"><a href="#1-7：巩固继承-amp-多态" class="headerlink" title="1.7：巩固继承&amp;多态"></a>1.7：巩固继承&amp;多态</h3><p>前面讲了那么多，现在我们通过画图的方式，系统的解释一遍<code>继承</code>和<code>多态</code>。</p>
<h4 id="1-7-1：继承关系下，重复方法的就近调用规则"><a href="#1-7-1：继承关系下，重复方法的就近调用规则" class="headerlink" title="1.7.1：继承关系下，重复方法的就近调用规则"></a>1.7.1：继承关系下，重复方法的就近调用规则</h4><p>先看下我们在前面留下的3个问题：</p>
<article class="message is-danger"><div class="message-body">

<p>❓ 疑问点1：为什么通过Animal的引用变量指向的Cat对象，无法调用其catchMice方法？为什么cry方法可以调用触发的却是Cat里的cry方法？</p>
<p>❓ 疑问点2：为什么呢？我明明是在Animal对象里调用的this.cry，为什么执行的却是子类的？</p>
<p>❓ 疑问点3：为什么父类的被子类重写过的方法可怜到只能通过子类的super关键词才能触发？为什么父类里也有的方法要优先执行子类里重写后的？不管在父类还是子类，用this关键词调用的资源都是优先以子类为准吗？找不到的资源才去考虑找父类吗？</p>
</div></article>

<p>先不用急着看问题，我们先来分析下一个类方法或属性在调用时，都经历了些什么。</p>
<p>在<code>LV2-1</code>的时候，我们就知道了，对象实际上就是一个整体，被保存在了内存里，然后通过一个引用变量来指向它，然后就可以利用这个引用变量来操纵它了，现在我们来看下，正常没有继承任何类的类，是如何访问方法的：</p>
<blockquote>
<p>🦜 这里说明一下，下面的流程图只是为了便于让大家理解并记住java继承关系下的访问规则，真实的java对象在内存里并不长这样（虽然确实包含属性值），方法的调用在java底层也很复杂，这些都要对jvm有深入了解才行。</p>
</blockquote>
<p><img src="http://myblog.sharemer.com/2020/03/10/20200310-2-3.png?imageView2/0/w/850" alt="图3" title="图3"></p>
<p>如果一个类没有任何父类，那么它的方法调用就很纯粹，没有任何悬念，现在让我们的看看Cat类：</p>
<p><img src="http://myblog.sharemer.com/2020/03/10/20200310-2-4.png?imageView2/0/w/1000" alt="图4" title="图4"></p>
<p>让我们再来看看更复杂的橘猫：</p>
<p><img src="http://myblog.sharemer.com/2020/03/10/20200310-2-5.png?imageView2/0/w/1000" alt="图5" title="图5"></p>
<p>我们仍然可以找到一些规则，来说明在继承里方法的调用和最终触发哪个方法的问题。</p>
<p>好的，截止目前，集合<code>图4</code>和<code>图5</code>，我们解决了<code>疑问点2</code>和<code>疑问点3</code>，通过<code>图4</code>，我们知道了this关键词取决于当前的对象究竟属于哪个类，仍然符合就近调用规则，例如Animal里面使用this.cry调用cry，如果当前对象是Animal自己，那么毫无疑问，最终触发的会是它自己的cry方法，但如果当前对象是Cat，那么this调用cry时就遵循就近规则，优先触发自己所属类（也就是Cat类）里的cry方法。</p>
<p><code>图4</code>告诉我们，<code>super</code>关键字在子类里可用来直接调用其父类里的方法：</p>
<p><img src="http://myblog.sharemer.com/2020/03/10/20200310-2-6.png?imageView2/0/w/550" alt="图6" title="图6"></p>
<p>这个可以解答<code>疑问点3</code>.</p>
<p>现在让我们解答下<code>疑问点1</code>，为什么父类引用变量可以接收子类对象？</p>
<p>还记得讲基本类型时，存在大类型和小类型吗？大类型可以自动接收小类型，而小类型想要变成大类型就得强转，类同样拥有类似的规则，比如你可以把父类理解成比较大的类，子类是比较小的类，那么父类当然可以自动接收子类咯，只不过类有不一样的地方，一个子类被父类接收以后，访问域就受父类限制了：</p>
<p><img src="http://myblog.sharemer.com/2020/03/10/20200310-2-7.png?imageView2/0/w/1000" alt="图7" title="图7"></p>
<p>既然规则跟基本类型差不多，当然也有类型强转啦：</p>
<figure class="highlight java"><figcaption><span>代码块29</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal cat = <span class="keyword">new</span> Cat();</span><br><span class="line">Cat cat2 = (Cat)cat;</span><br></pre></td></tr></table></figure>

<p>看吧，连写法都跟基本类型的强转一样，括号里加上要转的目标类型即可。</p>
<p>但是需要注意的是，别瞎转，比如你知道这个Animal的确是一个Cat，然后像<code>代码块29</code>里那样转成Cat类型即可，但如果对象并不是Cat，那样强转语法里是允许的，但是运行时会报类型转换错误，比如下面这样：</p>
<figure class="highlight java"><figcaption><span>代码块30</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal dog = <span class="keyword">new</span> Dog();</span><br><span class="line">Cat cat = (Cat)dog;</span><br></pre></td></tr></table></figure>

<p>上面的代码在语法里不会有问题，但实际上运行时便会报错，即类型转换错误。</p>
<p>到目前为止，有关<code>问题1、2、3</code>都说完了，继承和多态这一块确实很复杂，最好能结合本节流程图记下来这个规则，以后做分析时就不会乱了。</p>
<h4 id="1-7-2：属性在继承关系下的访问规则"><a href="#1-7-2：属性在继承关系下的访问规则" class="headerlink" title="1.7.2：属性在继承关系下的访问规则"></a>1.7.2：属性在继承关系下的访问规则</h4><p>上面只是说了方法的调用规则，却没有说属性，我们来做个试验：</p>
<p>现在让Cat类里也有一个叫age的属性：</p>
<figure class="highlight java"><figcaption><span>代码块31</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">12</span>; <span class="comment">//新增一个跟父类一样的属性，初始值为12</span></span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.age); <span class="comment">//通过this关键词访问age</span></span><br><span class="line">        System.out.println(<span class="keyword">super</span>.age); <span class="comment">//通过super关键词访问父类里的age</span></span><br><span class="line">        System.out.println(<span class="string">"喵喵喵~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catchMice</span><span class="params">()</span> </span>&#123; <span class="comment">//扩展方法：捕鼠</span></span><br><span class="line">        System.out.println(<span class="string">"我会捉老鼠"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后让父类里的age访问权限变成public（详细看下方<code>1.8</code>，这里改成public的目的是为了让Cat可以直接访问这个属性），然后让其初始值为15，并且在其eat方法里使用this关键词访问age：</p>
<figure class="highlight java"><figcaption><span>代码块32</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    ...省略...</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">15</span>; <span class="comment">//动物们的年龄，初始值为15</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.age); <span class="comment">//输出age</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">"正在吃东西"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    ...省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在让我们来测试下：</p>
<figure class="highlight java"><figcaption><span>代码块33</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Animal cat = <span class="keyword">new</span> Cat();</span><br><span class="line">    cat.cry();</span><br><span class="line">    cat.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight bash"><figcaption><span>代码块34</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">15</span><br><span class="line">喵喵喵~</span><br><span class="line">15</span><br><span class="line">xx正在吃东西</span><br></pre></td></tr></table></figure>

<blockquote>
<p>🎑 结论：由运行结果我们可以知道，与方法的重写不同，类的属性本身该属于哪个类还是属于哪个类，记住这个规则。</p>
</blockquote>
<p>好了，上面的这个试验有画蛇添足的嫌疑，因为age父类里就有，为什么Cat里还要加上一个同名的age呢？是的，真实设计类的时候没人会这样设计的，我们需要明确一个点，方法是行为，方法在继承关系里允许各种重写，但是属性作为一种没有任何行为方式的东西，你重复定义它的意义大吗？显然是不大的，而且极易跟父类混淆，所以我们说子类可以重写父类的方法，继承关系里，方法调用符合以对象所属类为参照就近调用的规则，子类还可以自己拓展父类里没有的方法，子类的对象还可以被父类引用变量接收，只是这样会影响子类对象的访问域（<code>图7</code>），子类还可以拓展父类里没有的属性，但不建议子类覆盖父类的属性，这种覆盖是没有意义的，通过上面的例子我们也发现了，同名属性在类继承链里是相互隔离的。</p>
<h3 id="1-8：访问权限"><a href="#1-8：访问权限" class="headerlink" title="1.8：访问权限"></a>1.8：访问权限</h3><p>通过<code>1.7</code>，你应该知道了某种类与父类访问规则，但是我们在<a href="https://info.bilibili.co/pages/viewpage.action?pageId=90133656#LV2-2：包的定义、类的基本组成、访问权限修饰符-三、访问权限修饰符">LV2-2的访问权限符</a>的介绍里，介绍了访问权限修饰符以及被它们修饰了的资源的访问权限，也就是说理想状态下1.7的流程图都是成立的，但是你有没有发现，这些方法的权限修饰符都是<code>public</code>的？是的，public表示资源公开，比如Animal类里的age和name两个属性都是<code>private</code>类型的，子类可以通过<code>super</code>直接访问这俩属性吗？显然是不行的，必须得通过public的setName和setAge俩方法完成对name和age的赋值，这就是访问权限符的意义了，至于怎么区分能不能访问呢？我们再把那张表里有关修饰符访问等级的表贴来：</p>
<p><img src="http://myblog.sharemer.com/2020/03/05/20200305-1-3.png?imageView2/0/w/800" alt="表1" title="表1"></p>
<p>只需要记住，如果俩类为继承关系，则<code>protected</code>关键词无视包目录，均可访问，其余规则全部跟普通类一样，由于之前讲过权限修饰符，因此这里不再做详细介绍。</p>
<h3 id="1-9：继承和多态的好处"><a href="#1-9：继承和多态的好处" class="headerlink" title="1.9：继承和多态的好处"></a>1.9：继承和多态的好处</h3><p>通过前面对继承和多态的了解，我们大体上对这俩特性有了一个认识，首先继承是为了解决什么问题的？</p>
<p>回归到我们的例子上，Animal里定义了符合动物特性一些行为和属性，Cat是一种动物，符合Animal定义的行为和属性，它们俩建立起父子关系后，Cat就可以直接使用父类里定义的属性和方法了，这样像eat这种方法，Cat和Dog都不需要自己定义了，这样会让我们的代码看起来很简洁，而且同样的代码逻辑块，不需要重复定义多次，有需要可以重写，子类还可以自定义自己的行为方法。</p>
<p>多态呢？它有什么好处？</p>
<p>多态就是指使用一个父类引用变量，可以接收子类对象并允许触发它内部的方法，参见<code>图1</code>，那么这样的一种特性的好处究竟是什么呢？我们本节先不会涉及，之后讲<code>JDBC</code>时可以提一嘴，现在你要做的是，牢记java的这种机制。</p>
<h3 id="1-10：抽象类"><a href="#1-10：抽象类" class="headerlink" title="1.10：抽象类"></a>1.10：抽象类</h3><p>了解完了<code>继承</code>和<code>多态</code>，我们再来了解一种特殊的类：<code>抽象类</code></p>
<p>什么是抽象类？让我们来改造下Animal方法，不知道你有没有发现，由Animal<code>派生</code>出来的子类Cat和Dog都重写了cry方法，说明大部分时候，Animal里的cry方法都不会主动生效，因为意义不大，这时我们认为cry方法在绝大多数情况下都是需要被重写的，像这种方法，我们就可以把它定义成一个抽象方法，包含抽象方法的类被称作抽象类，普通的类是不能有抽象方法的，因此想要cry变成抽象方法，首先要把Animal变成抽象类：</p>
<figure class="highlight java"><figcaption><span>代码块35</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用abstract修饰的class，被称为抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"xx"</span>; <span class="comment">//动物学名，动物们都有学名，这里默认为xx，因为动物类是用来描述动物的，动物有学名，但你并不知道是那种动物，name只能未知</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">15</span>; <span class="comment">//动物们的年龄</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//被abstract修饰的方法被称为抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">()</span></span>; <span class="comment">//动物会叫，但每个动物的叫声都完全不一样，有的甚至不会叫，那"叫"就应该是一个标准，作为动物的标准，动物本身只要定义好这个标准就好了，其余交给具体的动物（子类）去实现</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; <span class="comment">//负责进食的方法</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">"正在进食"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，抽象方法没有任何实现，所以称它为一个标准，所有直系子类都必须实现这个标准，这时Cat类继承了Animal类，如果不实现cry方法，语法上就会报错：</p>
<p><img src="http://myblog.sharemer.com/2020/03/10/20200310-2-8.png?imageView2/0/w/900" alt="图8" title="图8"></p>
<p>现在我们只能让Cat类实现这个抽象方法：</p>
<p><img src="http://myblog.sharemer.com/2020/03/10/20200310-2-9.png?imageView2/0/w/900" alt="图9" title="图9"></p>
<p>这就相当于强制让子类去重写cry方法，事实上确实需要每个动物都实现自己的cry方法，但是像eat这种方法就没有必要这样做，因为大部分动物都需要进食且都是用嘴进食的，大同小异，如果真的存在不一样的吃东西的方法，那么就跟之前一样重写就好了，但大部分动物都不需要重写eat方法，父类Animal里的已经够用了，这是在告诉你什么时候需要搞抽象方法，什么时候不需要。</p>
<p>现在你知道了，有的方法需要被抽象，那就定义抽象方法，因为存在抽象方法，所以类必须被声明为抽象类（<code>abstract</code>关键词）。</p>
<p>抽象类的特点：</p>
<ol>
<li>抽象类不能被实例化（也就是说不可以利用<code>new</code>关键词实例化一个抽象类）</li>
<li>由于1的特性，我们认为，抽象类是为继承而生的，如果你定义了一个抽象类，而它没有任何子类，那么这个抽象类就没有任何意义</li>
<li>抽象类不一定有抽象方法，但有抽象方法的类一定是抽象类</li>
<li>抽象类可以继承抽象类，当继承了抽象类时，子类抽象类也可以不实现其父类的抽象方法，全部交给非抽象的子类去做</li>
<li>抽象类也可以继承普通类，也可以选择重写普通类的方法，更神奇的是，它还可以让通过重写，让普通类的方法变成一个抽象方法</li>
<li>抽象类虽然不可以被实例化，但是它仍然存在构造器（这是句废话，抽象类是天生的父类，父类构造器在子类被实例化的时候会自动调用一次，所以作为天生的父类，它必有构造器）</li>
</ol>
<article class="message is-warning"><div class="message-body">

<p>🌵 <strong>思考：</strong></p>
<p>现在Animal定义如下：</p>
<p><img src="http://myblog.sharemer.com/2020/03/10/20200310-2-10.png?imageView2/0/w/500" alt="Animal定义" title="Animal定义"></p>
<p>Cat类是它的子类，定义如下：</p>
<p><img src="http://myblog.sharemer.com/2020/03/10/20200310-2-11.png?imageView2/0/w/500" alt="Cat定义" title="Cat定义"></p>
<p>结合前面对继承和多态以及本部分对抽象类的理解，请问如下测试代码输出结果是什么？</p>
<p><img src="http://myblog.sharemer.com/2020/03/10/20200310-2-12.png?imageView2/0/w/500" alt="这段代码的结果是什么呢？" title="这段代码的结果是什么呢？"></p>
</div></article>

<h3 id="1-11：万类の父-Object"><a href="#1-11：万类の父-Object" class="headerlink" title="1.11：万类の父-Object"></a>1.11：万类の父-Object</h3><p>不知道你有没有发现，任何对象都自动有这些方法：</p>
<p><img src="http://myblog.sharemer.com/2020/03/10/20200310-2-13.png?imageView2/0/w/600" alt="图10" title="图10"></p>
<p>这是因为类被定义出来，就隐藏继承了一个父类，名叫<code>Object</code>，这是java自带的类，不需要显式的extends出来。</p>
<h2 id="二、封装"><a href="#二、封装" class="headerlink" title="二、封装"></a>二、封装</h2><p>封装充满我们代码，还是以前面的例子为准，我们认为对一类操作使用一个方法定义来圈起来，就是封装，比如eat、cry等方法，例子里面很简单，只打印了一句话，但实际开发中，一个方法可能会完成很复杂的操作，这里拿之前一个例子来说明问题：</p>
<figure class="highlight java"><figcaption><span>代码块36</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> gender;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> color;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(<span class="keyword">int</span> gender, <span class="keyword">int</span> age, <span class="keyword">int</span> color, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cry</span><span class="params">(Cat cat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.tooOld()) &#123; <span class="comment">//通过tooOld来判断当前这只猫是否年龄太大了</span></span><br><span class="line">            System.out.println(<span class="string">"叫不动了..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"喵喵喵~"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"要恰饭的嘛"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">emm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.tooOld()) &#123; <span class="comment">//通过tooOld来判断当前这只猫是否年龄太大了</span></span><br><span class="line">            System.out.println(<span class="string">"骚不动了..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"猪肉卷和千层面不存在二选一，我全都要！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tooOld()) &#123; <span class="comment">//通过tooOld来判断当前这只猫是否年龄太大了</span></span><br><span class="line">            System.out.println(<span class="string">"跑不动了..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (age &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"奔跑速度：10km/h"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"奔跑速度：15km/h"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ...省略...</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//被拆出来的逻辑块，因为这段逻辑会出现在多个方法里，因此单拆出来封装成一个方法，这种方法建议设置成private权限的，因为仅限本类内调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">tooOld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age &gt; <span class="number">15</span>; <span class="comment">//经过本层封装，只要需要这段逻辑的地方，直接调用下这个方法即可，本例太简单，因为只做了age大小判断，实际开发里可以把更复杂的且重复度过高的代码块像这样拆出来，封装成一个方法提供服务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过本例，我们知道了封装的目的是减少代码的重复度，提高复用率，这点是不是跟继承也很像？继承的意义之一也是为了解决代码重复度的。</p>
<p>封装仅仅只是为了解决重复度吗？并不是，通过之前的Animal的例子，我们发现像age、name这种属性的赋值操作也被封装成了一个个方法（setName和setAge），而Animal里的name和age全是private的，这是为什么呢？为什么不让age和name变成protected或public这种权限呢？让别的类直接赋值不是更好？为啥还要多此一举搞俩专门赋值的方法？</p>
<p>这就体现了封装的另外一层意义：<code>隔离</code></p>
<p>现在我们试着将Animal里的age变成public的，来看看下面：</p>
<figure class="highlight java"><figcaption><span>代码块37</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">animal.age = <span class="number">10000</span>; <span class="comment">//由于Animal的age变成public公开了，因此在外界可以随意对其赋值</span></span><br></pre></td></tr></table></figure>

<p>但是Animal这时不干了，你见过能活10000岁的生物吗？？因此Animal把自己的age封了起来，首先把访问权限变成private，然后提供一个setAge方法用来给age赋值，setAge就是Animal对外封装的一个专门给age赋值的方法，这个时候Animal就由之前的被动状态变成主动状态了，如果你不想让别人设置的age太过分，就可以在setAge里做限制，反正是自己的方法嘛，还不是想怎么设计怎么设计，让我们来改一下Animal里setAge的逻辑：</p>
<figure class="highlight java"><figcaption><span>代码块38</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (age &gt; <span class="number">10000</span>) &#123; <span class="comment">//当传入的age超过1w时，输出这句话反问对方</span></span><br><span class="line">        System.out.println(<span class="string">"这种生物你给我找来个康康？"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则的话就给自己的age赋值</span></span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看，这样age的赋值就完全被隔离进本类内了，外界进行赋值时就不敢那么放肆了~</p>
<p><strong>封装的意义：</strong></p>
<ul>
<li>封装的意义在于保护或者防止代码（数据）被我们无意中破坏。</li>
<li>保护成员属性，不让类以外的程序直接访问和修改；</li>
<li>隐藏方法细节</li>
</ul>
<p>这也是为啥我们在定义一个类的时候，属性经常被设置成<code>private</code>访问级别的，然后通过定义赋值方法来让外界给自己的属性赋值。</p>
<p><strong>关于对象封装的原则:</strong></p>
<ul>
<li><code>内聚</code>：内聚是指一个模块内部各个部分之间的关联程度</li>
<li><code>耦合</code>：耦合指各个模块之前的关联程度</li>
<li>封装原则：隐藏对象的属性和实现细节，仅对外公开访问方法，并且控制访问级别</li>
<li>在面向对象方法中，用类来实现上面的要求。用类实现封装，用封装来实现<code>高内聚</code>，<code>低耦合</code>。</li>
</ul>
<p>↑上面的话先读一下，做多了东西自然就懂了，我们做开发时所作的<code>封装</code>、<code>多态</code>等，都是为了这一个目标：<code>高内聚</code>、<code>低耦合</code>来进行的。</p>
</div><div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/2020/04/02/LV5-6%EF%BC%9Ajava%E5%B9%B6%E5%8F%91%E5%8C%85-juc%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/" target="_blank">LV5-6：java并发包-juc的简单介绍</a><br></span><span>  2.<a class="is-size-6" href="/2020/04/02/LV5-5%EF%BC%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%9Ajoin%E3%80%81yield%E3%80%81sleep%E3%80%81interrupt/" target="_blank">LV5-5：线程调度：join、yield、sleep、interrupt</a><br></span><span>  3.<a class="is-size-6" href="/2020/04/01/LV5-4%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%9Await%E3%80%81notify%E3%80%81notifyall/" target="_blank">LV5-4：线程通信：wait、notify、notifyall</a><br></span><span>  4.<a class="is-size-6" href="/2020/04/01/LV5-3%EF%BC%9Ajava%E9%87%8C%E7%9A%84%E5%90%8C%E6%AD%A5%E9%94%81/" target="_blank">LV5-3：java里的同步锁</a><br></span><span>  5.<a class="is-size-6" href="/2020/04/01/LV5-2%EF%BC%9A%E5%B9%B6%E5%8F%91&amp;%E5%B9%B6%E8%A1%8C/" target="_blank">LV5-2：并发&amp;并行</a><br></span><span>  6.<a class="is-size-6" href="/2020/03/31/LV5-1%EF%BC%9A%E8%BF%9B%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E7%BA%BF%E7%A8%8B%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/" target="_blank">LV5-1：进程是什么？线程又是什么？</a><br></span><span>  7.<a class="is-size-6" href="/2020/03/27/LV4-5%EF%BC%9A%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E3%80%81%E5%8D%8F%E8%AE%AE%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E3%80%81%E7%A8%8B%E5%BA%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB/" target="_blank">LV4-5：网络通信、协议、序列化、程序之间的联系</a><br></span><span>  8.<a class="is-size-6" href="/2020/03/25/LV4-4%EF%BC%9A%E4%BD%8D%E5%9B%BE/" target="_blank">LV4-4：位图</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="http://myblog.sharemer.com/alipay_qrcode.png" alt="支付宝"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="http://myblog.sharemer.com/wx_qrcode.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/03/12/LV2-5%EF%BC%9A%E6%8E%A5%E5%8F%A3/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">LV2-5：接口</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/03/10/JAVA%E6%9C%89%E5%85%B3%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%85%A8%E5%A5%97%E6%A2%B3%E7%90%86/"><span class="level-item">JAVA有关位运算的全套梳理</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            id: 'b45f407d8078e5ad1221352fe16e44df',
            repo: 'exceting.github.io',
            owner: 'exceting',
            clientID: '17297b562584b5cec3d7',
            clientSecret: '46c7652ed4f09fb1d847d15df81500a5a2ceeae8',
            admin: ["exceting"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: 'last',
            
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget toc-scroll" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-一、继承和多态" href="#一、继承和多态"><span>一、继承和多态</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-1-1：一个例子" href="#1-1：一个例子"><span>1.1：一个例子</span></a></li><li><a class="is-flex toc-item" id="toc-item-1-2：父类方法覆盖" href="#1-2：父类方法覆盖"><span>1.2：父类方法覆盖</span></a></li><li><a class="is-flex toc-item" id="toc-item-1-3：子类方法扩展" href="#1-3：子类方法扩展"><span>1.3：子类方法扩展</span></a></li><li><a class="is-flex toc-item" id="toc-item-1-4：多态" href="#1-4：多态"><span>1.4：多态</span></a></li><li><a class="is-flex toc-item" id="toc-item-1-5：如何直接访问父类的内容？" href="#1-5：如何直接访问父类的内容？"><span>1.5：如何直接访问父类的内容？</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-1-5-1：直接new" href="#1-5-1：直接new"><span>1.5.1：直接new</span></a></li><li><a class="is-flex toc-item" id="toc-item-1-5-2：super关键词" href="#1-5-2：super关键词"><span>1.5.2：super关键词</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-1-6：继承链" href="#1-6：继承链"><span>1.6：继承链</span></a></li><li><a class="is-flex toc-item" id="toc-item-1-7：巩固继承-amp-多态" href="#1-7：巩固继承-amp-多态"><span>1.7：巩固继承&amp;amp;多态</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-1-7-1：继承关系下，重复方法的就近调用规则" href="#1-7-1：继承关系下，重复方法的就近调用规则"><span>1.7.1：继承关系下，重复方法的就近调用规则</span></a></li><li><a class="is-flex toc-item" id="toc-item-1-7-2：属性在继承关系下的访问规则" href="#1-7-2：属性在继承关系下的访问规则"><span>1.7.2：属性在继承关系下的访问规则</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-1-8：访问权限" href="#1-8：访问权限"><span>1.8：访问权限</span></a></li><li><a class="is-flex toc-item" id="toc-item-1-9：继承和多态的好处" href="#1-9：继承和多态的好处"><span>1.9：继承和多态的好处</span></a></li><li><a class="is-flex toc-item" id="toc-item-1-10：抽象类" href="#1-10：抽象类"><span>1.10：抽象类</span></a></li><li><a class="is-flex toc-item" id="toc-item-1-11：万类の父-Object" href="#1-11：万类の父-Object"><span>1.11：万类の父-Object</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-二、封装" href="#二、封装"><span>二、封装</span></a></li></ul></div></div><script type="text/javascript" async>
        $(document).ready(function () { //参考自 https://github.com/ppoffice/hexo-theme-icarus/pull/616/files
            var observerTopMargin;
            var scrollObserver;
            var headerElems = $(".headerlink");
            var activeTocItem;
        
            function initIntersectionObserver(docHeight) {
                observerTopMargin = docHeight;
                scrollObserver = new IntersectionObserver(scrollCallBack,
                    {
                        root: null,  // viewpoint
                        rootMargin: docHeight + "px 0px -80% 0px"  // cover top 30% of viewport to the top of document
                    })
            }
        
            function scrollCallBack(entries, observer) {
                if ($(window).scrollTop() > observerTopMargin * 0.7) { 
                    // User somehow scroll to 70% of observerTopMargin (which is inited as 200% document height)
                    // Observer top margin need to extend to cover all the space to the top of the document
                    initIntersectionObserver(observerTopMargin * 2)
                    observer.disconnect();
                    return;
                }
                let toActive;
                if (entries[0].intersectionRatio == 1) {  // enter viewed area
                    let entry = entries.reduce((u, v) => (u.target.toc_id > v.target.toc_id ? u : v));  // get the lowest item
                    toActive = $("#toc-item-" + $(entry.target).attr("href").substr(1));
                } else {
                    let entry = entries.reduce((u, v) => (u.target.toc_id < v.target.toc_id ? u : v));  // get the highest item
                    let idx = Math.max(entry.target.toc_id - 1, 0);
                    toActive = $("#toc-item-" + $(headerElems[idx]).attr("href").substr(1));
                }
                if (activeTocItem) activeTocItem.removeClass("is-current");
                activeTocItem = toActive
                activeTocItem.addClass("is-current");
            }
        
            initIntersectionObserver($(document).height() * 2);
            headerElems.each(function (index, obj) {
                obj.toc_id = index;
                scrollObserver.observe(obj);
            })
        });</script></div><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="" src="http://myblog.sharemer.com/avatar_2.png" alt="S-Virus"></figure><p class="title is-size-4 is-block line-height-inherit">S-Virus</p><p class="is-size-6 is-block">随机和因果，命运与无常，兼而有之</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>上海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">71</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">35</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">65</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/exceting" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/exceting"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="bilibili" href="https://www.bilibili.com"><i class="fas fa-tv"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:1807301715@qq.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-08T01:38:00.000Z">2020-06-08</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/08/%E6%B5%8E%E6%BA%90%E6%B8%B8%E8%AE%B0/">济源游记-20200517</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E6%97%A5%E5%B8%B8/">日常</a> / <a class="link-muted" href="/categories/%E6%97%A5%E5%B8%B8/%E6%97%85%E8%A1%8C/">旅行</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-01T16:11:00.000Z">2020-06-02</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/02/%E8%AF%A6%E8%A7%A3JDBC%E7%9A%84Loadbalance%E6%A8%A1%E5%BC%8F/">详解JDBC的Loadbalance模式</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/DB/">DB</a> / <a class="link-muted" href="/categories/DB/MySQL/">MySQL</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-02T07:47:00.000Z">2020-04-02</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/02/LV5-6%EF%BC%9Ajava%E5%B9%B6%E5%8F%91%E5%8C%85-juc%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/">LV5-6：java并发包-juc的简单介绍</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/JAVA%E5%9F%BA%E7%A1%80/">JAVA基础</a> / <a class="link-muted" href="/categories/JAVA%E5%9F%BA%E7%A1%80/JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA/">JAVA进化论</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-02T06:40:00.000Z">2020-04-02</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/02/LV5-5%EF%BC%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%9Ajoin%E3%80%81yield%E3%80%81sleep%E3%80%81interrupt/">LV5-5：线程调度：join、yield、sleep、interrupt</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/JAVA%E5%9F%BA%E7%A1%80/">JAVA基础</a> / <a class="link-muted" href="/categories/JAVA%E5%9F%BA%E7%A1%80/JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA/">JAVA进化论</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-01T13:35:00.000Z">2020-04-01</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/01/LV5-4%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%9Await%E3%80%81notify%E3%80%81notifyall/">LV5-4：线程通信：wait、notify、notifyall</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/JAVA%E5%9F%BA%E7%A1%80/">JAVA基础</a> / <a class="link-muted" href="/categories/JAVA%E5%9F%BA%E7%A1%80/JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA/">JAVA进化论</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/DB/"><span class="level-start"><span class="level-item">DB</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/DB/InfluxDB/"><span class="level-start"><span class="level-item">InfluxDB</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/DB/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/DB/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"><span class="level-start"><span class="level-item">分布式缓存</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/IDEA%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">IDEA插件开发</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JAVA%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">JAVA基础</span></span><span class="level-end"><span class="level-item tag">30</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/JAVA%E5%9F%BA%E7%A1%80/JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA/"><span class="level-start"><span class="level-item">JAVA进化论</span></span><span class="level-end"><span class="level-item tag">28</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JAVA%E5%9F%BA%E7%A1%80/JVM/"><span class="level-start"><span class="level-item">JVM</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">并发编程</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC/"><span class="level-start"><span class="level-item">JUC</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><span class="tag">基础知识</span><span class="tag is-grey-lightest">27</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%99%E7%A8%8B/"><span class="tag">教程</span><span class="tag is-grey-lightest">27</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span class="tag">并发编程</span><span class="tag is-grey-lightest">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="tag">网络编程</span><span class="tag is-grey-lightest">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NIO/"><span class="tag">NIO</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ThreadLocal/"><span class="tag">ThreadLocal</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/juc/"><span class="tag">juc</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF/"><span class="tag">池化技术</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"><span class="tag">连接池</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Druid/"><span class="tag">Druid</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JVM/"><span class="tag">JVM</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenTracing/"><span class="tag">OpenTracing</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/aop/"><span class="tag">aop</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ioc/"><span class="tag">ioc</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/map/"><span class="tag">map</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BD%8D%E5%9B%BE/"><span class="tag">位图</span><span class="tag is-grey-lightest">2</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=removeifFeedsId&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="removeifFeedsId" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div><p class="help">如果需要订阅，可以尝试留下你的邮箱</p></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="http://myblog.sharemer.com/logooo.png" alt="S-Virus" height="28"></a><p class="size-small"><span>&copy; 2020 S-Virus</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>,Modify by <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">removeif</a> <br><span>© 版权说明：[本博客所有文档均由博主创作，作为博主本人记录生活和学习之用，站内文档禁止转载，如有关于本站的疑问，请<a href="/message" target="_blank">留言</a>]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2018/12/29 00:00:00')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/exceting"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="2755914162" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.12/js/lightgallery-all.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><!--!--><!--!--><!--!--><script src="/js/toc.js" defer></script><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('17297b562584b5cec3d7','46c7652ed4f09fb1d847d15df81500a5a2ceeae8','exceting','exceting.github.io',false);})</script><link rel="stylesheet" href="/css/insight.css"><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="想要查找什么..."><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>(function (window) {
            var INSIGHT_CONFIG = {
                TRANSLATION: {
                    POSTS: '文章',
                    PAGES: '页面',
                    CATEGORIES: '分类',
                    TAGS: '标签',
                    UNTITLED: '(无标题)',
                },
                CONTENT_URL: '/content.json',
            };
            window.INSIGHT_CONFIG = INSIGHT_CONFIG;
        })(window);</script><script src="/js/insight.js" defer></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('17297b562584b5cec3d7','46c7652ed4f09fb1d847d15df81500a5a2ceeae8','exceting','exceting.github.io',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>