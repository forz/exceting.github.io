<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><meta name="keywords" content="[object Object]"><meta name="description" content="上一篇介绍了jvm的内存模型，本篇将介绍虚拟机中最为复杂的一部分：垃圾收集，本篇会从垃圾回收前的准备工作到后面的收集阶段的方式以及HotSpot虚拟机对这些工作的实现做个较为系统的记录，方便自己以后查找阅读。"><meta name="author" content="exceting"><title>JVM基础回顾记录（二）：垃圾收集 - S</title><meta description="上一篇介绍了jvm的内存模型，本篇将介绍虚拟机中最为复杂的一部分：垃圾收集，本篇会从垃圾回收前的准备工作到后面的收集阶段的方式以及HotSpot虚拟机对这些工作的实现做个较为系统的记录，方便自己以后查找阅读。"><meta property="og:type" content="article"><meta property="og:title" content="JVM基础回顾记录（二）：垃圾收集"><meta property="og:url" content="http://yoursite.com/2019/05/07/JVM%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"><meta property="og:site_name" content="S"><meta property="og:description" content="上一篇介绍了jvm的内存模型，本篇将介绍虚拟机中最为复杂的一部分：垃圾收集，本篇会从垃圾回收前的准备工作到后面的收集阶段的方式以及HotSpot虚拟机对这些工作的实现做个较为系统的记录，方便自己以后查找阅读。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://myblog.sharemer.com/avatar.jpg"><meta property="article:published_time" content="2019-05-07T01:29:00.000Z"><meta property="article:modified_time" content="2020-04-30T01:39:17.582Z"><meta property="article:author" content="exceting"><meta property="article:tag" content="JVM"><meta property="article:tag" content="GC"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://myblog.sharemer.com/avatar.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2019/05/07/JVM%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"},"headline":"JVM基础回顾记录（二）：垃圾收集","image":["http://myblog.sharemer.com/avatar.jpg"],"datePublished":"2019-05-07T01:29:00.000Z","dateModified":"2020-04-30T01:39:17.582Z","author":{"@type":"Person","name":"exceting"},"description":"上一篇介绍了jvm的内存模型，本篇将介绍虚拟机中最为复杂的一部分：垃圾收集，本篇会从垃圾回收前的准备工作到后面的收集阶段的方式以及HotSpot虚拟机对这些工作的实现做个较为系统的记录，方便自己以后查找阅读。"}</script><link rel="alternative" href="/atom.xml" title="S" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.12/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/css/style.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="http://myblog.sharemer.com/logooo.png" alt="S" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/exceting"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2019-05-07  <a class="commentCountImg" href="/2019/05/07/JVM%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/#comment-container"><span class="display-none-class">58e97093c0688e71749b3e94acd12175</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="58e97093c0688e71749b3e94acd12175">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>38 分钟  <i class="fas fa-pencil-alt"> </i>5.7k</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">JVM基础回顾记录（二）：垃圾收集</h1><div class="content"><blockquote>
<p>上一篇介绍了jvm的内存模型，本篇将介绍虚拟机中最为复杂的一部分：垃圾收集，本篇会从垃圾回收前的准备工作到后面的收集阶段的方式以及HotSpot虚拟机对这些工作的实现做个较为系统的记录，方便自己以后查找阅读。</p>
</blockquote>
<a id="more"></a>

<h2 id="一、栈帧、变量类型、引用分析"><a href="#一、栈帧、变量类型、引用分析" class="headerlink" title="一、栈帧、变量类型、引用分析"></a>一、栈帧、变量类型、引用分析</h2><p>讲解垃圾收集器的实现之前，结合之前讲的jvm内存区域划分，先来看下HotSpot虚拟机中对于对象的访问定位是怎样的，对象访问定位如下图所示：</p>
<p><img src="http://myblog.sharemer.com/2019/05/07/20190507-1-1.png?imageView2/0/w/1024" alt="图1" title="图1"></p>
<p>一般来说，一个方法视为一个<code>栈帧</code>，栈帧内会存放当前方法所有的变量，这就是栈的<code>本地变量表</code>，变量分为<code>基本类型变量</code>和<code>引用类型变量</code>，基本类型是直接在栈空间分配存储空间的（也即是当前栈帧内，受<code>-Xss</code>一定的影响），而引用类型则是预先无法知晓其内存占用量为多大，因此需要<code>动态分配内存</code>，这就需要借助<code>堆区</code>的存储，这种一般是<code>堆区</code>创建对象实例，而<code>栈帧</code>内创建一个引用<code>reference</code>，其存放的实际上是指向<code>堆区实例对象的地址</code>，实例对象的内部也有很多成员变量，其次实例对象也会有一个指针指向方法区里的属于该对象的类型数据（这一步就标记了当前实例属于哪个Class）。</p>
<p>先来看一段程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Teacher teacher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> b = <span class="number">2L</span>;</span><br><span class="line"></span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    student.setId(<span class="number">1</span>);</span><br><span class="line">    student.setAge(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    Teacher teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line">    teacher.setId(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    student.setTeacher(teacher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<center>代码块1</center>

<p>上面是很简单的一个程序，main方法里声明了一些变量以及初始化了一些对象，那么上面的程序执行过程中的引用关系表示为下图：</p>
<p><img src="http://myblog.sharemer.com/2019/05/07/20190507-1-2.png?imageView2/0/w/1024" alt="图2" title="图2"></p>
<p>上图就是执行到main方法尾部的最终引用关系，我们知道像栈帧里的数据（本地变量表）随着方法的执行结束，自然就被释放了，因此像main方法里的a、b、student、teacher是不需要GC来关心的，GC需要关心的是图2里堆区的俩实例对象，这俩实例对象是不会随着栈帧的结束而被回收掉的，因此需要借助GC来进行回收，那么什么样的对象可以被回收呢？这又回到上一篇里对可达性分析算法的描述了，其实就是看看当前实例还有没有被<code>GC Root</code>引用，针对上例，<code>GC Root</code>就是student和teacher，这俩引用没了，引用局面就变成了下面这样：</p>
<p><img src="http://myblog.sharemer.com/2019/05/07/20190507-1-3.png?imageView2/0/w/1024" alt="图3" title="图3"></p>
<p>很显然，两个实例已经失去了<code>GC Root</code>的引用，尽管Teacher实例还存在一个强引用，但是基于可达性分析算法的特性，也会被判定为“不可达”对象，最终俩实例会被GC回收掉。</p>
<p>到这里总结一下，<code>栈帧</code>里存放的<code>本地变量表</code>，存在两种类型的变量：<code>基本类型&amp;引用类型</code>，基本类型由于预先知道要为其分配多大内存，因此会直接在<code>栈帧</code>内创建，创建完毕后随着栈帧的结束而销毁，引用变量（非基本类型的其他类型变量）由于预先并不清楚需要分配多大的内存，可能后续需要动态扩容等，需要放入<code>堆空间</code>，栈帧内保留一个指向其内存地址的<code>引用变量</code>，而放入堆空间意味着实例本身无法随着栈帧的消失而被释放，需要借助<code>GC</code>来完成回收。</p>
<h2 id="二、预回收阶段"><a href="#二、预回收阶段" class="headerlink" title="二、预回收阶段"></a>二、预回收阶段</h2><h3 id="2-1：回收前的对象判活"><a href="#2-1：回收前的对象判活" class="headerlink" title="2.1：回收前的对象判活"></a>2.1：回收前的对象判活</h3><p>通过第一部分，大致了解了两种变量类型，而GC需要关心的则是<code>GC Root</code>，典型的作为GC Root的类型，则是<code>引用类型</code>，而判定变量是否为引用类型变量，往往影响着GC的实现。</p>
<p>这里所处的阶段是预回收阶段，这个阶段的GC不会发生回收，所以先不说回收阶段的算法（下面将要介绍的标记-清除算法、标记-压缩算法、复制算法），GC要进入回收阶段，首先要做的事情就是判断出“哪些对象还是活着的”，那么这个阶段需要做的事情是分析出对象的存活状态，有哪些方式可以判断出对象的活性呢？这里有两种主要方式：<code>引用计数</code>&amp;<code>可达性分析算法</code>，其中可达性分析算法是根据<code>GC Root</code>来进行判断的，所以需要关心栈帧里的<code>引用类型</code>变量，这个判断引用变量的方式，又分为<code>保守式</code>和<code>准确式</code>，这些判定方法的选择往往会影响GC的实现。</p>
<h4 id="2-1-1：引用计数法"><a href="#2-1-1：引用计数法" class="headerlink" title="2.1.1：引用计数法"></a>2.1.1：引用计数法</h4><p>这种判定算法非常简单，给对象添加一个引用计数器，每当有一个地方引用它，就加1，每当一个引用失效，就减1，当引用计数器为0的时候，就认为该对象失活，处于可回收状态。但是这种算法是有缺陷的，比如对象的循环引用问题，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> A();</span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line">a.b = b;</span><br><span class="line">b.a = a;</span><br><span class="line">a = <span class="keyword">null</span>;</span><br><span class="line">b = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>如上代码，首先A、B的实例首先被a、b引用，这时加1，然后又被a.b、b.a引用一次，再次加1，然后a、b指向null，A、B实例失去了一个引用，但是计数器里的引用数还是1，单看上面的代码，A、B对象的实例应该是需要被回收的的，因为不存在任何方法栈的引用，反而是它们内部的属性互相引用着彼此，因此利用这个算法，很大程度上会造成内存泄漏的问题。jvm在上述代码中，也是会把A和B的实例对象给回收掉的，因此JVM并不是采用这种方法分析对象活性的。</p>
<h4 id="2-1-2：可达性分析算法"><a href="#2-1-2：可达性分析算法" class="headerlink" title="2.1.2：可达性分析算法"></a>2.1.2：可达性分析算法</h4><p>这个算法的基本思路就是通过一系列的<code>GC Roots</code>的对象作为起点，然后从这些节点往下搜索，搜索走过的路径被称作“<code>引用链</code>”，当一个对象到<code>GC Roots</code>没有任何引用链相连时，则认为该对象死亡，<code>GC Roots</code>通常包含：<code>虚拟机栈（栈帧中的本地变量表）中引用的对象</code>、<code>方法区中的类静态属性引用的对象以及常量引用的对象</code>、<code>本地方法栈中的native方法引用的对象</code>。</p>
<p>那么再利用此算法来看看上述AB循环依赖问题例子的引用变化：</p>
<p><img src="http://myblog.sharemer.com/2019/05/07/20190507-1-4.png?imageView2/0/w/1024" alt="图4" title="图4"></p>
<p>通过<code>图4</code>可以看到，最后失去GC Roots的引用后，A、B的实例对象到GC Roots没有任何引用链相连，因此最终会被判定为死亡对象，进而被回收。</p>
<p>目前JVM的对象死亡判定也是通过该算法来进行判断的，当一个对象到GC Roots<code>“不可达”</code>时，即被认为<code>“可回收”</code>。</p>
<p>通过之前对可达性分析算法的介绍，这种判活方法主要根据判定一个对象是否直接或间接被一个GC Root引用，而引用类型的变量才会作为GC Root，因此采用这种判活算法，往往要先分析出哪些变量属于引用类型，因为有了这一步，所以可达性分析算法又根据JVM的实现不同，影响着GC的实现方式，因而GC又被分为了两种分析方式：</p>
<h5 id="2-1-2-1：可达性分析算法-保守式GC"><a href="#2-1-2-1：可达性分析算法-保守式GC" class="headerlink" title="2.1.2.1：可达性分析算法-保守式GC"></a>2.1.2.1：可达性分析算法-保守式GC</h5><p>如果JVM不选择记录下来栈帧中的变量哪些是引用类型，哪些是基本类型，对于GC而言，是无法知道变量类型，于是GC在回收前夕，需要遍历栈帧里的每一个变量，通过一些判定条件来分析出当前变量是否是引用变量，这些条件包括<code>边界检查</code>、<code>对齐检查</code>等，符合标准的，会被视为<code>引用类型</code>变量，否则为基本类型变量，这种判定方式比较简单，但是存在缺点，比如一个对象实际上没有任何引用存在了，但是仍然存在<code>“疑似指向”</code>它的指针，使得其逃过被GC的命运，这里<code>“疑似指向”</code>的意思是说，栈帧里可能恰好存在一个通过了条件检查（边界、对齐等检查都符合引用类型数据的条件）的变量，这时GC会认为它就是一个GC Root，被认为是GC Root后，其值正好对应上这个无用对象的地址，那么这个死对象仍然被认为“<code>可达</code>”，此时就会绕过了一次GC。</p>
<h5 id="2-1-2-2：可达性分析算法-准确式GC"><a href="#2-1-2-2：可达性分析算法-准确式GC" class="headerlink" title="2.1.2.2：可达性分析算法-准确式GC"></a>2.1.2.2：可达性分析算法-准确式GC</h5><p>这是目前HotSpot虚拟机会采用的一种枚举GC Roots的方式（下面③会介绍实现方式），准确式GC不同于保守式GC，准确式GC是在枚举GC Roots时，GC已经知道了栈帧里所有对象的类型，这就免去了上面的不确定检查，因为预先知道栈帧里的变量是引用类型还是基本类型，那么枚举GC Roots就变的非常准确，这就是准确式GC。</p>
<h5 id="2-1-2-3：HotSpot对于准确式GC的实现-OopMap"><a href="#2-1-2-3：HotSpot对于准确式GC的实现-OopMap" class="headerlink" title="2.1.2.3：HotSpot对于准确式GC的实现-OopMap"></a>2.1.2.3：HotSpot对于准确式GC的实现-OopMap</h5><p>HotSpot虚拟机是采用<code>OopMap</code>来实现引用类型标记的，<code>OopMap</code>可以记录下当前栈帧里所有引用类型变量，<code>GC</code>时，只需要读取这里面的变量即可，很多资料会提到<code>OopMap</code>是<code>提高了枚举GC Roots的效率</code>，其实这不是<code>OopMap</code>真正的目的，<code>OopMap</code>的实现是HotSpot用来实现<code>准确式GC</code>的，而这样处理，恰好对枚举效率的提升也起到一定的帮助（比如枚举时完全可以忽略掉那些基本类型变量了，因为他们不会被记到<code>OopMap</code>里）。</p>
<h3 id="2-2：STW"><a href="#2-2：STW" class="headerlink" title="2.2：STW"></a>2.2：STW</h3><p>上面说了GC开始前针对对象的判活方法，HotSpot通过OopMap实现了<code>准确式GC</code>，现在来讲下GC前的准备工作，GC前往往需要将所有正在运行的线程挂起，这是为了防止一些引用在GC过程中还在不停的发生变化而做的一致性保护，这种行为叫做<code>STW</code>（<code>Stop The World</code>），一般来说，STW发生时的<code>线程中断</code>，HotSpot虚拟机需要每个线程将自己的程序执行到指定位置，根据线程是否已经让出CPU资源（即线程状态）而分为两种意义上的位置：</p>
<h4 id="2-2-1：安全点（Safe-Point）"><a href="#2-2-1：安全点（Safe-Point）" class="headerlink" title="2.2.1：安全点（Safe Point）"></a>2.2.1：安全点（Safe Point）</h4><p>针对的是GC发生时还在运行的线程，这时候需要等待该线程主动运行到指定位置才中断线程，这些指定的位置，被称为<code>安全点</code>，<code>安全点</code>的意义是什么呢？上面说到HotSpot通过OopMap来完成<code>准确式GC</code>，但是引用关系的变化是不可避免的，每变化一次，就更新一次OopMap显然效率不高，因此JVM更新OopMap的实现就用到了<code>安全点</code>，当线程运行到安全点，记录下当前引用，更新至OopMap即可，这也就解释了为什么程序中断前必须要停靠在最近的安全点上。可作为安全点的位置有：<code>循环末尾</code>、<code>方法临近返回前</code>、<code>方法调用后</code>、<code>抛出异常的位置</code>。</p>
<h4 id="2-2-2：安全区域（Safe-Region）"><a href="#2-2-2：安全区域（Safe-Region）" class="headerlink" title="2.2.2：安全区域（Safe Region）"></a>2.2.2：安全区域（Safe Region）</h4><p>意义类似<code>安全点</code>，这个概念是针对<code>GC发生前</code>，程序线程处于“<code>CPU让出状态</code>”，比如线程的sleep状态或者blocked状态，这时该线程是没有能力运行到就近的安全点的，针对此情况，便有了<code>安全区域</code>概念，<code>安全区域</code>是指在一段代码区域中，引用关系是不会发生变化的，在此区域的任意位置开始GC都是安全的。线程在运行到<code>安全区域</code>内，首先会标记自己已经到达了安全区域，那么当JVM需要GC时，发现该线程已经进入安全区域，则不会再去管其状态（无视<code>sleep</code>、<code>blocked</code>等让出CPU的状态），直接对其内部进行<code>OopMap更新</code>，完成GC Roots的枚举，当然，如果线程离开安全区域时，就需要判断是否已经完成了GC或者GC Roots枚举，若完成则继续执行，否则就必须等待直到收到可以离开安全区域的信号为止。</p>
<h4 id="2-2-3：STW中断线程的两种方式"><a href="#2-2-3：STW中断线程的两种方式" class="headerlink" title="2.2.3：STW中断线程的两种方式"></a>2.2.3：STW中断线程的两种方式</h4><p>安全点和安全区域均为HotSpot虚拟机为了保证枚举GC Roots的准确性而做出的实现，结合安全点、安全区域，在达到安全点时GC对线程的中断（STW）又分为两种中断方式：</p>
<h5 id="2-2-3-1：抢先式中断"><a href="#2-2-3-1：抢先式中断" class="headerlink" title="2.2.3.1：抢先式中断"></a>2.2.3.1：抢先式中断</h5><p>在GC发生时，首先<code>中断所有线程</code>，然后检查各个线程是否执行到了<code>安全点</code>，如果没有，则<code>恢复</code>对应线程让其运行到安全点再次完成<code>中断</code>。</p>
<h5 id="2-2-3-2：主动式中断"><a href="#2-2-3-2：主动式中断" class="headerlink" title="2.2.3.2：主动式中断"></a>2.2.3.2：主动式中断</h5><p>在GC发生时，<code>不直接操作线程中断</code>，而是简单设置一个<code>标记</code>，让各个线程去<code>轮询</code>这个标记，如果轮询到该标记，则自己<code>主动中断挂起自己</code>。JVM就采用该中断方式，轮询标记的位置和<code>安全点</code>的位置一般是<code>重合</code>的。</p>
<h2 id="三、回收阶段-垃圾回收算法"><a href="#三、回收阶段-垃圾回收算法" class="headerlink" title="三、回收阶段-垃圾回收算法"></a>三、回收阶段-垃圾回收算法</h2><p>第二部分讲的是GC前的准备工作，以及HotSpot在GC前针对枚举GC Roots的实现，下面来看下完成GC Roots枚举后的回收阶段的几种回收算法。</p>
<h3 id="3-1：标记-清除算法"><a href="#3-1：标记-清除算法" class="headerlink" title="3.1：标记-清除算法"></a>3.1：标记-清除算法</h3><p>这是一种最基础的收集算法，这种算法分为两个阶段：</p>
<ol>
<li><p>标记出所有需要回收的对象（这里的标记使用可达性分析算法进行判定）</p>
</li>
<li><p>标记完成后统一回收所有被标记的对象</p>
</li>
</ol>
<p>这个算法两个阶段的效率都不高，而且会产生大量的内存碎片，碎片过多可能会导致无法找到连续内存存储较大的对象，所以会被迫提前触发一次GC，图示如下：</p>
<p><img src="http://myblog.sharemer.com/2019/05/07/20190507-1-5.png?imageView2/0/w/1024" alt="图5" title="图5"></p>
<p>由上图可以看到，在回收后，产生了大量不连续的内存单元碎片。单纯从<code>图5</code>看，只能知道这个算法会产生内存碎片，并不能了解整个算法的细节，因此单纯通过上图，是没办法体现该算法效率问题的，<code>图5</code>是大部分资料里都会展示的一个最终态，算法细节则全部省略，导致很多时候，<code>标记-清除算法</code>相比<code>复制算法</code>的效率究竟弱在哪里没有很清晰的认知，下面，通过一幅图来说明下其具体的执行细节：</p>
<p><img src="http://myblog.sharemer.com/2019/05/07/20190507-1-6.png?imageView2/0/w/1024" alt="图6" title="图6"></p>
<p>上图就是<code>标记-清除算法</code>的执行过程，首先从<code>标记阶段</code>到<code>清除阶段</code>，GC执行流程如下：</p>
<ol>
<li><p>把从root开始的可能被引用的对象（<code>可达对象</code>）进行一个个的标记，图中的“<code>标记阶段</code>”就是在干这件事，被标记的对象图里已染成绿色。</p>
</li>
<li><p>重复<code>1步骤</code>就可以把所有从root出发的被引用或间接引用的对象全部打上标记</p>
</li>
<li><p>在上述两个过程完成后，<code>标记阶段</code>就算告一段落，接下来就是<code>清除阶段</code>，<code>清除阶段</code>将上述被标记的对象视为“<code>存活对象</code>”，这时会<strong>扫描全部对象</strong>，将没有被标记的<code>对象清除</code>，同时将有标记的对象的<code>标记去除</code>，方便下次GC使用。</p>
</li>
</ol>
<p>了解完这个算法的执行过程，大致上就知道了为什么这个算法的效率会很低了，如果系统中会创建大量的对象，但只有很少的对象会存活的比较久，这时候该算法的效率在<code>清除阶段</code>的时候，耗时就会很久，因为要<code>整体遍历</code>，而且还要进行<code>大量回收</code>。</p>
<h3 id="3-2：复制算法"><a href="#3-2：复制算法" class="headerlink" title="3.2：复制算法"></a>3.2：复制算法</h3><p>这种算法将可用内存划分为大小相等的两块，每次只使用其中一块，GC触发时，就将该块内存里还存活着的对象整体复制到另外一块内存上去，然后再把已使用的内存一次性清除掉，下面来展示下回收状态：</p>
<p><img src="http://myblog.sharemer.com/2019/05/07/20190507-1-7.png?imageView2/0/w/1024" alt="图7" title="图7"></p>
<p>同样的，这张图仅用来表现清理过程和最终态，下面，通过<code>图8</code>来说明下这种算法的执行流程：</p>
<p><img src="http://myblog.sharemer.com/2019/05/07/20190507-1-8.png?imageView2/0/w/1024" alt="图8" title="图8"></p>
<p>上图就是复制算法的执行过程：</p>
<ol>
<li><p>根据<code>root</code>，找出来所有的<code>可达对象</code>（<code>存活对象</code>），整体<code>复制</code>到<code>新空间</code>里（这个过程类似<code>标记-清除算法</code>里的<code>标记阶段</code>）。</p>
</li>
<li><p>将原来的<code>旧空间</code>里的所有对象整体清除掉（完成复制后，可以认为原来的<code>旧空间</code>里的所有对象都可以回收），下次GC的时候，本次GC意义上的“<code>新空间</code>”就变成了下次GC意义上的“<code>旧空间</code>”，以此类推。</p>
</li>
</ol>
<p>相比<code>标记-清除</code>算法，复制算法虽然内存被一分为二，但是<strong>节省了整体遍历所有对象</strong>这一步操作，对于那种产生大量对象，但是对象生命周期极短的情况，这个算法相比<code>标记-清除算法</code>效率高了不止一个档次，因为每次仅复制一小批存活的对象，没必要整体遍历所有的对象进行标记判断+清理的操作。所以这种算法适合那种对象多，但大部分对象生命周期短的情况，如果对象多，生命周期长，那么意味着复制算法每次对复制这个动作的开销，是非常大的，这也就解释了，为什么jvm<code>新生代</code>的回收算法采用<code>复制算法</code>，而<code>老年代</code>则不用。</p>
<h3 id="3-3：标记-压缩算法"><a href="#3-3：标记-压缩算法" class="headerlink" title="3.3：标记-压缩算法"></a>3.3：标记-压缩算法</h3><p>也分为两个阶段：</p>
<ol>
<li><p>标记阶段，这个阶段跟<code>标记-清除算法</code>一致，具体流程可以参考<code>图6</code></p>
</li>
<li><p>压缩阶段，相比<code>标记-清除算法</code>，该算法不再整体遍历所有的对象，而是将带有标记的“<code>存活对象</code>”依次<code>压缩排列</code>，排列完成后，存活对象将紧紧挨在一起，清除时只需要将存活对象<code>边界以外</code>的区域全部清理即可。</p>
</li>
</ol>
<p>过程如图所示：</p>
<p><img src="http://myblog.sharemer.com/2019/05/07/20190507-1-9.png?imageView2/0/w/1024" alt="图9" title="图9"></p>
<p>这里不再画算法的执行流程图，标记步骤参考<code>图6</code>，压缩过程参考<code>图9</code>即可。</p>
<p>这个算法的好处就是不会产生内存碎片，不会大量复制，相比<code>复制算法</code>，内存也不会减半，由于少了一层遍历所有对象的操作，因此一般效率也要比<code>标记-清除算法</code>高。</p>
<h3 id="3-4：分代收集算法"><a href="#3-4：分代收集算法" class="headerlink" title="3.4：分代收集算法"></a>3.4：分代收集算法</h3><p>目前商业虚拟机的垃圾回收都采用分代收集算法，这种算法基于上述几个基本的垃圾回收算法，通过「<code>分代</code>」的方式分类不同生命周期特征的对象，将不同「<code>代</code>」使用适合的收集算法来实现回收，比如jvm<code>新生代</code>，新生代中的对象特征为生命周期短，每次回收只有少量对象存活，且要求快速，因此适合用<code>复制-收集算法</code>来实现（比如<code>新生代</code>里的<code>Eden区</code>和两个<code>Survivor区</code>，就是为<code>复制算法</code>而拆分出来的），而<code>老年代</code>里的对象因为生命周期长，每次回收大量的对象还处于存活期，如果再使用复制-收集算法来实现，那么复制成本是很高的，因此<code>老年代</code>则适合使用<code>标记-整理算法</code>，这种不使用单一算法，会根据对象的生命周期特征进行算法隔离分区的方式就叫做「<code>分代收集</code>」。</p>
</div><ul class="post-copyright"><li><strong>本文标题：</strong><a href="http://yoursite.com/2019/05/07/JVM基础回顾记录（二）：垃圾收集/">JVM基础回顾记录（二）：垃圾收集</a></li><li><strong>本文作者：</strong><a href="http://yoursite.com">S</a></li><li><strong>本文链接：</strong><a href="http://yoursite.com/2019/05/07/JVM基础回顾记录（二）：垃圾收集/">http://yoursite.com/2019/05/07/JVM基础回顾记录（二）：垃圾收集/</a></li><li><strong>版权声明：</strong><span>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</span></li></ul><div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/2019/04/06/JVM%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AJVM%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" target="_blank">JVM基础回顾记录（一）：JVM的内存模型</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="http://myblog.sharemer.com/alipay_qrcode.png" alt="支付宝"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="http://myblog.sharemer.com/wx_qrcode.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/06/21/InfluxDB%EF%BC%88%E4%B8%80%EF%BC%89%E5%88%9D%E6%8E%A2%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">InfluxDB（一）初探时序数据库</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/04/15/%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/"><span class="level-item">链路追踪（二）-分布式链路追踪系统数据采集</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            id: '58e97093c0688e71749b3e94acd12175',
            repo: 'exceting.github.io',
            owner: 'exceting',
            clientID: '17297b562584b5cec3d7',
            clientSecret: '46c7652ed4f09fb1d847d15df81500a5a2ceeae8',
            admin: ["exceting"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: 'last',
            
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget toc-scroll" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-一、栈帧、变量类型、引用分析" href="#一、栈帧、变量类型、引用分析"><span>一、栈帧、变量类型、引用分析</span></a></li><li><a class="is-flex toc-item" id="toc-item-二、预回收阶段" href="#二、预回收阶段"><span>二、预回收阶段</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-2-1：回收前的对象判活" href="#2-1：回收前的对象判活"><span>2.1：回收前的对象判活</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-2-1-1：引用计数法" href="#2-1-1：引用计数法"><span>2.1.1：引用计数法</span></a></li><li><a class="is-flex toc-item" id="toc-item-2-1-2-3：HotSpot对于准确式GC的实现-OopMap" href="#2-1-2-3：HotSpot对于准确式GC的实现-OopMap"><span>2.1.2.3：HotSpot对于准确式GC的实现-OopMap</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-2-2：STW" href="#2-2：STW"><span>2.2：STW</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-2-2-1：安全点（Safe-Point）" href="#2-2-1：安全点（Safe-Point）"><span>2.2.1：安全点（Safe Point）</span></a></li><li><a class="is-flex toc-item" id="toc-item-2-2-2：安全区域（Safe-Region）" href="#2-2-2：安全区域（Safe-Region）"><span>2.2.2：安全区域（Safe Region）</span></a></li><li><a class="is-flex toc-item" id="toc-item-2-2-3-2：主动式中断" href="#2-2-3-2：主动式中断"><span>2.2.3.2：主动式中断</span></a></li></ul></li></ul></li><li><a class="is-flex toc-item" id="toc-item-三、回收阶段-垃圾回收算法" href="#三、回收阶段-垃圾回收算法"><span>三、回收阶段-垃圾回收算法</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-3-1：标记-清除算法" href="#3-1：标记-清除算法"><span>3.1：标记-清除算法</span></a></li><li><a class="is-flex toc-item" id="toc-item-3-2：复制算法" href="#3-2：复制算法"><span>3.2：复制算法</span></a></li><li><a class="is-flex toc-item" id="toc-item-3-3：标记-压缩算法" href="#3-3：标记-压缩算法"><span>3.3：标记-压缩算法</span></a></li><li><a class="is-flex toc-item" id="toc-item-3-4：分代收集算法" href="#3-4：分代收集算法"><span>3.4：分代收集算法</span></a></li></ul></li></ul></div></div><script type="text/javascript" async>
        $(document).ready(function () { //参考自 https://github.com/ppoffice/hexo-theme-icarus/pull/616/files
            var observerTopMargin;
            var scrollObserver;
            var headerElems = $(".headerlink");
            var activeTocItem;
        
            function initIntersectionObserver(docHeight) {
                observerTopMargin = docHeight;
                scrollObserver = new IntersectionObserver(scrollCallBack,
                    {
                        root: null,  // viewpoint
                        rootMargin: docHeight + "px 0px -80% 0px"  // cover top 30% of viewport to the top of document
                    })
            }
        
            function scrollCallBack(entries, observer) {
                if ($(window).scrollTop() > observerTopMargin * 0.7) { 
                    // User somehow scroll to 70% of observerTopMargin (which is inited as 200% document height)
                    // Observer top margin need to extend to cover all the space to the top of the document
                    initIntersectionObserver(observerTopMargin * 2)
                    observer.disconnect();
                    return;
                }
                let toActive;
                if (entries[0].intersectionRatio == 1) {  // enter viewed area
                    let entry = entries.reduce((u, v) => (u.target.toc_id > v.target.toc_id ? u : v));  // get the lowest item
                    toActive = $("#toc-item-" + $(entry.target).attr("href").substr(1));
                } else {
                    let entry = entries.reduce((u, v) => (u.target.toc_id < v.target.toc_id ? u : v));  // get the highest item
                    let idx = Math.max(entry.target.toc_id - 1, 0);
                    toActive = $("#toc-item-" + $(headerElems[idx]).attr("href").substr(1));
                }
                if (activeTocItem) activeTocItem.removeClass("is-current");
                activeTocItem = toActive
                activeTocItem.addClass("is-current");
            }
        
            initIntersectionObserver($(document).height() * 2);
            headerElems.each(function (index, obj) {
                obj.toc_id = index;
                scrollObserver.observe(obj);
            })
        });</script></div><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="" src="http://myblog.sharemer.com/avatar.jpg" alt="S"></figure><p class="title is-size-4 is-block line-height-inherit">S</p><p class="is-size-6 is-block">随机和因果，命运与无常，兼而有之</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>上海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">45</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">35</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">57</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/exceting" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/exceting"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Bilibili" href="https://www.bilibili.com"><i class="fab fa-bilibili"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:1807301715@qq.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-03-09T16:51:00.000Z">2020-03-10</time></p><p class="title is-6"><a class="link-muted" href="/2020/03/10/JAVA%E6%9C%89%E5%85%B3%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%85%A8%E5%A5%97%E6%A2%B3%E7%90%86/">JAVA有关位运算的全套梳理</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/JAVA%E5%9F%BA%E7%A1%80/">JAVA基础</a> / <a class="link-muted" href="/categories/JAVA%E5%9F%BA%E7%A1%80/JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA/">JAVA进化论</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-02-28T12:20:00.000Z">2020-02-28</time></p><p class="title is-6"><a class="link-muted" href="/2020/02/28/LV1-3%EF%BC%9Ajava%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6/">LV1-3：java中的运算符</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/JAVA%E5%9F%BA%E7%A1%80/">JAVA基础</a> / <a class="link-muted" href="/categories/JAVA%E5%9F%BA%E7%A1%80/JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA/">JAVA进化论</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-02-26T12:03:00.000Z">2020-02-26</time></p><p class="title is-6"><a class="link-muted" href="/2020/02/26/LV1-2%EF%BC%9Ajava%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/">LV1-2：java中的变量类型</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/JAVA%E5%9F%BA%E7%A1%80/">JAVA基础</a> / <a class="link-muted" href="/categories/JAVA%E5%9F%BA%E7%A1%80/JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA/">JAVA进化论</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-02-25T06:57:00.000Z">2020-02-25</time></p><p class="title is-6"><a class="link-muted" href="/2020/02/25/LV1-1%EF%BC%9A%E5%AE%89%E8%A3%85java%E7%8E%AF%E5%A2%83&amp;%E7%AC%AC%E4%B8%80%E4%B8%AAjava%E7%A8%8B%E5%BA%8F/">LV1-1：安装java环境&amp;第一个java程序</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/JAVA%E5%9F%BA%E7%A1%80/">JAVA基础</a> / <a class="link-muted" href="/categories/JAVA%E5%9F%BA%E7%A1%80/JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA/">JAVA进化论</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2019-12-13T04:52:00.000Z">2019-12-13</time></p><p class="title is-6"><a class="link-muted" href="/2019/12/13/IDEA%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%A1%A8%E5%8D%95demo/">IDEA插件开发（一）一个简单的表单demo</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/IDEA%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/">IDEA插件开发</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/DB/"><span class="level-start"><span class="level-item">DB</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/DB/InfluxDB/"><span class="level-start"><span class="level-item">InfluxDB</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/DB/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/DB/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"><span class="level-start"><span class="level-item">分布式缓存</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/IDEA%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">IDEA插件开发</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JAVA%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">JAVA基础</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/JAVA%E5%9F%BA%E7%A1%80/JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA/"><span class="level-start"><span class="level-item">JAVA进化论</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JAVA%E5%9F%BA%E7%A1%80/JVM/"><span class="level-start"><span class="level-item">JVM</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">并发编程</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC/"><span class="level-start"><span class="level-item">JUC</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/10/"><span class="level-start"><span class="level-item">十月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/NIO/"><span class="tag">NIO</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="tag">网络编程</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span class="tag">并发编程</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ThreadLocal/"><span class="tag">ThreadLocal</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><span class="tag">基础知识</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%99%E7%A8%8B/"><span class="tag">教程</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF/"><span class="tag">池化技术</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"><span class="tag">连接池</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Druid/"><span class="tag">Druid</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JVM/"><span class="tag">JVM</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenTracing/"><span class="tag">OpenTracing</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/aop/"><span class="tag">aop</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ioc/"><span class="tag">ioc</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/juc/"><span class="tag">juc</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"><span class="tag">分布式缓存</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag is-grey-lightest">2</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=removeifFeedsId&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="removeifFeedsId" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div><p class="help">输入邮箱开始订阅，更博后邮件通知！</p></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="http://myblog.sharemer.com/logooo.png" alt="S" height="28"></a><p class="size-small"><span>&copy; 2020 S</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>,Modify by <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">removeif</a> <br><span>© 版权说明：[本站所有内容均收集于互联网或自己创作，方便于本人记录和学习，如有侵权，请<a href="/message" target="_blank">留言</a>，我会立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2018/12/29 00:00:00')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/exceting"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="2755914162" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.12/js/lightgallery-all.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><!--!--><!--!--><!--!--><script src="/js/toc.js" defer></script><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('17297b562584b5cec3d7','46c7652ed4f09fb1d847d15df81500a5a2ceeae8','exceting','exceting.github.io',false);})</script><link rel="stylesheet" href="/css/insight.css"><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="想要查找什么..."><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>(function (window) {
            var INSIGHT_CONFIG = {
                TRANSLATION: {
                    POSTS: '文章',
                    PAGES: '页面',
                    CATEGORIES: '分类',
                    TAGS: '标签',
                    UNTITLED: '(无标题)',
                },
                CONTENT_URL: '/content.json',
            };
            window.INSIGHT_CONFIG = INSIGHT_CONFIG;
        })(window);</script><script src="/js/insight.js" defer></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('17297b562584b5cec3d7','46c7652ed4f09fb1d847d15df81500a5a2ceeae8','exceting','exceting.github.io',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>