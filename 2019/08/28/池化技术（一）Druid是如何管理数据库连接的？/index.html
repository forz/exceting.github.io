<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><meta name="keywords" content="[object Object]"><meta name="description" content="基于依赖程序的版本信息：&amp;nbsp"><meta name="author" content="exceting"><title>池化技术（一）Druid是如何管理数据库连接的？ - S-Virus</title><meta description="基于依赖程序的版本信息：&amp;amp;nbsp;&amp;amp;nbsp; 下一篇：HikariCP是如何管理数据库连接的"><meta property="og:type" content="article"><meta property="og:title" content="池化技术（一）Druid是如何管理数据库连接的？"><meta property="og:url" content="http://yoursite.com/2019/08/28/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF%EF%BC%88%E4%B8%80%EF%BC%89Druid%E6%98%AF%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E7%9A%84%EF%BC%9F/"><meta property="og:site_name" content="S-Virus"><meta property="og:description" content="基于依赖程序的版本信息：&amp;amp;nbsp;&amp;amp;nbsp; 下一篇：HikariCP是如何管理数据库连接的"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://myblog.sharemer.com/avatar_2.png"><meta property="article:published_time" content="2019-08-27T16:16:00.000Z"><meta property="article:modified_time" content="2020-05-02T07:44:02.684Z"><meta property="article:author" content="exceting"><meta property="article:tag" content="池化技术"><meta property="article:tag" content="连接池"><meta property="article:tag" content="Druid"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://myblog.sharemer.com/avatar_2.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2019/08/28/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF%EF%BC%88%E4%B8%80%EF%BC%89Druid%E6%98%AF%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E7%9A%84%EF%BC%9F/"},"headline":"池化技术（一）Druid是如何管理数据库连接的？","image":["http://myblog.sharemer.com/avatar_2.png"],"datePublished":"2019-08-27T16:16:00.000Z","dateModified":"2020-05-02T07:44:02.684Z","author":{"@type":"Person","name":"exceting"},"description":"基于依赖程序的版本信息：&amp;nbsp;&amp;nbsp; 下一篇：HikariCP是如何管理数据库连接的"}</script><link rel="alternative" href="/atom.xml" title="S-Virus" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.12/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/css/style.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="http://myblog.sharemer.com/logooo.png" alt="S-Virus" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">🏠 首页</a><a class="navbar-item" href="/archives">⚜️ 归档</a><a class="navbar-item" href="/categories">👾 分类</a><a class="navbar-item" href="/tags">🔖 标签</a><a class="navbar-item" href="/categories/%E6%97%A5%E5%B8%B8/">🌴 日常</a><a class="navbar-item" href="/course">📚 教程</a><a class="navbar-item" href="/message">📝 留言</a><a class="navbar-item" href="/timeline">⌚️ 时光轴</a><a class="navbar-item" href="/about">👨🏻‍💻 关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/exceting"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2019-08-28  <a class="commentCountImg" href="/2019/08/28/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF%EF%BC%88%E4%B8%80%EF%BC%89Druid%E6%98%AF%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E7%9A%84%EF%BC%9F/#comment-container"><span class="display-none-class">f2b8d24880eb67258beb240c75f65e28</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="f2b8d24880eb67258beb240c75f65e28">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>2 小时  <i class="fas fa-pencil-alt"> </i>15.5k</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">池化技术（一）Druid是如何管理数据库连接的？</h1><div class="content"><blockquote>
<p>基于依赖程序的版本信息：<embed src="https://img.shields.io/badge/Druid-v1.1.16-green" style="display:inline-block;*display:inline;width:102px;height:20px" />&nbsp;&nbsp;<embed src="https://img.shields.io/badge/mysql--connector--java-v8.0.17-green" style="display:inline-block;*display:inline;width:184px;height:20px" /></p>
<p>下一篇：<a href="/2019/08/28/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF%EF%BC%88%E4%BA%8C%EF%BC%89HikariCP%E6%98%AF%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E7%9A%84%EF%BC%9F/">HikariCP是如何管理数据库连接的</a></p>
</blockquote>
<a id="more"></a>

<h2 id="零、类图-amp-流程预览"><a href="#零、类图-amp-流程预览" class="headerlink" title="零、类图&amp;流程预览"></a>零、类图&amp;流程预览</h2><p>下方流程中涉及到的类、属性、方法名均列在这里：<a href="/2019/09/20/Druid-%E7%B1%BB%E5%9B%BE-%E5%B1%9E%E6%80%A7%E8%A1%A8/">Druid-类图-属性表</a> ←该表格用来辅助理解下面的流程图和代码，不用细看，混乱时可用来理清关系。</p>
<p>本文会通过getConnection作为入口，探索在druid里，一个连接的生命周期。大体流程被划分成了以下几个主流程：</p>
<p><img src="http://myblog.sharemer.com/2019/08/28/20190828-2-1.png?imageView2/0/w/1024" alt="表1" title="表1"></p>
<h2 id="一、主流程1：获取连接流程"><a href="#一、主流程1：获取连接流程" class="headerlink" title="一、主流程1：获取连接流程"></a>一、主流程1：获取连接流程</h2><p>首先从入口来看看它在获取连接时做了哪些操作：</p>
<p><img src="http://myblog.sharemer.com/2019/08/28/20190828-2-2.png?imageView2/0/w/1024" alt="主流程1" title="主流程1"></p>
<p>上述流程对应源代码如下（请展开）：</p>
<figure class="highlight java"><figcaption><span>代码段1-1 &gt;folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DruidPooledConnection <span class="title">getConnection</span><span class="params">(<span class="keyword">long</span> maxWaitMillis)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        init(); <span class="comment">//初始化，即主流程2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (filters.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            FilterChainImpl filterChain = <span class="keyword">new</span> FilterChainImpl(<span class="keyword">this</span>); <span class="comment">//责任链，内部也是触发下面的getConnectionDirect方法，只是要走一遍责任链上每个filter的逻辑，这里不做描述，后续放到流程1.1里体现</span></span><br><span class="line">            <span class="keyword">return</span> filterChain.dataSource_connect(<span class="keyword">this</span>, maxWaitMillis);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getConnectionDirect(maxWaitMillis); <span class="comment">//触发getConnectionDirect</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DruidPooledConnection <span class="title">getConnectionDirect</span><span class="params">(<span class="keyword">long</span> maxWaitMillis)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> notFullTimeoutRetryCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">//死循环</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 真正返回出去的连接对象，注意这里是被druid包装成了DruidPooledConnection类型，</span></span><br><span class="line"><span class="comment">             * 实际上池子里存放的连接类型是DruidConnectionHolder，DruidPooledConnection类本身持有一个holder属性，</span></span><br><span class="line"><span class="comment">             * 用于保存真正的连接对象，而DruidConnectionHolder才是真正保存驱动连接对象的类。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            DruidPooledConnection poolableConnection;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                poolableConnection = getConnectionInternal(maxWaitMillis); <span class="comment">//从池子里获取连接，这一个后续放到流程1.2体现</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (GetConnectionTimeoutException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (notFullTimeoutRetryCnt &lt;= <span class="keyword">this</span>.notFullTimeoutRetryCount &amp;&amp; !isFull()) &#123; <span class="comment">//出现了超时异常，在连接池没满且重试次数未超过上限的情况下，重试一次（notFullTimeoutRetryCount默认是0，所以至少可以重试一次）。</span></span><br><span class="line">                    notFullTimeoutRetryCnt++; <span class="comment">//重试次数+1</span></span><br><span class="line">                    <span class="keyword">if</span> (LOG.isWarnEnabled()) &#123;</span><br><span class="line">                        LOG.warn(<span class="string">"get connection timeout retry : "</span> + notFullTimeoutRetryCnt);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> ex; <span class="comment">//超过重试次数或者池子已满仍然获取失败，则直接抛出异常</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (testOnBorrow) &#123; <span class="comment">//testOnBorrow开启时，每次都进行检测连接可用性</span></span><br><span class="line">                <span class="keyword">boolean</span> validate = testConnectionInternal(poolableConnection.holder, poolableConnection.conn);</span><br><span class="line">                <span class="keyword">if</span> (!validate) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                        LOG.debug(<span class="string">"skip not validate connection."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Connection realConnection = poolableConnection.conn; <span class="comment">//获取真正驱动的连接对象</span></span><br><span class="line">                    discardConnection(realConnection); <span class="comment">//若连接不可用，则触发discard，这个方法具体放到流程1.4体现</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Connection realConnection = poolableConnection.conn;</span><br><span class="line">                <span class="keyword">if</span> (poolableConnection.conn.isClosed()) &#123;</span><br><span class="line">                    discardConnection(<span class="keyword">null</span>); <span class="comment">// 传入null，避免重复关闭</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (testWhileIdle) &#123; <span class="comment">//不启用testOnBorrow的情况下，才会判断是否启用testWhileIdle</span></span><br><span class="line">                    <span class="keyword">final</span> DruidConnectionHolder holder = poolableConnection.holder;</span><br><span class="line">                    <span class="keyword">long</span> currentTimeMillis             = System.currentTimeMillis();</span><br><span class="line">                    <span class="keyword">long</span> lastActiveTimeMillis          = holder.lastActiveTimeMillis; <span class="comment">//上次被使用的时间</span></span><br><span class="line">                    <span class="keyword">long</span> lastKeepTimeMillis            = holder.lastKeepTimeMillis;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (lastKeepTimeMillis &gt; lastActiveTimeMillis) &#123;</span><br><span class="line">                        lastActiveTimeMillis = lastKeepTimeMillis;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">long</span> idleMillis = currentTimeMillis - lastActiveTimeMillis; <span class="comment">//计算出闲置时间</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">long</span> timeBetweenEvictionRunsMillis = <span class="keyword">this</span>.timeBetweenEvictionRunsMillis;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (timeBetweenEvictionRunsMillis &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (idleMillis &gt;= timeBetweenEvictionRunsMillis || idleMillis &lt; <span class="number">0</span>) &#123; <span class="comment">//当闲置时间超出timeBetweenEvictionRunsMillis（默认60s）时，则触发检查逻辑</span></span><br><span class="line">                        <span class="keyword">boolean</span> validate = testConnectionInternal(poolableConnection.holder, poolableConnection.conn);</span><br><span class="line">                        <span class="keyword">if</span> (!validate) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                                LOG.debug(<span class="string">"skip not validate connection."</span>);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            discardConnection(realConnection); <span class="comment">//连接不可用，同样触发discard</span></span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (removeAbandoned) &#123; <span class="comment">//若开启removeAbandoned，则把当前拿到的连接放到activeConnections里，方便后续检查（后面流程4.2体现）</span></span><br><span class="line">                StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();</span><br><span class="line">                poolableConnection.connectStackTrace = stackTrace;</span><br><span class="line">                poolableConnection.setConnectedTimeNano(); <span class="comment">//设置连接获取时间为当前时间</span></span><br><span class="line">                poolableConnection.traceEnable = <span class="keyword">true</span>; <span class="comment">//这个设置为true，则在归还该连接时会在activeConnections里清除掉该连接对象</span></span><br><span class="line"></span><br><span class="line">                activeConnectionLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    activeConnections.put(poolableConnection, PRESENT);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    activeConnectionLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.defaultAutoCommit) &#123; <span class="comment">//默认是不开事务的，所以这里是true，不会触发下面的逻辑；这个不建议手动设置默认值，一般开启事务的工作自己做或者交给第三方框架（如spring）做比较好</span></span><br><span class="line">                poolableConnection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> poolableConnection; <span class="comment">//最终返回可用连接</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述为获取连接时的流程图，首先会调用<code>init</code>进行连接池的初始化，然后运行<code>责任链</code>上的每一个<code>filter</code>，最终执行<code>getConnectionDirect</code>获取真正的连接对象，如果开启了<code>testOnBorrow</code>，则每次都会去测试连接是否可用</p>
<article class="message is-success"><div class="message-body">
<p>这也是官方<code>不建议</code>设置<code>testOnBorrow</code>为<code>true</code>的原因，影响性能，这里的测试是指测试mysql服务端的长连接是否断开，一般mysql服务端长连保活时间是<code>8h</code>，被使用一次则刷新一次使用时间，若一个连接距离上次被使用超过了保活时间，那么再次使用时将无法与mysql服务端通信</p>
</div></article>

<p>如果<code>testOnBorrow</code>没有被置为<code>true</code>，则会进行<code>testWhileIdle</code>的检查（这一项官方建议设置为<code>true</code>，缺省值也是<code>true</code>），检查时会判断当前连接对象距离上次被使用的时间是否超过规定检查的时间，若超过，则进行检查一次，这个检查时间通过<code>timeBetweenEvictionRunsMillis</code>来控制，默认<code>60s</code>，每个连接对象会记录下上次被使用的时间，用当前时间减去上一次的使用时间得出闲置时间，闲置时间再跟<code>timeBetweenEvictionRunsMillis</code>比较，超过这个时间就做一次连接可用性检查，这个相比<code>testOnBorrow</code>每次都检查来说，性能会提升很多，用的时候无需关注该值，因为缺省值是<code>true</code>，经测试如果将该值设置为<code>false</code>，<code>testOnBorrow</code>也设置为<code>false</code>，数据库服务端长连保活时间改为60s，60s内不使用连接，超过60s后使用将会报连接错误。若使用<code>testConnectionInternal</code>方法测试长连接结果为<code>false</code>，则证明该连接已被服务端断开或者有其他的网络原因导致该连接不可用，则会触发<code>discardConnection</code>进行连接回收（对应<code>流程1.4</code>，因为丢弃了一个连接，因此该方法会唤醒<code>主流程3</code>进行检查是否需要新建连接）。整个流程运行在一个死循环内，直到取到可用连接或者超过重试上限报错退出（在连接没有超过连接池上限的话，最多重试一次（重试次数默认重试1次，可以通过<code>notFullTimeoutRetryCount</code>属性来控制），所以取连接这里一旦发生等待，在连接池没有满的情况下，最大等待<code>2 × maxWait</code>的时间 ←这个有待验证）。</p>
<article class="message is-info"><div class="message-header">
<p>特别说明项</p>
</div><div class="message-body">

<ol>
<li>为了保证性能，不建议将<code>testOnBorrow</code>设置为<code>true</code>，或者说牵扯到长连接可用检测的那几项配置使用druid默认的配置就可以保证性能是最好的，如上所说，默认长连接检查是60s一次，所以不启用<code>testOnBorrow</code>的情况下要想保证万无一失，自己要确认下所连的那个mysql服务端的长连接保活时间（虽然默认是8h，但是dba可能给测试环境设置的时间远小于这个时间，所以如果这个时间小于60s，就需要手动设置<code>timeBetweenEvictionRunsMillis</code>了，如果mysql服务端长连接时间是8h或者更长，则用默认值即可。</li>
<li>为了防止不必要的扩容，在mysql服务端长连接够用的情况下，对于一些qps较高的服务、网关业务，建议把池子的最小闲置连接数<code>minIdle</code>和最大连接数<code>maxActive</code>设置成一样的，且按照需要调大，且开启<code>keepAlive</code>进行连接活性检查（参考<code>流程4.1</code>），这样就不会后期发生动态新建连接的情况（建连还是个比较重的操作，所以不如一开始就申请好所有需要的连接，个人意见，仅供参考），但是像管理后台这种，长期qps非常低，但是有的时候需要用管理后台做一些巨大的操作（比如导数据什么的）导致需要的连接暴增，且管理后台不会特别要求性能，就适合将<code>minIdle</code>的值设置的比<code>maxActive</code>小，这样不会造成不必要的连接浪费，也不会在需要暴增连接的时候无法动态扩增连接。</div></article></li>
</ol>
<h2 id="二、主流程2：初始化连接池"><a href="#二、主流程2：初始化连接池" class="headerlink" title="二、主流程2：初始化连接池"></a>二、主流程2：初始化连接池</h2><p>通过上面的流程图可以看到，在获取一个连接的时候首先会检查连接池是否已经初始化完毕（通过<code>inited</code>来控制，<code>bool类型</code>，未初始化为<code>flase</code>，初始化完毕为<code>true</code>，这个判断过程在<code>init方法</code>内完成），若没有初始化，则调用init进行初始化（图<code>主流程1</code>中的紫色部分），下面来看看<code>init方法</code>里又做了哪些操作：</p>
<p><img src="http://myblog.sharemer.com/2019/08/28/20190828-2-3.png?imageView2/0/w/1024" alt="主流程2" title="主流程2"></p>
<p>上述流程对应源代码如下（请展开）：</p>
<figure class="highlight java"><figcaption><span>代码段2-1 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inited) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//如果已经被初始化过，则终止该方法</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bug fixed for dead lock, for issue #2980</span></span><br><span class="line">        DruidDriver.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock; <span class="comment">//获取重入锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lockInterruptibly();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"interrupt"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (inited) &#123; <span class="comment">//双重检查</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            initStackTrace = Utils.toString(Thread.currentThread().getStackTrace());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.id = DruidDriver.createDataSourceId(); <span class="comment">//生成连接池id</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.id &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//生成其他对象的id，比如连接对象的id、statement对象的id</span></span><br><span class="line">                <span class="keyword">long</span> delta = (<span class="keyword">this</span>.id - <span class="number">1</span>) * <span class="number">100000</span>;</span><br><span class="line">                <span class="keyword">this</span>.connectionIdSeedUpdater.addAndGet(<span class="keyword">this</span>, delta);</span><br><span class="line">                <span class="keyword">this</span>.statementIdSeedUpdater.addAndGet(<span class="keyword">this</span>, delta);</span><br><span class="line">                <span class="keyword">this</span>.resultSetIdSeedUpdater.addAndGet(<span class="keyword">this</span>, delta);</span><br><span class="line">                <span class="keyword">this</span>.transactionIdSeedUpdater.addAndGet(<span class="keyword">this</span>, delta);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.jdbcUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.jdbcUrl = <span class="keyword">this</span>.jdbcUrl.trim();</span><br><span class="line">                initFromWrapDriverUrl(); <span class="comment">//jdbc url的头必须是jdbc:wrap-jdbc才会触发该方法里的逻辑（这个头貌似是oracle的？本篇文章仅针对mysql）</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Filter filter : filters) &#123;</span><br><span class="line">                filter.init(<span class="keyword">this</span>); <span class="comment">//通过池对象初始化filters（因为filter里面可能会用到一些池属性）</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.dbType == <span class="keyword">null</span> || <span class="keyword">this</span>.dbType.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.dbType = JdbcUtils.getDbType(jdbcUrl, <span class="keyword">null</span>); <span class="comment">//根据jdbc协议头分析出当前数据库的类型（本文默认mysql）</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (JdbcConstants.MYSQL.equals(<span class="keyword">this</span>.dbType)</span><br><span class="line">                    || JdbcConstants.MARIADB.equals(<span class="keyword">this</span>.dbType)</span><br><span class="line">                    || JdbcConstants.ALIYUN_ADS.equals(<span class="keyword">this</span>.dbType)) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> cacheServerConfigurationSet = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.connectProperties.containsKey(<span class="string">"cacheServerConfiguration"</span>)) &#123;</span><br><span class="line">                    cacheServerConfigurationSet = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.jdbcUrl.indexOf(<span class="string">"cacheServerConfiguration"</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    cacheServerConfigurationSet = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cacheServerConfigurationSet) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.connectProperties.put(<span class="string">"cacheServerConfiguration"</span>, <span class="string">"true"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//下面就是对设置的这些属性合理性的判断，不符合要求的将直接抛异常</span></span><br><span class="line">            <span class="keyword">if</span> (maxActive &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"illegal maxActive "</span> + maxActive);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (maxActive &lt; minIdle) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"illegal maxActive "</span> + maxActive);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (getInitialSize() &gt; maxActive) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"illegal initialSize "</span> + <span class="keyword">this</span>.initialSize + <span class="string">", maxActive "</span> + maxActive);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timeBetweenLogStatsMillis &gt; <span class="number">0</span> &amp;&amp; useGlobalDataSourceStat) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeBetweenLogStatsMillis not support useGlobalDataSourceStat=true"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (maxEvictableIdleTimeMillis &lt; minEvictableIdleTimeMillis) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"maxEvictableIdleTimeMillis must be grater than minEvictableIdleTimeMillis"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.driverClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.driverClass = driverClass.trim();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过SPI机制加载责任链上需要执行的filter，方法详情在下面</span></span><br><span class="line">            initFromSPIServiceLoader();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果driver为空，加载驱动，最终将加载到的驱动注册到DriverManager上去</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.driver == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.driverClass == <span class="keyword">null</span> || <span class="keyword">this</span>.driverClass.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.driverClass = JdbcUtils.getDriverClassName(<span class="keyword">this</span>.jdbcUrl); <span class="comment">//在driverClass不配置的情况下，druid会通过url来判定属于哪个driverClass</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (MockDriver<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>().<span class="title">equals</span>(<span class="title">driverClass</span>)) </span>&#123; <span class="comment">//忽略</span></span><br><span class="line">                    driver = MockDriver.instance;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (jdbcUrl == <span class="keyword">null</span> &amp;&amp; (driverClass == <span class="keyword">null</span> || driverClass.length() == <span class="number">0</span>)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"url not set"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    driver = JdbcUtils.createDriver(driverClassLoader, driverClass); <span class="comment">//driverClass不为空的情况下直接触发驱动加载</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//除非手动设置驱动，否则不会走这里的逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.driverClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.driverClass = driver.getClass().getName();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            initCheck(); <span class="comment">//根据dbType的不同，来初始化一些标记字段（比如isMySql）</span></span><br><span class="line"></span><br><span class="line">            initExceptionSorter(); <span class="comment">//异常处理器初始化</span></span><br><span class="line">            initValidConnectionChecker(); <span class="comment">//初始化长连接检测时所需要用到的checker的适配类型，具体实现在下面</span></span><br><span class="line">            validationQueryCheck(); <span class="comment">//简单的检测validationQuery参数是否填写了，若没填写会打印一个错误日志，不影响主流程</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isUseGlobalDataSourceStat()) &#123; <span class="comment">//默认不开启，忽略</span></span><br><span class="line">                dataSourceStat = JdbcDataSourceStat.getGlobal();</span><br><span class="line">                <span class="keyword">if</span> (dataSourceStat == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    dataSourceStat = <span class="keyword">new</span> JdbcDataSourceStat(<span class="string">"Global"</span>, <span class="string">"Global"</span>, <span class="keyword">this</span>.dbType);</span><br><span class="line">                    JdbcDataSourceStat.setGlobal(dataSourceStat);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dataSourceStat.getDbType() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    dataSourceStat.setDbType(<span class="keyword">this</span>.dbType);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dataSourceStat = <span class="keyword">new</span> JdbcDataSourceStat(<span class="keyword">this</span>.name, <span class="keyword">this</span>.jdbcUrl, <span class="keyword">this</span>.dbType, <span class="keyword">this</span>.connectProperties);</span><br><span class="line">            &#125;</span><br><span class="line">            dataSourceStat.setResetStatEnable(<span class="keyword">this</span>.resetStatEnable);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//下面三个数组都跟池子本身有关系，所以容量为maxActive</span></span><br><span class="line">            connections = <span class="keyword">new</span> DruidConnectionHolder[maxActive]; <span class="comment">//初始化连接池本体</span></span><br><span class="line">            evictConnections = <span class="keyword">new</span> DruidConnectionHolder[maxActive]; <span class="comment">//初始化丢弃连接数组（流程4.1需要用到）</span></span><br><span class="line">            keepAliveConnections = <span class="keyword">new</span> DruidConnectionHolder[maxActive]; <span class="comment">//初始化需要检测可用性连接数组（流程4.1要用）</span></span><br><span class="line"></span><br><span class="line">            SQLException connectError = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (createScheduler != <span class="keyword">null</span> &amp;&amp; asyncInit) &#123; <span class="comment">//另外一种通过线程池管理连接池的方式，默认不启用，忽略</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initialSize; ++i) &#123;</span><br><span class="line">                    createTaskCount++;</span><br><span class="line">                    CreateConnectionTask task = <span class="keyword">new</span> CreateConnectionTask(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">this</span>.createSchedulerFuture = createScheduler.submit(task);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!asyncInit) &#123;</span><br><span class="line">                <span class="comment">// init connections</span></span><br><span class="line">                <span class="keyword">while</span> (poolingCount &lt; initialSize) &#123; <span class="comment">//当池子里的连接数少于需要初始化的个数时，则需要不断新增连接填充连接池，直到等于初始化连接数</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        PhysicalConnectionInfo pyConnectInfo = createPhysicalConnection(); <span class="comment">//直接通过驱动程序创建连接对象，参考流程2.1</span></span><br><span class="line">                        DruidConnectionHolder holder = <span class="keyword">new</span> DruidConnectionHolder(<span class="keyword">this</span>, pyConnectInfo); <span class="comment">//拿着驱动连接包装成holder对象</span></span><br><span class="line">                        connections[poolingCount++] = holder; <span class="comment">//生成好的连接直接往后排</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                        LOG.error(<span class="string">"init datasource error, url: "</span> + <span class="keyword">this</span>.getUrl(), ex);</span><br><span class="line">                        <span class="keyword">if</span> (initExceptionThrow) &#123;</span><br><span class="line">                            connectError = ex;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">3000</span>); <span class="comment">//异常报错后会休眠3s来进行下次的添加</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (poolingCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    poolingPeak = poolingCount;</span><br><span class="line">                    poolingPeakTime = System.currentTimeMillis();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            createAndLogThread(); <span class="comment">//开启打印log日志的守护线程</span></span><br><span class="line">            createAndStartCreatorThread(); <span class="comment">//开启负责新增连接的守护线程（主流程3）</span></span><br><span class="line">            createAndStartDestroyThread(); <span class="comment">//开启负责丢弃连接的守护线程（主流程4）</span></span><br><span class="line"></span><br><span class="line">            initedLatch.await(); <span class="comment">//倒计数器，用来保证上面的主流程3和4两个守护线程全部开启完毕后才进行接下来的操作</span></span><br><span class="line">            init = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            initedTime = <span class="keyword">new</span> Date();</span><br><span class="line">            registerMbean();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (connectError != <span class="keyword">null</span> &amp;&amp; poolingCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> connectError;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (keepAlive) &#123;</span><br><span class="line">                <span class="comment">// async fill to minIdle</span></span><br><span class="line">                <span class="keyword">if</span> (createScheduler != <span class="keyword">null</span>) &#123; <span class="comment">//默认不启用该模式，忽略</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minIdle; ++i) &#123;</span><br><span class="line">                        createTaskCount++;</span><br><span class="line">                        CreateConnectionTask task = <span class="keyword">new</span> CreateConnectionTask(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">this</span>.createSchedulerFuture = createScheduler.submit(task);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.emptySignal(); <span class="comment">//keepAlive=true，主动唤起主流程3一次</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            LOG.error(<span class="string">"&#123;dataSource-"</span> + <span class="keyword">this</span>.getID() + <span class="string">"&#125; init error"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e)&#123;</span><br><span class="line">            LOG.error(<span class="string">"&#123;dataSource-"</span> + <span class="keyword">this</span>.getID() + <span class="string">"&#125; init error"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Error e)&#123;</span><br><span class="line">            LOG.error(<span class="string">"&#123;dataSource-"</span> + <span class="keyword">this</span>.getID() + <span class="string">"&#125; init error"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            inited = <span class="keyword">true</span>; <span class="comment">//初始化完成后置为true</span></span><br><span class="line">            lock.unlock(); <span class="comment">//释放锁</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (init &amp;&amp; LOG.isInfoEnabled()) &#123;</span><br><span class="line">                String msg = <span class="string">"&#123;dataSource-"</span> + <span class="keyword">this</span>.getID();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.name != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.name.isEmpty()) &#123;</span><br><span class="line">                    msg += <span class="string">","</span>;</span><br><span class="line">                    msg += <span class="keyword">this</span>.name;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                msg += <span class="string">"&#125; inited"</span>;</span><br><span class="line"></span><br><span class="line">                LOG.info(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initFromSPIServiceLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (loadSpifilterSkip) &#123; <span class="comment">//默认不跳过SPI加载</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (autoFilters == <span class="keyword">null</span>) &#123;</span><br><span class="line">            List filters = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            ServiceLoader autoFilterLoader = ServiceLoader.load(Filter<span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">//加载Filter的实现</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Filter filter : autoFilterLoader) &#123;</span><br><span class="line">                AutoLoad autoLoad = filter.getClass().getAnnotation(AutoLoad<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span> (autoLoad != <span class="keyword">null</span> &amp;&amp; autoLoad.value()) &#123;</span><br><span class="line">                    filters.add(filter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            autoFilters = filters;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Filter filter : autoFilters) &#123;</span><br><span class="line">            <span class="keyword">if</span> (LOG.isInfoEnabled()) &#123;</span><br><span class="line">                LOG.info(<span class="string">"load filter from spi :"</span> + filter.getClass().getName());</span><br><span class="line">            &#125;</span><br><span class="line">            addFilter(filter); <span class="comment">//把通过SPI机制加载到的filter放到池子的filters里，用于后续责任链触发</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initValidConnectionChecker</span><span class="params">()</span> </span>&#123; <span class="comment">//初始化checker</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.validConnectionChecker != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String realDriverClassName = driver.getClass().getName(); <span class="comment">//根据驱动的class名称，来适配具体的checker实现</span></span><br><span class="line">        <span class="keyword">if</span> (JdbcUtils.isMySqlDriver(realDriverClassName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.validConnectionChecker = <span class="keyword">new</span> MySqlValidConnectionChecker(); <span class="comment">//假设是mysql类型的驱动，那么适配到mysql的checker，MySqlValidConnectionChecker的构造器参考下面的方法</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (realDriverClassName.equals(JdbcConstants.ORACLE_DRIVER)</span><br><span class="line">                || realDriverClassName.equals(JdbcConstants.ORACLE_DRIVER2)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.validConnectionChecker = <span class="keyword">new</span> OracleValidConnectionChecker();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (realDriverClassName.equals(JdbcConstants.SQL_SERVER_DRIVER)</span><br><span class="line">                || realDriverClassName.equals(JdbcConstants.SQL_SERVER_DRIVER_SQLJDBC4)</span><br><span class="line">                || realDriverClassName.equals(JdbcConstants.SQL_SERVER_DRIVER_JTDS)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.validConnectionChecker = <span class="keyword">new</span> MSSQLValidConnectionChecker();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (realDriverClassName.equals(JdbcConstants.POSTGRESQL_DRIVER)</span><br><span class="line">                || realDriverClassName.equals(JdbcConstants.ENTERPRISEDB_DRIVER)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.validConnectionChecker = <span class="keyword">new</span> PGValidConnectionChecker();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Mysql对应的checker构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySqlValidConnectionChecker</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = Utils.loadClass(<span class="string">"com.mysql.jdbc.MySQLConnection"</span>);</span><br><span class="line">            <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">                clazz = Utils.loadClass(<span class="string">"com.mysql.cj.jdbc.ConnectionImpl"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果驱动程序本身有ping方法，则下面的usePingMethod设置为true，后续连接保活测试就会采用ping.invoke的方式触发。</span></span><br><span class="line">                ping = clazz.getMethod(<span class="string">"pingInternal"</span>, <span class="keyword">boolean</span><span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ping != <span class="keyword">null</span>) &#123;</span><br><span class="line">                usePingMethod = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOG.warn(<span class="string">"Cannot resolve com.mysql.jdbc.Connection.ping method.  Will use 'SELECT 1' instead."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        configFromProperties(System.getProperties());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，实例化的时候会初始化全局的<code>重入锁lock</code>，在初始化过程中包括后续的连接池操作都会利用该锁保证线程安全，初始化连接池的时候首先会进行双重检查是否已经初始化过，若没有，则进行连接池的初始化，这时候还会通过<code>SPI机制</code>额外加载责任链上的<code>filter</code>，但是这类filter需要在类上加上<code>@AutoLoad</code>注解。然后初始化了三个数组，容积都为<code>maxActive</code>，首先<code>connections</code>就是用来存放池子里连接对象的，<code>evictConnections</code>用来存放每次检查需要抛弃的连接（结合<code>流程4.1</code>理解），<code>keepAliveConnections</code>用于存放需要连接检查的存活连接（同样结合<code>流程4.1</code>理解），然后生成初始化数（<code>initialSize</code>）个连接，放进<code>connections</code>，然后生成两个必须的守护线程，用来添加连接进池以及从池子里摘除不需要的连接，这俩过程较复杂，因此拆出来单说（<code>主流程3</code>和<code>主流程4</code>）。</p>
<article class="message is-info"><div class="message-header">
<p>特别说明项</p>
</div><div class="message-body">

<ol>
<li><p>从流程上看如果一开始实例化的时候不对连接池进行初始化（这个初始化是指对池子本身的初始化，并非单纯的指druid对象属性的初始化），那么在第一次调用<code>getConnection</code>时就会走上图那么多逻辑，尤其是耗时较久的建立连接操作，被重复执行了很多次，导致第一次<code>getConnection</code>时耗时过久，如果你的程序并发量很大，那么第一次获取连接时就会因为初始化流程而发生排队，所以建议在实例化连接池后对其进行<code>预热</code>，通过调用<code>init方法</code>或者<code>getConnection</code>方法都可以。</p>
</li>
<li><p>在构建全局重入锁的时候，利用<code>lock</code>对象生成了俩<code>Condition</code>，对这俩<code>Condition</code>解释如下：</p>
<p>当连接池连接够用时，利用<code>empty阻塞</code>添加连接的守护线程（<code>主流程3</code>），当连接池连接不够用时，获取连接的那个线程（这里记为<code>业务线程A</code>）就会<code>阻塞</code>在<code>notEmpty</code>上，且<code>唤起</code>阻塞在<code>empty</code>上的<code>添加连接的守护线程</code>，走完添加连接的流程，走完后会<code>重新唤起</code>阻塞在<code>notEmpty</code>上的<code>业务线程A</code>，<code>业务线程A</code>就会继续尝试获取连接。</p>
</li>
</ol>
</div></article>

<h2 id="三、流程1-1：责任链"><a href="#三、流程1-1：责任链" class="headerlink" title="三、流程1.1：责任链"></a>三、流程1.1：责任链</h2><article class="message is-danger"><div class="message-body">
<p>⚠️ 这块东西结合源码看更容易理解</p>
</div></article>

<p><img src="http://myblog.sharemer.com/2019/08/28/20190828-2-4.png?imageView2/0/w/1024" alt="流程1.1" title="流程1.1"></p>
<p>上述流程对应源代码如下（请展开）：</p>
<figure class="highlight java"><figcaption><span>代码段-1-2 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//DruidDataSource类里的方法：获取连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DruidPooledConnection <span class="title">getConnection</span><span class="params">(<span class="keyword">long</span> maxWaitMillis)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (filters.size() &gt; <span class="number">0</span>) &#123; <span class="comment">//责任链上的filter存在</span></span><br><span class="line">            FilterChainImpl filterChain = <span class="keyword">new</span> FilterChainImpl(<span class="keyword">this</span>); <span class="comment">//该类是执行整个责任链的执行者</span></span><br><span class="line">            <span class="keyword">return</span> filterChain.dataSource_connect(<span class="keyword">this</span>, maxWaitMillis); <span class="comment">//每个需要执行责任链的方法，在filterChain里都可以找到映射方法，比如本方法getConnection，就对应filterChain.dataSource_connect（参考流程1.1）</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getConnectionDirect(maxWaitMillis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//FilterChainImpl类里的方法：获取连接映射方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DruidPooledConnection <span class="title">dataSource_connect</span><span class="params">(DruidDataSource dataSource, <span class="keyword">long</span> maxWaitMillis)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.pos &lt; filterSize) &#123;</span><br><span class="line">            <span class="comment">//除了FilterChainImpl里面包含一些datasource的映射方法，需要执行的filter里面也包括，比如下面的dataSource_getConnection方法</span></span><br><span class="line">            DruidPooledConnection conn = nextFilter().dataSource_getConnection(<span class="keyword">this</span>, dataSource, maxWaitMillis); <span class="comment">//根据下标，获取下一个filter，触发目标方法</span></span><br><span class="line">            <span class="keyword">return</span> conn;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dataSource.getConnectionDirect(maxWaitMillis); <span class="comment">//执行到最后一个filter时，触发datasource，返回真正的连接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//FilterChainImpl类里的方法：获取下一个需要执行的filter</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Filter <span class="title">nextFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getFilters()</span><br><span class="line">                .get(pos++); <span class="comment">//根据游标计算</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//随便找了一个filter里的目标方法</span></span><br><span class="line">    <span class="comment">//LogFilter类里的方法：dataSource_getConnection</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DruidPooledConnection <span class="title">dataSource_getConnection</span><span class="params">(FilterChain chain, DruidDataSource dataSource,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                          <span class="keyword">long</span> maxWaitMillis)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        DruidPooledConnection conn = chain.dataSource_connect(dataSource, maxWaitMillis); <span class="comment">//这里又会利用FilterChainImpl触发映射方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面就是自己内部的一些特有逻辑，忽略</span></span><br><span class="line">        ConnectionProxy connection = (ConnectionProxy) conn.getConnectionHolder().getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (connectionConnectAfterLogEnable &amp;&amp; isConnectionLogEnabled()) &#123;</span><br><span class="line">            connectionLog(<span class="string">"&#123;conn-"</span> + connection.getId() + <span class="string">"&#125; pool-connect"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> conn; <span class="comment">//返回</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里对应<code>流程1</code>里获取连接时需要执行的责任链，每个<code>DruidAbstractDataSource</code>里都包含<code>filters</code>属性，<code>filters</code>是对Druid里<code>Filters</code>接口的实现，里面有很多对应着连接池里的映射方法，比如例子中<code>dataSource</code>的<code>getConnection</code>方法在触发的时候就会利用<code>FilterChain</code>把每个<code>filter</code>里的<code>dataSource_getConnection</code>给执行一遍，这里也要说明下<code>FilterChain</code>，通过<code>流程1.1</code>可以看出来，datasource是利用<code>FilterChain</code>来触发各个filter的执行的，<code>FilterChain</code>里也有一堆<code>datasource</code>里的映射方法，比如上图里的<code>dataSource_connect</code>，这个方法会把datasource里的<code>filters</code>全部执行一遍直到<code>nextFilter</code>取不到值，才会触发<code>dataSource.getConnectionDirect</code>，这个结合代码会比较容易理解。</p>
<h2 id="四、流程1-2：从池中获取连接的流程"><a href="#四、流程1-2：从池中获取连接的流程" class="headerlink" title="四、流程1.2：从池中获取连接的流程"></a>四、流程1.2：从池中获取连接的流程</h2><p><img src="http://myblog.sharemer.com/2019/08/28/20190828-2-5.png?imageView2/0/w/1024" alt="流程1.2" title="流程1.2"></p>
<p>上述流程对应源代码如下（请展开）：</p>
<figure class="highlight java"><figcaption><span>代码段1-3 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DruidPooledConnection <span class="title">getConnectionInternal</span><span class="params">(<span class="keyword">long</span> maxWait)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//可用性判断</span></span><br><span class="line">        <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">            connectErrorCountUpdater.incrementAndGet(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> DataSourceClosedException(<span class="string">"dataSource already closed at "</span> + <span class="keyword">new</span> Date(closeTimeMillis));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!enable) &#123;</span><br><span class="line">            connectErrorCountUpdater.incrementAndGet(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> DataSourceDisableException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> nanos = TimeUnit.MILLISECONDS.toNanos(maxWait); <span class="comment">//纳秒</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> maxWaitThreadCount = <span class="keyword">this</span>.maxWaitThreadCount; <span class="comment">//目前因为拿不到连接而发生阻塞的业务线程数</span></span><br><span class="line"></span><br><span class="line">        DruidConnectionHolder holder;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">boolean</span> createDirect = <span class="keyword">false</span>;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (createDirect) &#123; <span class="comment">//模式未启用，恒等false，下面的逻辑不会触发，所以为了方便阅读，隐藏这部分代码</span></span><br><span class="line">                <span class="comment">//代码隐藏</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lockInterruptibly(); <span class="comment">//锁获取</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                connectErrorCountUpdater.incrementAndGet(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"interrupt"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (maxWaitThreadCount &gt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; notEmptyWaitThreadCount &gt;= maxWaitThreadCount) &#123; <span class="comment">//如果因为拿不到连接而阻塞的业务线程数达到阈值，则直接抛异常</span></span><br><span class="line">                    connectErrorCountUpdater.incrementAndGet(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"maxWaitThreadCount "</span> + maxWaitThreadCount + <span class="string">", current wait Thread count "</span></span><br><span class="line">                            + lock.getQueueLength());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (onFatalError</span><br><span class="line">                        &amp;&amp; onFatalErrorMaxActive &gt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; activeCount &gt;= onFatalErrorMaxActive) &#123;</span><br><span class="line">                    connectErrorCountUpdater.incrementAndGet(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                    StringBuilder errorMsg = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    errorMsg.append(<span class="string">"onFatalError, activeCount "</span>)</span><br><span class="line">                            .append(activeCount)</span><br><span class="line">                            .append(<span class="string">", onFatalErrorMaxActive "</span>)</span><br><span class="line">                            .append(onFatalErrorMaxActive);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (lastFatalErrorTimeMillis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        errorMsg.append(<span class="string">", time '"</span>)</span><br><span class="line">                                .append(StringUtils.formatDateTime19(</span><br><span class="line">                                        lastFatalErrorTimeMillis, TimeZone.getDefault()))</span><br><span class="line">                                .append(<span class="string">"'"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (lastFatalErrorSql != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        errorMsg.append(<span class="string">", sql \n"</span>)</span><br><span class="line">                                .append(lastFatalErrorSql);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(</span><br><span class="line">                            errorMsg.toString(), lastFatalError);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                connectCount++; <span class="comment">//连接数累加</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (createScheduler != <span class="keyword">null</span></span><br><span class="line">                        &amp;&amp; poolingCount == <span class="number">0</span></span><br><span class="line">                        &amp;&amp; activeCount &lt; maxActive</span><br><span class="line">                        &amp;&amp; creatingCountUpdater.get(<span class="keyword">this</span>) == <span class="number">0</span></span><br><span class="line">                        &amp;&amp; createScheduler <span class="keyword">instanceof</span> ScheduledThreadPoolExecutor) &#123;</span><br><span class="line">                    ScheduledThreadPoolExecutor executor = (ScheduledThreadPoolExecutor) createScheduler;</span><br><span class="line">                    <span class="keyword">if</span> (executor.getQueue().size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        createDirect = <span class="keyword">true</span>; <span class="comment">//createScheduler这种异步添加模式不开启（默认不开启，本文也不是基于该模式的），createDirect永远不等于true，所以上面createDirect==true的代码不会被触发</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (maxWait &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    holder = pollLast(nanos); <span class="comment">//尝试从池子里获取连接</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    holder = takeLast();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    activeCount++; <span class="comment">//拿到连接，activeCount累加</span></span><br><span class="line">                    <span class="keyword">if</span> (activeCount &gt; activePeak) &#123;</span><br><span class="line">                        activePeak = activeCount;</span><br><span class="line">                        activePeakTime = System.currentTimeMillis();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                connectErrorCountUpdater.incrementAndGet(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                connectErrorCountUpdater.incrementAndGet(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123; <span class="comment">//没有获取到连接，整理错误信息，抛出错误</span></span><br><span class="line">            <span class="keyword">long</span> waitNanos = waitNanosLocal.get();</span><br><span class="line"></span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line">            buf.append(<span class="string">"wait millis "</span>)<span class="comment">//</span></span><br><span class="line">                    .append(waitNanos / (<span class="number">1000</span> * <span class="number">1000</span>))<span class="comment">//</span></span><br><span class="line">                    .append(<span class="string">", active "</span>).append(activeCount)<span class="comment">//</span></span><br><span class="line">                    .append(<span class="string">", maxActive "</span>).append(maxActive)<span class="comment">//</span></span><br><span class="line">                    .append(<span class="string">", creating "</span>).append(creatingCount)<span class="comment">//</span></span><br><span class="line">            ;</span><br><span class="line">            <span class="keyword">if</span> (creatingCount &gt; <span class="number">0</span> &amp;&amp; createStartNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> createElapseMillis = (System.nanoTime() - createStartNanos) / (<span class="number">1000</span> * <span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">if</span> (createElapseMillis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buf.append(<span class="string">", createElapseMillis "</span>).append(createElapseMillis);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (createErrorCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                buf.append(<span class="string">", createErrorCount "</span>).append(createErrorCount);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List sqlList = <span class="keyword">this</span>.getDataSourceStat().getRuningSqlList();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sqlList.size(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                    buf.append(<span class="string">'\n'</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    buf.append(<span class="string">", "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                JdbcSqlStatValue sql = sqlList.get(i);</span><br><span class="line">                buf.append(<span class="string">"runningSqlCount "</span>).append(sql.getRunningCount());</span><br><span class="line">                buf.append(<span class="string">" : "</span>);</span><br><span class="line">                buf.append(sql.getSql());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String errorMessage = buf.toString();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.createError != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> GetConnectionTimeoutException(errorMessage, createError);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> GetConnectionTimeoutException(errorMessage);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        holder.incrementUseCount();</span><br><span class="line"></span><br><span class="line">        DruidPooledConnection poolalbeConnection = <span class="keyword">new</span> DruidPooledConnection(holder); <span class="comment">//包装成目标对象</span></span><br><span class="line">        <span class="keyword">return</span> poolalbeConnection; <span class="comment">//返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试从池子里获取连接</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> DruidConnectionHolder <span class="title">pollLast</span><span class="params">(<span class="keyword">long</span> nanos)</span> <span class="keyword">throws</span> InterruptedException, SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> estimate = nanos;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (poolingCount == <span class="number">0</span>) &#123; <span class="comment">//池子里的空闲连接为0，说明需要通知主流程3新增连接了</span></span><br><span class="line">                emptySignal(); <span class="comment">// empty.signal，唤起主流程3新增连接</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (failFast &amp;&amp; isFailContinuous()) &#123; <span class="comment">//如果置为快速结束，则不阻塞业务线程，直接抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> DataSourceNotAvailableException(createError);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (estimate &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    waitNanosLocal.set(nanos - estimate);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                notEmptyWaitThreadCount++; <span class="comment">//因为获取不到连接而陷入阻塞状态的业务线程数+1</span></span><br><span class="line">                <span class="keyword">if</span> (notEmptyWaitThreadCount &gt; notEmptyWaitThreadPeak) &#123;</span><br><span class="line">                    notEmptyWaitThreadPeak = notEmptyWaitThreadCount;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">long</span> startEstimate = estimate;</span><br><span class="line">                    estimate = notEmpty.awaitNanos(estimate); <span class="comment">// 阻塞（挂起）estimate这么长的世界，期间如果被唤醒，则estimate就会被刷新成剩余等待时间</span></span><br><span class="line">                    <span class="comment">// recycle or</span></span><br><span class="line">                    <span class="comment">// creator</span></span><br><span class="line">                    notEmptyWaitCount++;</span><br><span class="line">                    notEmptyWaitNanos += (startEstimate - estimate);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!enable) &#123;</span><br><span class="line">                        connectErrorCountUpdater.incrementAndGet(<span class="keyword">this</span>);</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> DataSourceDisableException();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    notEmpty.signal(); <span class="comment">// 期间线程被中断，则唤起一次其他处于阻塞状态的业务线程</span></span><br><span class="line">                    notEmptySignalCount++;</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    notEmptyWaitThreadCount--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (poolingCount == <span class="number">0</span>) &#123; <span class="comment">//依然没有竞争到</span></span><br><span class="line">                    <span class="keyword">if</span> (estimate &gt; <span class="number">0</span>) &#123; <span class="comment">//如果目标阻塞时间（maxWait）还没有用完，则继续尝试获取</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    waitNanosLocal.set(nanos - estimate);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            decrementPoolingCount(); <span class="comment">//poolingCount--</span></span><br><span class="line">            DruidConnectionHolder last = connections[poolingCount]; <span class="comment">//直接获取</span></span><br><span class="line">            connections[poolingCount] = <span class="keyword">null</span>; <span class="comment">//获取后意味着连接已被借出，原有位置置空</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> waitNanos = nanos - estimate; <span class="comment">//标记这次获取连接花了多长时间，连接够用时便为0</span></span><br><span class="line">            last.setLastNotEmptyWaitNanos(waitNanos);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> last; <span class="comment">//返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>getConnectionInternal</code>方法从池子里获取真正的连接对象，druid支持两种方式新增连接，一种是通过开启不同的守护线程通过<code>await</code>、<code>signal</code>通信实现（本文启用的方式，也是默认的方式），另一种是直接通过线程池异步新增，这个方式通过在初始化druid时传入<code>asyncInit=true</code>，再把一个线程池对象赋值给<code>createScheduler</code>，就成功启用了这种模式，没仔细研究这种方式，所以本文的流程图和代码块都会规避这个模式。</p>
<p>上面的流程很简单，连接足够时就直接<code>poolingCount-1</code>，数组取值，返回，<code>activeCount+1</code>，整体复杂度为<code>O(1)</code>，关键还是看取不到连接时的做法，取不到连接时，druid会先唤起新增连接的守护线程新增连接，然后陷入等待状态，然后唤醒该等待的点有两处，一个是用完了连接<code>recycle（主流程5）</code>进池子后触发，另外一个就是新增连接的守护线程成功新增了一个连接后触发，<code>await</code>被唤起后继续加入锁竞争，然后往下走如果发现池子里的连接数仍然是0（说明在唤醒后参与锁竞争里刚被放进来的连接又被别的线程拿去了），则继续下一次的<code>await</code>，这里采用的是<code>awaitNanos</code>方法，初始值是<code>maxWait</code>，然后下次被刷新后就是<code>maxWait</code>减去上次阻塞花费的实际时间，每次<code>await</code>的时间会逐步减少，直到归零，整体时间是约等于<code>maxWait</code>的，但实际比<code>maxActive</code>要大，因为程序本身存在耗时以及被唤醒后又要参与锁竞争导致也存在一定的耗时。</p>
<p>如果最终都没办法拿到连接则返回null出去，紧接着触发<code>主流程1</code>中的重试逻辑。</p>
<article class="message is-warning"><div class="message-header">
<p>druid如何防止在获取不到连接时阻塞过多的业务线程？</p>
</div><div class="message-body">

<p>通过上面的流程图和流程描述，如果非常极端的情况，池子里的连接完全不够用时，会阻塞过多的业务线程，甚至会阻塞超过<code>maxWait</code>这么久，有没有一种措施是可以在连接不够用的时候控制阻塞线程的个数，超过这个限制后直接报错，而不是陷入等待呢？</p>
<p>druid其实支持这种策略的，在<code>maxWaitThreadCount</code>属性为默认值（<code>-1</code>）的情况下不启用，如果<code>maxWaitThreadCount</code>配置大于0，表示启用，这是druid做的一种丢弃措施，如果你不希望在池子里的连接完全不够用导阻塞的业务线程过多，就可以考虑配置该项，这个属性的意思是说在连接不够用时最多让多少个业务线程发生阻塞，<code>流程1.2</code>的图里没有体现这个开关的用途，可以在代码里查看，每次在<code>pollLast</code>方法里陷入等待前会把属性<code>notEmptyWaitThreadCount</code>进行累加，阻塞结束后会递减，由此可见<code>notEmptyWaitThreadCount</code>就是表示当前等待可用连接时阻塞的业务线程的总个数，而<code>getConnectionInternal</code>在每次调用<code>pollLast</code>前都会判断这样一段代码：</p>
<figure class="highlight java"><figcaption><span>代码块1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (maxWaitThreadCount &gt; <span class="number">0</span> &amp;&amp; notEmptyWaitThreadCount &gt;= maxWaitThreadCount) &#123;</span><br><span class="line">                    connectErrorCountUpdater.incrementAndGet(<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"maxWaitThreadCount "</span> + maxWaitThreadCount + <span class="string">", current wait Thread count "</span></span><br><span class="line">                            + lock.getQueueLength()); <span class="comment">//直接抛异常，而不是陷入等待状态阻塞业务线程</span></span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，如果配置了<code>maxWaitThreadCount</code>所限制的等待线程个数，那么会直接判断当前陷入等待的业务线程是否超过了<code>maxWaitThreadCount</code>，一旦超过甚至不触发<code>pollLast</code>的调用（防止新增等待线程），直接抛错。</p>
<p>一般情况下不需要启用该项，一定要启用建议考虑好<code>maxWaitThreadCount</code>的取值，一般来说发生大量等待说明代码里存在不合理的地方：比如典型的连接池基本配置不合理，高qps的系统里<code>maxActive</code>配置过小；比如借出去的连接没有及时close归还；比如存在慢查询或者慢事务导致连接借出时间过久。这些要比配置<code>maxWaitThreadCount</code>更值得优先考虑，当然配置这个做一个极限保护也是没问题的，只是要结合实际情况考虑好取值。</p>
</div></article>

<h2 id="五、流程1-3：连接可用性测试"><a href="#五、流程1-3：连接可用性测试" class="headerlink" title="五、流程1.3：连接可用性测试"></a>五、流程1.3：连接可用性测试</h2><h3 id="①init-checker"><a href="#①init-checker" class="headerlink" title="①init-checker"></a>①init-checker</h3><p>讲这块的东西之前，先来了解下如何初始化检测连接用的checker，整个流程参考下图：</p>
<p><img src="http://myblog.sharemer.com/2019/08/28/20190828-2-6.png?imageView2/0/w/1024" alt="init-checker流程图" title="init-checker流程图"></p>
<blockquote>
<p>ps：上述流程对应源代码位置：<code>代码段2-1</code>中的<code>initValidConnectionChecker</code>方法与<code>MySqlValidConnectionChecker</code>构造器</p>
</blockquote>
<p>初始化<code>checker</code>发生在<code>init阶段</code>（限于篇幅，没有在<code>主流程2（init阶段）</code>里体现出来，只需要记住初始化<code>checker</code>也是发生在<code>init阶段</code>就好），druid支持多种数据库的连接源，所以checker针对不同的驱动程序都做了适配，所以才看到图中checker有不同的实现，我们根据加载到的驱动类名匹配不同的数据库checker，上图匹配至mysql的checker，checker的初始化里做了一件事情，就是判断驱动内是否有<code>ping方法</code>（<code>jdbc4</code>开始支持，<code>mysql-connector-java</code>早在<code>3.x</code>的版本就有<code>ping方法</code>的实现了），如果有，则把<code>usePingMethod</code>置为<code>true</code>，用于后续启用checker时做判断用（下面会讲，这里置为<code>true</code>，则通过<code>反射</code>的方式调用驱动程序的<code>ping方法</code>，如果为<code>false</code>，则触发普通的<code>SELECT 1</code>查询检测，<code>SELECT 1</code>就是我们非常熟悉的那个东西啦，新建<code>statement</code>，然后<code>执行SELECT 1</code>，然后再判断连接是否可用）。</p>
<h3 id="②testConnectionInternal"><a href="#②testConnectionInternal" class="headerlink" title="②testConnectionInternal"></a>②testConnectionInternal</h3><p>然后回到本节探讨的方法：<code>流程1.3</code>对应的<code>testConnectionInternal</code></p>
<p><img src="http://myblog.sharemer.com/2019/08/28/20190828-2-7.png?imageView2/0/w/1024" alt="流程1.3" title="流程1.3"></p>
<p>上述流程对应源代码如下（请展开）：</p>
<figure class="highlight java"><figcaption><span>代码段1-4 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据库连接可用性测试</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">testConnectionInternal</span><span class="params">(DruidConnectionHolder holder, Connection conn)</span> </span>&#123;</span><br><span class="line">        String sqlFile = JdbcSqlStat.getContextSqlFile();</span><br><span class="line">        String sqlName = JdbcSqlStat.getContextSqlName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sqlFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            JdbcSqlStat.setContextSqlFile(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sqlName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            JdbcSqlStat.setContextSqlName(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (validConnectionChecker != <span class="keyword">null</span>) &#123; <span class="comment">//checker不为空</span></span><br><span class="line">                <span class="comment">//checker是init（主流程2）里通过驱动进行适配的检测者，因为本篇文章基于mysql，所以假设这里适配到的checker是MySqlValidConnectionChecker类型的</span></span><br><span class="line">                <span class="keyword">boolean</span> valid = validConnectionChecker.isValidConnection(conn, validationQuery, validationQueryTimeout);</span><br><span class="line">                <span class="keyword">long</span> currentTimeMillis = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    holder.lastValidTimeMillis = currentTimeMillis;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (valid &amp;&amp; isMySql) &#123;</span><br><span class="line">                    <span class="comment">//这里在现有驱动版本的情况下拿到的lastPacketReceivedTimeMs始终小于0，因为找不到com.mysql.jdbc.MySQLConnection</span></span><br><span class="line">                    <span class="keyword">long</span> lastPacketReceivedTimeMs = MySqlUtils.getLastPacketReceivedTimeMs(conn);</span><br><span class="line">                    <span class="keyword">if</span> (lastPacketReceivedTimeMs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">long</span> mysqlIdleMillis = currentTimeMillis - lastPacketReceivedTimeMs;</span><br><span class="line">                        <span class="keyword">if</span> (lastPacketReceivedTimeMs &gt; <span class="number">0</span> <span class="comment">//</span></span><br><span class="line">                                &amp;&amp; mysqlIdleMillis &gt;= timeBetweenEvictionRunsMillis) &#123;</span><br><span class="line">                            discardConnection(conn);</span><br><span class="line">                            String errorMsg = <span class="string">"discard long time none received connection. "</span></span><br><span class="line">                                    + <span class="string">", jdbcUrl : "</span> + jdbcUrl</span><br><span class="line">                                    + <span class="string">", jdbcUrl : "</span> + jdbcUrl</span><br><span class="line">                                    + <span class="string">", lastPacketReceivedIdleMillis : "</span> + mysqlIdleMillis;</span><br><span class="line">                            LOG.error(errorMsg);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> valid; <span class="comment">//返回验证结果</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (conn.isClosed()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//checker为空时，就直接利用validationQuery进行常规测试</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == validationQuery) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//validationQuery为空就单纯返回true</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">            ResultSet rset = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stmt = conn.createStatement();</span><br><span class="line">                <span class="keyword">if</span> (getValidationQueryTimeout() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    stmt.setQueryTimeout(validationQueryTimeout);</span><br><span class="line">                &#125;</span><br><span class="line">                rset = stmt.executeQuery(validationQuery);</span><br><span class="line">                <span class="keyword">if</span> (!rset.next()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//执行检测语句失败，返回false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//关闭资源</span></span><br><span class="line">                JdbcUtils.close(rset);</span><br><span class="line">                JdbcUtils.close(stmt);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//验证通过返回true</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// skip</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sqlFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">                JdbcSqlStat.setContextSqlFile(sqlFile);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sqlName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                JdbcSqlStat.setContextSqlName(sqlName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//MySqlValidConnectionChecker类里的验证方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidConnection</span><span class="params">(Connection conn, String validateQuery, <span class="keyword">int</span> validationQueryTimeout)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (conn.isClosed()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (usePingMethod) &#123; <span class="comment">//是否启用ping方法（如果驱动程序有该方法，则这里为true，一般情况下都是true）</span></span><br><span class="line">            <span class="keyword">if</span> (conn <span class="keyword">instanceof</span> DruidPooledConnection) &#123;</span><br><span class="line">                conn = ((DruidPooledConnection) conn).getConnection();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (conn <span class="keyword">instanceof</span> ConnectionProxy) &#123;</span><br><span class="line">                conn = ((ConnectionProxy) conn).getRawObject();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (clazz.isAssignableFrom(conn.getClass())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (validationQueryTimeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    validationQueryTimeout = DEFAULT_VALIDATION_QUERY_TIMEOUT;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//ping对象是初始化时拿到驱动程序的一个Method对象，这里通过invoke触发调用</span></span><br><span class="line">                    ping.invoke(conn, <span class="keyword">true</span>, validationQueryTimeout * <span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                    Throwable cause = e.getCause();</span><br><span class="line">                    <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> SQLException) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> (SQLException) cause;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">throw</span> e; <span class="comment">//ping出错抛异常</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//通过则返回true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不支持ping方式检测，则触发SELECT 1的方式进行检测（一般情况下不会触发，都是上面ping方式）</span></span><br><span class="line">        String query = validateQuery;</span><br><span class="line">        <span class="keyword">if</span> (validateQuery == <span class="keyword">null</span> || validateQuery.isEmpty()) &#123;</span><br><span class="line">            query = DEFAULT_VALIDATION_QUERY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            <span class="keyword">if</span> (validationQueryTimeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                stmt.setQueryTimeout(validationQueryTimeout);</span><br><span class="line">            &#125;</span><br><span class="line">            rs = stmt.executeQuery(query);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtils.close(rs);</span><br><span class="line">            JdbcUtils.close(stmt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法会利用<code>主流程2</code>（<code>init阶段</code>）里初始化好的<code>checker对象</code>（流程参考<code>init-checker</code>）里的<code>isValidConnection方法</code>，如果启用<code>ping</code>，则该方法会利用<code>invoke</code>触发驱动程序里的<code>ping方法</code>，如果不启用ping，就采用<code>SELECT 1</code>方式（从<code>init-checker</code>里可以看出启不启用取决于加载到的驱动程序里是否存在相应的方法）。</p>
<h2 id="六、流程1-4：抛弃连接"><a href="#六、流程1-4：抛弃连接" class="headerlink" title="六、流程1.4：抛弃连接"></a>六、流程1.4：抛弃连接</h2><p><img src="http://myblog.sharemer.com/2019/08/28/20190828-2-8.png?imageView2/0/w/450" alt="流程1.4" title="流程1.4"></p>
<p>上述流程对应源代码如下（请展开）：</p>
<figure class="highlight java"><figcaption><span>代码段1-5 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//丢弃连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discardConnection</span><span class="params">(Connection realConnection)</span> </span>&#123;</span><br><span class="line">        JdbcUtils.close(realConnection); <span class="comment">//close掉真正的连接对象，一般调用该方法传入的connection对象都是最原始的驱动连接对象，所以这里并不会触发recycle</span></span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            activeCount--; <span class="comment">//活跃连接数-1</span></span><br><span class="line">            discardCount++; <span class="comment">//丢弃连接数+1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (activeCount &lt;= minIdle) &#123;</span><br><span class="line">                emptySignal(); <span class="comment">//唤起一次主流程3新增连接</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>经过<code>流程1.3</code>返回的测试结果，如果发现连接不可用，则直接触发抛弃连接逻辑，这个过程非常简单，如上图所示，由<code>流程1.2</code>获取到该连接时累加上去的<code>activeCount</code>，在本流程里会再次减一，表示被取出来的连接不可用，并不能active状态。其次这里的close是拿着驱动那个连接对象进行close，正常情况下一个连接对象会被druid封装成<code>DruidPooledConnection</code>对象，内部持有的<code>conn</code>就是真正的<code>驱动Connection</code>对象，上图中的关闭连接就是获取的该对象进行<code>close</code>，如果使用包装类<code>DruidPooledConnection</code>进行close，则代表回收连接对象（<code>recycle</code>，参考<code>主流程5</code>）。</p>
<h2 id="七、主流程3：添加连接的守护线程"><a href="#七、主流程3：添加连接的守护线程" class="headerlink" title="七、主流程3：添加连接的守护线程"></a>七、主流程3：添加连接的守护线程</h2><p><img src="http://myblog.sharemer.com/2019/08/28/20190828-2-9.png?imageView2/0/w/1024" alt="主流程3" title="主流程3"></p>
<p>上述流程对应源代码如下（请展开）：</p>
<figure class="highlight java"><figcaption><span>代码段3-1 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DruidDataSource的内部类，对应主流程3，用来补充连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateConnectionThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CreateConnectionThread</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name); <span class="comment">//重置线程名称</span></span><br><span class="line">            <span class="keyword">this</span>.setDaemon(<span class="keyword">true</span>); <span class="comment">//标记为守护线程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//run方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            initedLatch.countDown(); <span class="comment">//通知init（主流程2）自己已经启动成功</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> lastDiscardCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> errorCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123; <span class="comment">//死循环</span></span><br><span class="line">                <span class="comment">// addLast</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lockInterruptibly(); <span class="comment">//锁获取</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e2) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">long</span> discardCount = DruidDataSource.<span class="keyword">this</span>.discardCount;</span><br><span class="line">                <span class="comment">//当前丢弃连接数与最后一次丢弃连接数的差值大于0，说明又发生了丢弃连接的现象，该条件会促进连接的创建</span></span><br><span class="line">                <span class="keyword">boolean</span> discardChanged = discardCount - lastDiscardCount &gt; <span class="number">0</span>;</span><br><span class="line">                lastDiscardCount = discardCount;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> emptyWait = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (createError != <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; poolingCount == <span class="number">0</span></span><br><span class="line">                            &amp;&amp; !discardChanged) &#123;</span><br><span class="line">                        emptyWait = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (emptyWait</span><br><span class="line">                            &amp;&amp; asyncInit &amp;&amp; createCount &lt; initialSize) &#123;</span><br><span class="line">                        emptyWait = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (emptyWait) &#123;</span><br><span class="line">                        <span class="comment">// 必须存在线程等待，才创建连接，否则不创建</span></span><br><span class="line">                        <span class="keyword">if</span> (poolingCount &gt;= notEmptyWaitThreadCount</span><br><span class="line">                                &amp;&amp; (!(keepAlive &amp;&amp; activeCount + poolingCount &lt; minIdle))</span><br><span class="line">                                &amp;&amp; !isFailContinuous()</span><br><span class="line">                        ) &#123;</span><br><span class="line">                            empty.await(); <span class="comment">//不需要创建连接时，阻塞（挂起）</span></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 防止创建超过maxActive数量的连接</span></span><br><span class="line">                        <span class="keyword">if</span> (activeCount + poolingCount &gt;= maxActive) &#123;</span><br><span class="line">                            empty.await(); <span class="comment">//超出限制依然挂起，不再新增连接</span></span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    lastCreateError = e;</span><br><span class="line">                    lastErrorTimeMillis = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!closing) &#123;</span><br><span class="line">                        LOG.error(<span class="string">"create connection Thread Interrupted, url: "</span> + jdbcUrl, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock(); <span class="comment">//锁释放</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//从上面的程序走到这里，说明该线程被成功唤起，则进行新建连接</span></span><br><span class="line">                PhysicalConnectionInfo connection = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    connection = createPhysicalConnection(); <span class="comment">//利用驱动程序新建物理连接</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    LOG.error(<span class="string">"create connection SQLException, url: "</span> + jdbcUrl + <span class="string">", errorCode "</span> + e.getErrorCode()</span><br><span class="line">                            + <span class="string">", state "</span> + e.getSQLState(), e);</span><br><span class="line"></span><br><span class="line">                    errorCount++;</span><br><span class="line">                    <span class="keyword">if</span> (errorCount &gt; connectionErrorRetryAttempts &amp;&amp; timeBetweenConnectErrorMillis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// fail over retry attempts</span></span><br><span class="line">                        setFailContinuous(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">if</span> (failFast) &#123;</span><br><span class="line">                            lock.lock();</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                notEmpty.signalAll();</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                lock.unlock();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (breakAfterAcquireFailure) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(timeBetweenConnectErrorMillis);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException interruptEx) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                    LOG.error(<span class="string">"create connection RuntimeException"</span>, e);</span><br><span class="line">                    setFailContinuous(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">                    LOG.error(<span class="string">"create connection Error"</span>, e);</span><br><span class="line">                    setFailContinuous(<span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">//新建失败后再次尝试</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> result = put(connection); <span class="comment">//尝试放入池子</span></span><br><span class="line">                <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                    JdbcUtils.close(connection.getPhysicalConnection());</span><br><span class="line">                    LOG.info(<span class="string">"put physical connection to pool failed."</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                errorCount = <span class="number">0</span>; <span class="comment">// reset errorCount</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这一个put方法是上面触发接收PhysicalConnectionInfo类型连接用的，之前说过，最终保存在池子里的连接对象都是DruidConnectionHolder类型，所以这里时进行一次包装，然后真正put进去的是更下面的put方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(PhysicalConnectionInfo physicalConnectionInfo)</span> </span>&#123;</span><br><span class="line">        DruidConnectionHolder holder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//包装成holder类型</span></span><br><span class="line">            holder = <span class="keyword">new</span> DruidConnectionHolder(DruidDataSource.<span class="keyword">this</span>, physicalConnectionInfo);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (createScheduler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    createTaskCount--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            LOG.error(<span class="string">"create connection holder error"</span>, ex);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> put(holder); <span class="comment">//真正放入池子</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//真正将连接对象放入池子</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(DruidConnectionHolder holder)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (poolingCount &gt;= maxActive) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//如果此时发现当前池子里的闲置连接数已经超过了maxActive，那么就不再往里面加了</span></span><br><span class="line">            &#125;</span><br><span class="line">            connections[poolingCount] = holder; <span class="comment">//加在数组尾部</span></span><br><span class="line">            incrementPoolingCount(); <span class="comment">//poolingCount++</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (poolingCount &gt; poolingPeak) &#123;</span><br><span class="line">                poolingPeak = poolingCount;</span><br><span class="line">                poolingPeakTime = System.currentTimeMillis();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            notEmpty.signal(); <span class="comment">//唤起一个因为拿不到连接对象而发生阻塞的业务线程，让其再次进入运行状态，进行获取连接竞争</span></span><br><span class="line">            notEmptySignalCount++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (createScheduler != <span class="keyword">null</span>) &#123; <span class="comment">//模式未启用</span></span><br><span class="line">                createTaskCount--;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (poolingCount + createTaskCount &lt; notEmptyWaitThreadCount <span class="comment">//</span></span><br><span class="line">                        &amp;&amp; activeCount + poolingCount + createTaskCount &lt; maxActive) &#123;</span><br><span class="line">                    emptySignal();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>主流程2</code>（<code>init初始化阶段</code>）时就开启了该流程，该流程独立运行，大部分时间处于等待状态，不会抢占cpu，但是当连接不够用时，就会被唤起追加连接，成功创建连接后将会唤醒其他正在等待获取可用连接的线程，比如：</p>
<p>结合<code>流程1.2</code>来看，当连接不够用时，会通过<code>empty.signal</code>唤醒该线程进行补充连接（阻塞在<code>empty</code>上的线程只有<code>主流程3</code>的单线程），然后通过<code>notEmpty</code>阻塞自己，当该线程补充连接成功后，又会对阻塞在<code>notEmpty</code>上的线程进行唤醒，让其进入锁竞争状态，简单理解就是一个生产-消费模型。这里有一些细节，比如池子里的连接使用中（<code>activeCount</code>）加上池子里剩余连接数（<code>poolingCount</code>）就是指当前一共生成了多少个连接，这个数不能比<code>maxActive</code>还大，如果比<code>maxActive</code>还大，则再次陷入等待。而在往池子里<code>put</code>连接时，则判断<code>poolingCount</code>是否大于<code>maxActive</code>来决定最终是否入池。</p>
<h2 id="八、主流程4：抛弃连接的守护线程"><a href="#八、主流程4：抛弃连接的守护线程" class="headerlink" title="八、主流程4：抛弃连接的守护线程"></a>八、主流程4：抛弃连接的守护线程</h2><p><img src="http://myblog.sharemer.com/2019/08/28/20190828-2-10.png?imageView2/0/w/1024" alt="主流程4" title="主流程4"></p>
<p>上述流程对应源代码如下（请展开）：</p>
<figure class="highlight java"><figcaption><span>代码段4-1 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接池瘦身，参考主流程4</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DestroyConnectionThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DestroyConnectionThread</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(name); <span class="comment">//给线程重命名</span></span><br><span class="line">            <span class="keyword">this</span>.setDaemon(<span class="keyword">true</span>); <span class="comment">//标记为守护线程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//run方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            initedLatch.countDown(); <span class="comment">//通知init（主流程2）自己已经启动成功</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123; <span class="comment">//死循环</span></span><br><span class="line">                <span class="comment">// 从前面开始删除</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (timeBetweenEvictionRunsMillis &gt; <span class="number">0</span>) &#123; <span class="comment">//检查时间间隔，不启用（小于等于0时）则默认1s，事实上，druid对于该参数的缺省值是60s</span></span><br><span class="line">                        Thread.sleep(timeBetweenEvictionRunsMillis);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>); <span class="comment">//默认1s</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    destroyTask.run(); <span class="comment">//启动destroy的run方法（在下方）</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DruidDataSource内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DestroyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DestroyTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            shrink(<span class="keyword">true</span>, keepAlive); <span class="comment">//连接池的检查&amp;瘦身</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isRemoveAbandoned()) &#123; <span class="comment">//如果开启该属性，则进行强制回收检查</span></span><br><span class="line">                removeAbandoned();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="流程4-1：连接池瘦身，检查连接是否可用以及丢弃多余连接"><a href="#流程4-1：连接池瘦身，检查连接是否可用以及丢弃多余连接" class="headerlink" title="流程4.1：连接池瘦身，检查连接是否可用以及丢弃多余连接"></a>流程4.1：连接池瘦身，检查连接是否可用以及丢弃多余连接</h3><p>整个过程如下：</p>
<p><img src="http://myblog.sharemer.com/2019/08/28/20190828-2-11.png?imageView2/0/w/1024" alt="流程4.1" title="流程4.1"></p>
<p>上述流程对应源代码如下（请展开）：</p>
<figure class="highlight java"><figcaption><span>代码段-4-2 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接池瘦身</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shrink</span><span class="params">(<span class="keyword">boolean</span> checkTime, <span class="keyword">boolean</span> keepAlive)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lockInterruptibly();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> evictCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> keepAliveCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!inited) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> checkCount = poolingCount - minIdle; <span class="comment">//根据poolingCount和minIdle计算出evictCheck的范围</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> currentTimeMillis = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolingCount; ++i) &#123; <span class="comment">//开始遍历连接池里闲置的连接</span></span><br><span class="line">                DruidConnectionHolder connection = connections[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (checkTime) &#123; <span class="comment">//除非手动调用，不然经过主流程4触发，一般为true</span></span><br><span class="line">                    <span class="keyword">if</span> (phyTimeoutMillis &gt; <span class="number">0</span>) &#123; <span class="comment">//默认不启用，忽略</span></span><br><span class="line">                        <span class="keyword">long</span> phyConnectTimeMillis = currentTimeMillis - connection.connectTimeMillis;</span><br><span class="line">                        <span class="keyword">if</span> (phyConnectTimeMillis &gt; phyTimeoutMillis) &#123;</span><br><span class="line">                            evictConnections[evictCount++] = connection;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//计算闲置时间</span></span><br><span class="line">                    <span class="keyword">long</span> idleMillis = currentTimeMillis - connection.lastActiveTimeMillis;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (idleMillis &lt; minEvictableIdleTimeMillis</span><br><span class="line">                            &amp;&amp; idleMillis &lt; keepAliveBetweenTimeMillis</span><br><span class="line">                    ) &#123; <span class="comment">//如果闲置时间达不到检测&amp;瘦身的阈值，则不处理</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (idleMillis &gt;= minEvictableIdleTimeMillis) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (checkTime &amp;&amp; i &lt; checkCount) &#123; <span class="comment">//达到需要丢弃的阈值时，则判断连接下标是否在evictCheck范围，若在，则视为“可以丢弃的对象”放入evictConnections数组</span></span><br><span class="line">                            evictConnections[evictCount++] = connection;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleMillis &gt; maxEvictableIdleTimeMillis) &#123; <span class="comment">//达到必须要丢弃的阈值时，则不管是不是在evictCheck范围内，都直接放入“可以丢弃的对象”的evictConnections数组</span></span><br><span class="line">                            evictConnections[evictCount++] = connection;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//如果上面的条件均没有命中，如果keepAlive为true，则判断是不是超过了闲置连接检查其活性的频次阈值（即由keepAliveBetweenTimeMillis控制）</span></span><br><span class="line">                    <span class="keyword">if</span> (keepAlive &amp;&amp; idleMillis &gt;= keepAliveBetweenTimeMillis) &#123;</span><br><span class="line">                        keepAliveConnections[keepAliveCount++] = connection; <span class="comment">//满足条件则视为“需要检测活性的对象”，放入keepAliveConnections数组</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; checkCount) &#123;</span><br><span class="line">                        evictConnections[evictCount++] = connection;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> removeCount = evictCount + keepAliveCount; <span class="comment">//这一批需要移除特殊处理的连接总数</span></span><br><span class="line">            <span class="keyword">if</span> (removeCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.arraycopy(connections, removeCount, connections, <span class="number">0</span>, poolingCount - removeCount); <span class="comment">//根据当前移除的元素，把剩余的元素移动至数组首部（参考流程4.1）</span></span><br><span class="line">                Arrays.fill(connections, poolingCount - removeCount, poolingCount, <span class="keyword">null</span>); <span class="comment">//剩余位置清空</span></span><br><span class="line">                poolingCount -= removeCount;</span><br><span class="line">            &#125;</span><br><span class="line">            keepAliveCheckCount += keepAliveCount;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (evictCount &gt; <span class="number">0</span>) &#123; <span class="comment">//如果需要丢弃的连接数量大于0</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; evictCount; ++i) &#123;</span><br><span class="line">                DruidConnectionHolder item = evictConnections[i];</span><br><span class="line">                Connection connection = item.getConnection();</span><br><span class="line">                JdbcUtils.close(connection); <span class="comment">//直接关闭连接（这里是直接关闭驱动连接，不再放回池子）</span></span><br><span class="line">                destroyCountUpdater.incrementAndGet(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Arrays.fill(evictConnections, <span class="keyword">null</span>); <span class="comment">//将evictConnections数组重新置空（方便下次使用）</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (keepAliveCount &gt; <span class="number">0</span>) &#123; <span class="comment">//检测那些需要判活的连接数</span></span><br><span class="line">            <span class="comment">// keep order</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = keepAliveCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                DruidConnectionHolder holer = keepAliveConnections[i];</span><br><span class="line">                Connection connection = holer.getConnection();</span><br><span class="line">                holer.incrementKeepAliveCheckCount();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> validate = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.validateConnection(connection); <span class="comment">//检测其活性</span></span><br><span class="line">                    validate = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable error) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">                        LOG.debug(<span class="string">"keepAliveErr"</span>, error);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// skip</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> discard = !validate;</span><br><span class="line">                <span class="keyword">if</span> (validate) &#123; <span class="comment">//检测通过</span></span><br><span class="line">                    holer.lastKeepTimeMillis = System.currentTimeMillis();</span><br><span class="line">                    <span class="keyword">boolean</span> putOk = put(holer); <span class="comment">//检测通过后，再次放入池子</span></span><br><span class="line">                    <span class="keyword">if</span> (!putOk) &#123; <span class="comment">//放不进去池子（说明已经达到连接池最大连接数阈值maxActive），则视为可以“直接抛弃”的连接</span></span><br><span class="line">                        discard = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (discard) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        connection.close(); <span class="comment">//如果可以抛弃，则直接关闭连接（直接调用驱动的close）</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="comment">// skip</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    lock.lock();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        discardCount++; <span class="comment">//抛弃连接数累加</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (activeCount &lt;= minIdle) &#123;</span><br><span class="line">                            emptySignal(); <span class="comment">//唤起主流程3追加连接对象</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.getDataSourceStat().addKeepAliveCheckCount(keepAliveCount);</span><br><span class="line">            Arrays.fill(keepAliveConnections, <span class="keyword">null</span>); <span class="comment">//将keepAliveConnections数组重新置空（方便下次使用）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上面检测通过，再次通过该方法重新把连接放入池子</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">put</span><span class="params">(DruidConnectionHolder holder)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (poolingCount &gt;= maxActive) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//若池子内闲置连接数超过maxActive，则无法继续添加新的连接进来，返回false</span></span><br><span class="line">            &#125;</span><br><span class="line">            connections[poolingCount] = holder; <span class="comment">//否则直接把此连接对象放入连接池队尾</span></span><br><span class="line">            incrementPoolingCount(); <span class="comment">//poolingCount++</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (poolingCount &gt; poolingPeak) &#123;</span><br><span class="line">                poolingPeak = poolingCount;</span><br><span class="line">                poolingPeakTime = System.currentTimeMillis();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            notEmpty.signal(); <span class="comment">//唤起那些因获取不到可用连接而陷入阻塞状态的业务线程一次</span></span><br><span class="line">            notEmptySignalCount++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (createScheduler != <span class="keyword">null</span>) &#123; <span class="comment">//不启用该模式，忽略</span></span><br><span class="line">                createTaskCount--;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (poolingCount + createTaskCount &lt; notEmptyWaitThreadCount <span class="comment">//</span></span><br><span class="line">                        &amp;&amp; activeCount + poolingCount + createTaskCount &lt; maxActive) &#123;</span><br><span class="line">                    emptySignal();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>整个流程分成图中主要的几步，首先利用<code>poolingCount</code>减去<code>minIdle</code>计算出需要做丢弃检查的连接对象区间，意味着这个区间的对象有被丢弃的可能，具体要不要放进丢弃队列<code>evictConnections</code>，要判断两个属性：</p>
<p><code>minEvictableIdleTimeMillis</code>：最小检查间隙，缺省值<code>30min</code>，官方解释：一个连接在池中最小生存的时间（结合检查区间来看，闲置时间超过这个时间，才会被丢弃）。</p>
<p><code>maxEvictableIdleTimeMillis</code>：最大检查间隙，缺省值<code>7h</code>，官方解释：一个连接在池中最大生存的时间（无视检查区间，只要闲置时间超过这个时间，就一定会被丢弃）。</p>
<p>如果当前连接对象闲置时间超过<code>minEvictableIdleTimeMillis</code>且下标在<code>evictCheck</code>区间内，则加入丢弃队列<code>evictConnections</code>，如果闲置时间超过<code>maxEvictableIdleTimeMillis</code>，则直接放入<code>evictConnections</code>（一般情况下会命中第一个判断条件，除非一个连接不在检查区间，且闲置时间超过<code>maxEvictableIdleTimeMillis</code>）。</p>
<p>如果连接对象不在<code>evictCheck</code>区间内，且<code>keepAlive</code>属性为<code>true</code>，则判断该对象闲置时间是否超出<code>keepAliveBetweenTimeMillis</code>（缺省值<code>60s</code>），若超出，则意味着该连接需要进行连接可用性检查，则将该对象放入<code>keepAliveConnections</code>队列。</p>
<p>两个队列赋值完成后，则池子会进行一次压缩，没有涉及到的连接对象会被压缩到队首。</p>
<p>然后就是处理<code>evictConnections</code>和<code>keepAliveConnections</code>两个队列了，<code>evictConnections</code>里的对象会被close最后释放掉，<code>keepAliveConnections</code>里面的对象将会其进行检测（流程参考<code>流程1.3</code>的<code>isValidConnection</code>），碰到不可用的连接会调用<code>discard</code>（<code>流程1.4</code>）抛弃掉，可用的连接会再次被放进连接池。</p>
<p>整个流程可以看出，连接闲置后，也并非一下子就减少到<code>minIdle</code>的，如果之前产生一堆的连接（不超过<code>maxActive</code>），突然闲置了下来，则至少需要花<code>minEvictableIdleTimeMillis</code>的时间才可以被移出连接池，如果一个连接闲置时间超过<code>maxEvictableIdleTimeMillis</code>则必定被回收，所以极端情况下（比如一个连接池从初始化后就没有再被使用过），连接池里并不会一直保持<code>minIdle</code>个连接，而是一个都没有，生产环境下这是非常不常见的，默认的<code>maxEvictableIdleTimeMillis</code>都有<code>7h</code>除非是极度冷门的系统才会出现这种情况，而开启<code>keepAlive</code>也不会推翻这个规则，<code>keepAlive</code>的优先级是低于<code>maxEvictableIdleTimeMillis</code>的，<code>keepAlive</code>只是保证了那些检查中不需要被移出连接池的连接在指定检测时间内去检测其连接活性，从而决定是否放入池子或者直接<code>discard</code>。</p>
<h3 id="流程4-2：主动回收连接，防止内存泄漏"><a href="#流程4-2：主动回收连接，防止内存泄漏" class="headerlink" title="流程4.2：主动回收连接，防止内存泄漏"></a>流程4.2：主动回收连接，防止内存泄漏</h3><p>过程如下：</p>
<p><img src="http://myblog.sharemer.com/2019/08/28/20190828-2-12.png?imageView2/0/w/1024" alt="流程4.2" title="流程4.2"></p>
<p>上述流程对应源代码如下（请展开）：</p>
<figure class="highlight java"><figcaption><span>代码段4-3 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回收长期未归还的连接（再次说明：该方法仅在removeAbandoned设置为true的情况下触发）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeAbandoned</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> removeCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> currrentNanos = System.nanoTime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这个列表用于存放满足条件的真正需要强制回收的连接</span></span><br><span class="line">        List abandonedList = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">        activeConnectionLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//在removeAbandoned设置为true的情况下，所有被借出去的连接，都会被保存进activeConnections（参考主流程1），所以要进行“长期未归还”的检查，就是从activeConnections开始的</span></span><br><span class="line">            Iterator iter = activeConnections.keySet().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (; iter.hasNext();) &#123;</span><br><span class="line">                DruidPooledConnection pooledConnection = iter.next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pooledConnection.isRunning()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">//如果当前连接正在使用中（指的是正在execute），则不处理</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//利用当前时间和连接被借出去时的时间，计算出连接被借出去的时间有多久</span></span><br><span class="line">                <span class="keyword">long</span> timeMillis = (currrentNanos - pooledConnection.getConnectedTimeNano()) / (<span class="number">1000</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (timeMillis &gt;= removeAbandonedTimeoutMillis) &#123; <span class="comment">//如果连接被借出去的时间超过removeAbandonedTimeoutMillis这个阈值，将会命中“主动归还”的逻辑检查</span></span><br><span class="line">                    iter.remove(); <span class="comment">//先从activeConnections移除</span></span><br><span class="line">                    pooledConnection.setTraceEnable(<span class="keyword">false</span>); <span class="comment">//标记为false，防止回收时重复removeactiveConnections，可以参考主流程5</span></span><br><span class="line">                    abandonedList.add(pooledConnection); <span class="comment">//放入“强制回收”队列</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            activeConnectionLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (abandonedList.size() &gt; <span class="number">0</span>) &#123; <span class="comment">//如果“强制回收”队列大于0，说明有需要回收的连接</span></span><br><span class="line">            <span class="keyword">for</span> (DruidPooledConnection pooledConnection : abandonedList) &#123; <span class="comment">//循环这些连接</span></span><br><span class="line">                <span class="keyword">final</span> ReentrantLock lock = pooledConnection.lock;</span><br><span class="line">                lock.lock(); <span class="comment">//拿到连接的锁</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pooledConnection.isDisable()) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>; <span class="comment">//已经被回收的，则不管</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//触发回收连接对象（pooledConnection）里的holcder（注意这里其实是把pooledConnection对象里的holder给回收至连接池了，pooledConnection对象本身会被销毁）</span></span><br><span class="line">                JdbcUtils.close(pooledConnection); <span class="comment">//这里触发的close，是DruidPooledConnection的close，也就是会触发recycle方法的close</span></span><br><span class="line">                pooledConnection.abandond(); <span class="comment">//标记为</span></span><br><span class="line">                removeAbandonedCount++;</span><br><span class="line">                removeCount++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (isLogAbandoned()) &#123; <span class="comment">//日志打印，忽略</span></span><br><span class="line">                    StringBuilder buf = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    buf.append(<span class="string">"abandon connection, owner thread: "</span>);</span><br><span class="line">                    buf.append(pooledConnection.getOwnerThread().getName());</span><br><span class="line">                    buf.append(<span class="string">", connected at : "</span>);</span><br><span class="line">                    buf.append(pooledConnection.getConnectedTimeMillis());</span><br><span class="line">                    buf.append(<span class="string">", open stackTrace\n"</span>);</span><br><span class="line"></span><br><span class="line">                    StackTraceElement[] trace = pooledConnection.getConnectStackTrace();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; trace.length; i++) &#123;</span><br><span class="line">                        buf.append(<span class="string">"\tat "</span>);</span><br><span class="line">                        buf.append(trace[i].toString());</span><br><span class="line">                        buf.append(<span class="string">"\n"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    buf.append(<span class="string">"ownerThread current state is "</span> + pooledConnection.getOwnerThread().getState()</span><br><span class="line">                            + <span class="string">", current stackTrace\n"</span>);</span><br><span class="line">                    trace = pooledConnection.getOwnerThread().getStackTrace();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; trace.length; i++) &#123;</span><br><span class="line">                        buf.append(<span class="string">"\tat "</span>);</span><br><span class="line">                        buf.append(trace[i].toString());</span><br><span class="line">                        buf.append(<span class="string">"\n"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    LOG.error(buf.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> removeCount; <span class="comment">//返回本次被强制回收的连接个数</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个流程在<code>removeAbandoned</code>设置为<code>true</code>的情况下才会触发，用于回收那些拿出去的使用长期未归还（归还：调用<code>close</code>方法触发<code>主流程5</code>）的连接。</p>
<p>先来看看<code>activeConnections</code>是什么，<code>activeConnections</code>用来保存当前从池子里被借出去的连接，这个可以通过<code>主流程1</code>看出来，每次调用<code>getConnection</code>时，如果开启<code>removeAbandoned</code>，则会把连接对象放到<code>activeConnections</code>，然后如果长期不调用<code>close</code>，那么这个被借出去的连接将永远无法被重新放回池子，这是一件很麻烦的事情，这将存在内存泄漏的风险，因为不close，意味着池子会不断产生新的连接放进<code>connections</code>，不符合连接池预期（连接池出发点是尽可能少的创建连接），然后之前被借出去的连接对象还有一直无法被回收的风险，存在内存泄漏的风险，因此为了解决这个问题，就有了这个流程，流程整体很简单，就是将现在借出去还没有归还的连接，做一次判断，符合条件的将会被放进<code>abandonedList</code>进行连接回收（这个list里的连接对象里的<code>abandoned</code>将会被置为<code>true</code>，标记已被该流程处理过，防止<code>主流程5</code>再次处理，具体可以参考<code>代码段5-1</code>）。</p>
<p>这个如果在实践中能保证每次都可以正常<code>close</code>，完全不用设置<code>removeAbandoned=true</code>，目前如果使用了类似<code>mybatis</code>、<code>spring</code>等开源框架，框架内部是一定会<code>close</code>的，所以此项是不建议设置的，视情况而定。</p>
<h2 id="九、主流程5：回收连接"><a href="#九、主流程5：回收连接" class="headerlink" title="九、主流程5：回收连接"></a>九、主流程5：回收连接</h2><p>这个流程通常是靠连接包装类<code>DruidPooledConnection</code>的<code>close</code>方法触发的，目标方法为<code>recycle</code>，流程图如下：</p>
<p><img src="http://myblog.sharemer.com/2019/08/28/20190828-2-13.png?imageView2/0/w/1024" alt="主流程5" title="主流程5">上述流程对应源代码如下（请展开）：</p>
<figure class="highlight java"><figcaption><span>代码段5-1 >folded</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DruidPooledConnection类的close方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.disable) &#123; <span class="comment">//检查，因为该连接对象是抛出去给别的业务线程使用，也就是说并不受连接池本身管控，所以很可能存在多线程同时close的操作，因此这里需要做一层检查，包括下方的syncClose里的检查也是一个意思</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DruidConnectionHolder holder = <span class="keyword">this</span>.holder; <span class="comment">//拿到对应的holder对象（之前说过，这个对象才是最后放进连接池的对象）</span></span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dupCloseLogEnable) &#123;</span><br><span class="line">                LOG.error(<span class="string">"dup close"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DruidAbstractDataSource dataSource = holder.getDataSource(); <span class="comment">//拿到对应的连接池对象</span></span><br><span class="line">        <span class="keyword">boolean</span> isSameThread = <span class="keyword">this</span>.getOwnerThread() == Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isSameThread) &#123; <span class="comment">//关闭该连接与获取该连接的线程并非同一个的时候，则触发下面的syncClose</span></span><br><span class="line">            dataSource.setAsyncCloseConnectionEnable(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dataSource.isAsyncCloseConnectionEnable()) &#123;</span><br><span class="line">            syncClose(); <span class="comment">//参考上面的解释，该方法详情在下方</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一些事件监听器的触发，忽略</span></span><br><span class="line">        <span class="keyword">for</span> (ConnectionEventListener listener : holder.getConnectionEventListeners()) &#123;</span><br><span class="line">            listener.connectionClosed(<span class="keyword">new</span> ConnectionEvent(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//责任链的执行，参考流程1.1与代码段1-2，运行方式是一样的，找到映射方法，整个触发一遍责任链上的filters</span></span><br><span class="line">        List filters = dataSource.getProxyFilters();</span><br><span class="line">        <span class="keyword">if</span> (filters.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            FilterChainImpl filterChain = <span class="keyword">new</span> FilterChainImpl(dataSource);</span><br><span class="line">            filterChain.dataSource_recycle(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            recycle(); <span class="comment">//触发目标方法recycle</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.disable = <span class="keyword">true</span>; <span class="comment">//标记该连接已失效，无法再次提供服务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//上面逻辑走syncClose的情况，该方法与上面大体相同，但由于不是同一个线程做的操作，所以这里需要锁控制</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncClose</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">//获取锁，这个锁是当前连接对象上的锁，为了解决同一个连接对象在不同的线程里被同时close多次而造成的线程安全问题</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.disable) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            DruidConnectionHolder holder = <span class="keyword">this</span>.holder; <span class="comment">//同样的，拿到需要归还的holder对象</span></span><br><span class="line">            <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dupCloseLogEnable) &#123;</span><br><span class="line">                    LOG.error(<span class="string">"dup close"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//同样是一些事件监听器的触发，忽略</span></span><br><span class="line">            <span class="keyword">for</span> (ConnectionEventListener listener : holder.getConnectionEventListeners()) &#123;</span><br><span class="line">                listener.connectionClosed(<span class="keyword">new</span> ConnectionEvent(<span class="keyword">this</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//同样的责任链的执行，参考上面的解释</span></span><br><span class="line">            DruidAbstractDataSource dataSource = holder.getDataSource();</span><br><span class="line">            List filters = dataSource.getProxyFilters();</span><br><span class="line">            <span class="keyword">if</span> (filters.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                FilterChainImpl filterChain = <span class="keyword">new</span> FilterChainImpl(dataSource);</span><br><span class="line">                filterChain.dataSource_recycle(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                recycle(); <span class="comment">//触发目标方法recycle，方法详情在下方</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.disable = <span class="keyword">true</span>; <span class="comment">//标记该连接已失效，无法再次提供服务</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">//解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//DruidPooledConnection类的recycle方法，由上面俩方法直接触发</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.disable) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DruidConnectionHolder holder = <span class="keyword">this</span>.holder; <span class="comment">//拿到真正需要归还的连接对象</span></span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dupCloseLogEnable) &#123;</span><br><span class="line">                LOG.error(<span class="string">"dup close"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.abandoned) &#123; <span class="comment">//如果期间已经被流程4.2处理过了（abandoned==true），则不触发下方逻辑</span></span><br><span class="line">            DruidAbstractDataSource dataSource = holder.getDataSource();</span><br><span class="line">            dataSource.recycle(<span class="keyword">this</span>); <span class="comment">//真正触发连接池的回收方法，方法详情在下方</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接对象一旦被回收处理，则会把所有与连接相关的属性置空（不持有），closed标记为true</span></span><br><span class="line">        <span class="keyword">this</span>.holder = <span class="keyword">null</span>;</span><br><span class="line">        conn = <span class="keyword">null</span>;</span><br><span class="line">        transactionInfo = <span class="keyword">null</span>;</span><br><span class="line">        closed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DruidDataSource类里的recycle方法，真正回收连接的方法，由上面DruidPooledConnection类的recycle触发</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">(DruidPooledConnection pooledConnection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> DruidConnectionHolder holder = pooledConnection.holder;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            LOG.warn(<span class="string">"connectionHolder is null"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logDifferentThread <span class="comment">//</span></span><br><span class="line">                &amp;&amp; (!isAsyncCloseConnectionEnable()) <span class="comment">//</span></span><br><span class="line">                &amp;&amp; pooledConnection.ownerThread != Thread.currentThread()<span class="comment">//</span></span><br><span class="line">        ) &#123;</span><br><span class="line">            LOG.warn(<span class="string">"get/close not same thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Connection physicalConnection = holder.conn; <span class="comment">//拿到真正的驱动连接对象</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pooledConnection.traceEnable) &#123; <span class="comment">//如果traceEnable为true（满足该属性为true，必须要removeAbandoned设置为true，这样在主流程1那里才会被放进activeConnections，才会置为true），流程4.2处理过后，会把该属性重新置为false，其他情况均为true</span></span><br><span class="line">            Object oldInfo = <span class="keyword">null</span>;</span><br><span class="line">            activeConnectionLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (pooledConnection.traceEnable) &#123; <span class="comment">//双重检查</span></span><br><span class="line">                    oldInfo = activeConnections.remove(pooledConnection); <span class="comment">//从activeConnections移除，防止流程4.2的重复检查</span></span><br><span class="line">                    pooledConnection.traceEnable = <span class="keyword">false</span>; <span class="comment">//置为false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                activeConnectionLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (oldInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (LOG.isWarnEnabled()) &#123;</span><br><span class="line">                    LOG.warn(<span class="string">"remove abandonded failed. activeConnections.size "</span> + activeConnections.size());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isAutoCommit = holder.underlyingAutoCommit;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isReadOnly = holder.underlyingReadOnly;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> testOnReturn = <span class="keyword">this</span>.testOnReturn;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果在归还至连接池时发现此连接对象还有未处理完的事务，则直接回滚</span></span><br><span class="line">            <span class="keyword">if</span> ((!isAutoCommit) &amp;&amp; (!isReadOnly)) &#123;</span><br><span class="line">                pooledConnection.rollback();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// reset holder, restore default settings, clear warnings</span></span><br><span class="line">            <span class="keyword">boolean</span> isSameThread = pooledConnection.ownerThread == Thread.currentThread();</span><br><span class="line">            <span class="keyword">if</span> (!isSameThread) &#123; <span class="comment">//同样判断线程，为了保证安全性</span></span><br><span class="line">                <span class="keyword">final</span> ReentrantLock lock = pooledConnection.lock;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    holder.reset(); <span class="comment">//连接被借出去后，可能被业务方改动了一些属性（典型的比如autoCommit），现在利用reset方法还原为默认值</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                holder.reset(); <span class="comment">//同上，这里认为获取和关闭连接的是同一个线程，不存在线程安全问题，因此不用去竞争锁</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//连接已被抛弃，则不作任何处理（不再归还）</span></span><br><span class="line">            <span class="keyword">if</span> (holder.discard) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//忽略</span></span><br><span class="line">            <span class="keyword">if</span> (phyMaxUseCount &gt; <span class="number">0</span> &amp;&amp; holder.useCount &gt;= phyMaxUseCount) &#123;</span><br><span class="line">                discardConnection(holder.conn);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果驱动连接本身被人为关闭了，除一些监控值之外，也不做处理</span></span><br><span class="line">            <span class="keyword">if</span> (physicalConnection.isClosed()) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    activeCount--;</span><br><span class="line">                    closeCount++;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//参考testOnBorrow，这里testOnReturn就是指每次回收连接都要做连接可用性检查，同样官方不建议开启，影响性能，缺省值也是不开启的</span></span><br><span class="line">            <span class="keyword">if</span> (testOnReturn) &#123;</span><br><span class="line">                <span class="comment">//流程忽略</span></span><br><span class="line">                <span class="keyword">boolean</span> validate = testConnectionInternal(holder, physicalConnection);</span><br><span class="line">                <span class="keyword">if</span> (!validate) &#123;</span><br><span class="line">                    JdbcUtils.close(physicalConnection);</span><br><span class="line"></span><br><span class="line">                    destroyCountUpdater.incrementAndGet(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                    lock.lock();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        activeCount--;</span><br><span class="line">                        closeCount++;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!enable) &#123;</span><br><span class="line">                <span class="comment">//中途发现连接又被置为不可用，则直接触发抛弃方法，参考流程1.4和代码段1-5</span></span><br><span class="line">                discardConnection(holder.conn);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> result;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> currentTimeMillis = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (phyTimeoutMillis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> phyConnectTimeMillis = currentTimeMillis - holder.connectTimeMillis;</span><br><span class="line">                <span class="keyword">if</span> (phyConnectTimeMillis &gt; phyTimeoutMillis) &#123;</span><br><span class="line">                    discardConnection(holder.conn);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                activeCount--;</span><br><span class="line">                closeCount++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//最终放入池子，方法详情在下方</span></span><br><span class="line">                result = putLast(holder, currentTimeMillis);</span><br><span class="line">                recycleCount++;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!result) &#123; <span class="comment">//如果加不进去，则直接关闭驱动连接，然后不处理（此时holder已经失去强引用，不久便会被回收）</span></span><br><span class="line">                JdbcUtils.close(holder.conn);</span><br><span class="line">                LOG.info(<span class="string">"connection recyle failed."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            holder.clearStatementCache();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!holder.discard) &#123;</span><br><span class="line">                <span class="keyword">this</span>.discardConnection(physicalConnection);</span><br><span class="line">                holder.discard = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            LOG.error(<span class="string">"recyle error"</span>, e);</span><br><span class="line">            recycleErrorCountUpdater.incrementAndGet(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DruidDataSource类里的putLast方法，由上方的recycle方法触发</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">putLast</span><span class="params">(DruidConnectionHolder e, <span class="keyword">long</span> lastActiveTimeMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (poolingCount &gt;= maxActive) &#123; <span class="comment">//池子已满，不加</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        e.lastActiveTimeMillis = lastActiveTimeMillis; <span class="comment">//刷新上次活跃时间，该时间很重要，直接影响连接检查的触发</span></span><br><span class="line">        connections[poolingCount] = e; <span class="comment">//放进连接池数组尾部</span></span><br><span class="line">        incrementPoolingCount(); <span class="comment">//poolingCount++</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (poolingCount &gt; poolingPeak) &#123;</span><br><span class="line">            poolingPeak = poolingCount;</span><br><span class="line">            poolingPeakTime = lastActiveTimeMillis;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        notEmpty.signal(); <span class="comment">//因为成功回收了一个连接，那就唤起一次所有因为获取不到连接而被阻塞的业务线程吧~（参考流程1.2）</span></span><br><span class="line">        notEmptySignalCount++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这也是非常重要的一个流程，连接用完要归还，就是利用该流程完成归还的动作，利用druid对外包装的Connecion包装类<code>DruidPooledConnection</code>的<code>close</code>方法触发，该方法会通过自己内部的<code>close</code>或者<code>syncClose</code>方法来间接触发dataSource对象的<code>recycle</code>方法，从而达到回收的目的。</p>
<p>最终的<code>recycle</code>方法：</p>
<ol>
<li><p>如果<code>removeAbandoned</code>被设置为<code>true</code>，则通过<code>traceEnable</code>判断是否需要从<code>activeConnections</code>移除该连接对象，防止<code>流程4.2</code>再次检测到该连接对象，当然如果是<code>流程4.2</code>主动触发的该流程，那么意味着<code>流程4.2</code>里已经remove过该对象了，<code>traceEnable</code>会被置为<code>false</code>，本流程就不再触发remove了（这个流程都是在<code>removeAbandoned=true</code>的情况下进行的，在<code>主流程1</code>里连接被放进<code>activeConnections</code>时<code>traceEnable</code>被置为<code>true</code>，而在<code>removeAbandoned=false</code>的情况下<code>traceEnable</code>恒等于<code>false</code>）。</p>
</li>
<li><p>如果回收过程中发现存在有未处理完的事务，则触发回滚（比较有可能触发这一条的是<code>流程4.2</code>里强制归还连接，也有可能是单纯使用连接，开启事务却没有提交事务就直接<code>close</code>的情况），然后利用<code>holder.reset</code>进行恢复连接对象里一些属性的默认值，除此之外，holder对象还会把由它产生的statement对象放到自己的一个arraylist里面，reset方法会循环着关闭内部未关闭的statement对象，最后清空list，当然，statement对象自己也会记录下其产生的所有的resultSet对象，然后关闭statement时同样也会循环关闭内部未关闭的resultSet对象，这是连接池做的一种保护措施，防止用户拿着连接对象做完一些操作没有对打开的资源关闭。</p>
</li>
<li><p>判断是否开启<code>testOnReturn</code>，这个跟<code>testOnBorrow</code>一样，官方默认不开启，也不建议开启，影响性能，理由参考<code>主流程1</code>里针对<code>testOnBorrow</code>的解释。</p>
</li>
<li><p>直接放回池子（当前<code>connections</code>的尾部），然后需要注意的是<code>putLast</code>方法和<code>put</code>方法的不同之处，<code>putLast</code>会把<code>lastActiveTimeMillis</code>置为当前时间，也就是说不管一个连接被借出去过久，只要归还了，最后活跃时间就是当前时间，这就会有造成某种特殊异常情况的发生（非常极端，几乎不会触发，可以选择不看）：</p>
<blockquote>
<p>如果不开启testOnBorrow和testOnReturn，并且keepAlive设置为false，那么长连接可用测试的间隔依据就是利用当前时间减去上次活跃时间（lastActiveTimeMillis）得出闲置时间，然后再利用闲置时间跟timeBetweenEvictionRunsMillis（默认60s）进行对比，超过才进行长连接可用测试。</p>
<p>那么如果一个mysql服务端的长连接保活时间被人为调整为60s，然后timeBetweenEvictionRunsMillis被设置为59s，这个设置是非常合理的，保证了测试间隔小于长连接实际保活时间，然后如果这时一个连接被拿出去后一直过了61s才被close回收，该连接对象的lastActiveTimeMillis被刷为当前时间，如果在59s内再次拿到该连接对象，就会绕过连接检查直接报连接不可用的错误。</p>
</blockquote>
</li>
</ol>
<h2 id="十、尾声"><a href="#十、尾声" class="headerlink" title="十、尾声"></a>十、尾声</h2><p>到这里针对<code>druid连接池</code>的初始化以及其内部一个连接从<code>生产</code>到<code>消亡</code>的整个流程就已经整理完了，主要是列出其运行流程以及一些主要的监控数据都是如何产生的，没有涉及到的是一个sql的执行，因为这个基本上就跟使用原生驱动程序差不多，只是druid又包装了一层Statement等，用于完成一些自己的操作。</p>
<p>对于druid，处理连接只是很小的一块内容，却是很核心的一块内容。</p>
<p>Druid地址：<a href="https://github.com/alibaba/druid">https://github.com/alibaba/druid</a></p>
</div><div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/2019/09/20/Druid-%E7%B1%BB%E5%9B%BE-%E5%B1%9E%E6%80%A7%E8%A1%A8/" target="_blank">Druid-类图-属性表</a><br></span><span>  2.<a class="is-size-6" href="/2019/08/28/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF%EF%BC%88%E4%BA%8C%EF%BC%89HikariCP%E6%98%AF%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E7%9A%84%EF%BC%9F/" target="_blank">池化技术（二）HikariCP是如何管理数据库连接的？</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="http://myblog.sharemer.com/alipay_qrcode.png" alt="支付宝"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="http://myblog.sharemer.com/wx_qrcode.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/08/28/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF%EF%BC%88%E4%BA%8C%EF%BC%89HikariCP%E6%98%AF%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E7%9A%84%EF%BC%9F/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">池化技术（二）HikariCP是如何管理数据库连接的？</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/07/16/%E5%88%A9%E7%94%A8Spring%E7%9A%84BeanPostProcessor%E6%9D%A5%E4%BF%AE%E6%94%B9bean%E5%B1%9E%E6%80%A7/"><span class="level-item">利用Spring的BeanPostProcessor来修改bean属性</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            id: 'f2b8d24880eb67258beb240c75f65e28',
            repo: 'exceting.github.io',
            owner: 'exceting',
            clientID: '17297b562584b5cec3d7',
            clientSecret: '46c7652ed4f09fb1d847d15df81500a5a2ceeae8',
            admin: ["exceting"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: 'last',
            
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget toc-scroll" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-零、类图-amp-流程预览" href="#零、类图-amp-流程预览"><span>零、类图&amp;amp;流程预览</span></a></li><li><a class="is-flex toc-item" id="toc-item-一、主流程1：获取连接流程" href="#一、主流程1：获取连接流程"><span>一、主流程1：获取连接流程</span></a></li><li><a class="is-flex toc-item" id="toc-item-二、主流程2：初始化连接池" href="#二、主流程2：初始化连接池"><span>二、主流程2：初始化连接池</span></a></li><li><a class="is-flex toc-item" id="toc-item-三、流程1-1：责任链" href="#三、流程1-1：责任链"><span>三、流程1.1：责任链</span></a></li><li><a class="is-flex toc-item" id="toc-item-四、流程1-2：从池中获取连接的流程" href="#四、流程1-2：从池中获取连接的流程"><span>四、流程1.2：从池中获取连接的流程</span></a></li><li><a class="is-flex toc-item" id="toc-item-五、流程1-3：连接可用性测试" href="#五、流程1-3：连接可用性测试"><span>五、流程1.3：连接可用性测试</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-①init-checker" href="#①init-checker"><span>①init-checker</span></a></li><li><a class="is-flex toc-item" id="toc-item-②testConnectionInternal" href="#②testConnectionInternal"><span>②testConnectionInternal</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-六、流程1-4：抛弃连接" href="#六、流程1-4：抛弃连接"><span>六、流程1.4：抛弃连接</span></a></li><li><a class="is-flex toc-item" id="toc-item-七、主流程3：添加连接的守护线程" href="#七、主流程3：添加连接的守护线程"><span>七、主流程3：添加连接的守护线程</span></a></li><li><a class="is-flex toc-item" id="toc-item-八、主流程4：抛弃连接的守护线程" href="#八、主流程4：抛弃连接的守护线程"><span>八、主流程4：抛弃连接的守护线程</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-流程4-1：连接池瘦身，检查连接是否可用以及丢弃多余连接" href="#流程4-1：连接池瘦身，检查连接是否可用以及丢弃多余连接"><span>流程4.1：连接池瘦身，检查连接是否可用以及丢弃多余连接</span></a></li><li><a class="is-flex toc-item" id="toc-item-流程4-2：主动回收连接，防止内存泄漏" href="#流程4-2：主动回收连接，防止内存泄漏"><span>流程4.2：主动回收连接，防止内存泄漏</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-九、主流程5：回收连接" href="#九、主流程5：回收连接"><span>九、主流程5：回收连接</span></a></li><li><a class="is-flex toc-item" id="toc-item-十、尾声" href="#十、尾声"><span>十、尾声</span></a></li></ul></div></div><script type="text/javascript" async>
        $(document).ready(function () { //参考自 https://github.com/ppoffice/hexo-theme-icarus/pull/616/files
            var observerTopMargin;
            var scrollObserver;
            var headerElems = $(".headerlink");
            var activeTocItem;
        
            function initIntersectionObserver(docHeight) {
                observerTopMargin = docHeight;
                scrollObserver = new IntersectionObserver(scrollCallBack,
                    {
                        root: null,  // viewpoint
                        rootMargin: docHeight + "px 0px -80% 0px"  // cover top 30% of viewport to the top of document
                    })
            }
        
            function scrollCallBack(entries, observer) {
                if ($(window).scrollTop() > observerTopMargin * 0.7) { 
                    // User somehow scroll to 70% of observerTopMargin (which is inited as 200% document height)
                    // Observer top margin need to extend to cover all the space to the top of the document
                    initIntersectionObserver(observerTopMargin * 2)
                    observer.disconnect();
                    return;
                }
                let toActive;
                if (entries[0].intersectionRatio == 1) {  // enter viewed area
                    let entry = entries.reduce((u, v) => (u.target.toc_id > v.target.toc_id ? u : v));  // get the lowest item
                    toActive = $("#toc-item-" + $(entry.target).attr("href").substr(1));
                } else {
                    let entry = entries.reduce((u, v) => (u.target.toc_id < v.target.toc_id ? u : v));  // get the highest item
                    let idx = Math.max(entry.target.toc_id - 1, 0);
                    toActive = $("#toc-item-" + $(headerElems[idx]).attr("href").substr(1));
                }
                if (activeTocItem) activeTocItem.removeClass("is-current");
                activeTocItem = toActive
                activeTocItem.addClass("is-current");
            }
        
            initIntersectionObserver($(document).height() * 2);
            headerElems.each(function (index, obj) {
                obj.toc_id = index;
                scrollObserver.observe(obj);
            })
        });</script></div><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="" src="http://myblog.sharemer.com/avatar_2.png" alt="S-Virus"></figure><p class="title is-size-4 is-block line-height-inherit">S-Virus</p><p class="is-size-6 is-block">随机和因果，命运与无常，兼而有之</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>上海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">75</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">37</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">71</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/exceting" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/exceting"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="bilibili" href="https://www.bilibili.com"><i class="fas fa-tv"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:1807301715@qq.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-08-13T02:25:00.000Z">2020-08-13</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/13/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-P2C%E7%AE%97%E6%B3%95/">负载均衡-P2C算法</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/">服务治理</a> / <a class="link-muted" href="/categories/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">负载均衡</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-08-07T12:57:00.000Z">2020-08-07</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/07/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-WRR%E7%AE%97%E6%B3%95/">负载均衡-P2C算法</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/">服务治理</a> / <a class="link-muted" href="/categories/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/">负载均衡</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-08-06T11:18:00.000Z">2020-08-06</time></p><p class="title is-6"><a class="link-muted" href="/2020/08/06/%E5%AE%9A%E5%88%B6grpc%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8/">定制grpc负载均衡器</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a> / <a class="link-muted" href="/categories/%E6%A1%86%E6%9E%B6/gRPC/">gRPC</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-08T01:38:00.000Z">2020-06-08</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/08/%E6%B5%8E%E6%BA%90%E6%B8%B8%E8%AE%B0/">济源游记-20200517</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E6%97%A5%E5%B8%B8/">日常</a> / <a class="link-muted" href="/categories/%E6%97%A5%E5%B8%B8/%E6%97%85%E8%A1%8C/">旅行</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-01T16:11:00.000Z">2020-06-02</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/02/%E8%AF%A6%E8%A7%A3JDBC%E7%9A%84Loadbalance%E6%A8%A1%E5%BC%8F/">详解JDBC的Loadbalance模式</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/DB/">DB</a> / <a class="link-muted" href="/categories/DB/MySQL/">MySQL</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/DB/"><span class="level-start"><span class="level-item">DB</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/DB/InfluxDB/"><span class="level-start"><span class="level-item">InfluxDB</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/DB/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/DB/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"><span class="level-start"><span class="level-item">分布式缓存</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/JAVA%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">JAVA基础</span></span><span class="level-end"><span class="level-item tag">31</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/JAVA%E5%9F%BA%E7%A1%80/JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA/"><span class="level-start"><span class="level-item">JAVA进化论</span></span><span class="level-end"><span class="level-item tag">28</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JAVA%E5%9F%BA%E7%A1%80/JVM/"><span class="level-start"><span class="level-item">JVM</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">并发编程</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC/"><span class="level-start"><span class="level-item">JUC</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadLocal/"><span class="level-start"><span class="level-item">ThreadLocal</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><span class="tag">基础知识</span><span class="tag is-grey-lightest">27</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%99%E7%A8%8B/"><span class="tag">教程</span><span class="tag is-grey-lightest">27</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span class="tag">并发编程</span><span class="tag is-grey-lightest">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="tag">网络编程</span><span class="tag is-grey-lightest">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NIO/"><span class="tag">NIO</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JVM/"><span class="tag">JVM</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ThreadLocal/"><span class="tag">ThreadLocal</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/juc/"><span class="tag">juc</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/loadbalancer/"><span class="tag">loadbalancer</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF/"><span class="tag">池化技术</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"><span class="tag">负载均衡</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"><span class="tag">连接池</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Druid/"><span class="tag">Druid</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenTracing/"><span class="tag">OpenTracing</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/aop/"><span class="tag">aop</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ioc/"><span class="tag">ioc</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/map/"><span class="tag">map</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag is-grey-lightest">2</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=removeifFeedsId&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="removeifFeedsId" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div><p class="help">如果需要订阅，可以尝试留下你的邮箱</p></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="http://myblog.sharemer.com/logooo.png" alt="S-Virus" height="28"></a><p class="size-small"><span>&copy; 2020 S-Virus</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>,Modify by <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">removeif</a> <br><span>© 版权说明：[本博客所有文档均由博主创作，作为博主本人记录生活和学习之用，站内文档禁止转载，如有关于本站的疑问，请<a href="/message" target="_blank">留言</a>]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2018/12/29 00:00:00')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/exceting"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="2755914162" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.12/js/lightgallery-all.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><!--!--><!--!--><!--!--><script src="/js/toc.js" defer></script><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('17297b562584b5cec3d7','46c7652ed4f09fb1d847d15df81500a5a2ceeae8','exceting','exceting.github.io',false);})</script><link rel="stylesheet" href="/css/insight.css"><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="想要查找什么..."><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>(function (window) {
            var INSIGHT_CONFIG = {
                TRANSLATION: {
                    POSTS: '文章',
                    PAGES: '页面',
                    CATEGORIES: '分类',
                    TAGS: '标签',
                    UNTITLED: '(无标题)',
                },
                CONTENT_URL: '/content.json',
            };
            window.INSIGHT_CONFIG = INSIGHT_CONFIG;
        })(window);</script><script src="/js/insight.js" defer></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('17297b562584b5cec3d7','46c7652ed4f09fb1d847d15df81500a5a2ceeae8','exceting','exceting.github.io',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>