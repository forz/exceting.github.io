<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.0"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><meta name="keywords" content="[object Object]"><meta name="description" content="🌏 环境：&amp;nbsp"><meta name="author" content="exceting"><title>Resilience4j熔断器-使用与源码解析 - S-Virus</title><meta description="🌏 环境：&amp;amp;nbsp;&amp;amp;nbsp; 🌾 依赖版本： 🍃 知识依赖：JUC，位图"><meta property="og:type" content="article"><meta property="og:title" content="Resilience4j熔断器-使用与源码解析"><meta property="og:url" content="http://yoursite.com/2019/12/10/Resilience4j%E7%86%94%E6%96%AD%E5%99%A8-%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><meta property="og:site_name" content="S-Virus"><meta property="og:description" content="🌏 环境：&amp;amp;nbsp;&amp;amp;nbsp; 🌾 依赖版本： 🍃 知识依赖：JUC，位图"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://myblog.sharemer.com/avatar_2.png"><meta property="article:published_time" content="2019-12-10T13:58:00.000Z"><meta property="article:modified_time" content="2020-05-03T05:25:37.523Z"><meta property="article:author" content="exceting"><meta property="article:tag" content="位图"><meta property="article:tag" content="熔断"><meta property="article:tag" content="Resilience4j"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://myblog.sharemer.com/avatar_2.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2019/12/10/Resilience4j%E7%86%94%E6%96%AD%E5%99%A8-%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},"headline":"Resilience4j熔断器-使用与源码解析","image":["http://myblog.sharemer.com/avatar_2.png"],"datePublished":"2019-12-10T13:58:00.000Z","dateModified":"2020-05-03T05:25:37.523Z","author":{"@type":"Person","name":"exceting"},"description":"🌏 环境：&amp;nbsp;&amp;nbsp; 🌾 依赖版本： 🍃 知识依赖：JUC，位图"}</script><link rel="alternative" href="/atom.xml" title="S-Virus" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.12/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/css/style.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="http://myblog.sharemer.com/logooo.png" alt="S-Virus" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">🏠 首页</a><a class="navbar-item" href="/archives">⚜️ 归档</a><a class="navbar-item" href="/categories">👾 分类</a><a class="navbar-item" href="/tags">🔖 标签</a><a class="navbar-item" href="/categories/%E6%97%A5%E5%B8%B8/">🌴 日常</a><a class="navbar-item" href="/course">📚 教程</a><a class="navbar-item" href="/message">📝 留言</a><a class="navbar-item" href="/timeline">⌚️ 时光轴</a><a class="navbar-item" href="/about">👨🏻‍💻 关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/exceting"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2019-12-10  <a class="commentCountImg" href="/2019/12/10/Resilience4j%E7%86%94%E6%96%AD%E5%99%A8-%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/#comment-container"><span class="display-none-class">fb64c509b42ca2eac1afe562ca02f822</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="fb64c509b42ca2eac1afe562ca02f822">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>1 小时  <i class="fas fa-pencil-alt"> </i>12.4k</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Resilience4j熔断器-使用与源码解析</h1><div class="content"><blockquote>
<p>🌏 环境：<embed src="https://img.shields.io/badge/JDK-v11-orange" style="display:inline-block;*display:inline;width:62px;height:20px" />&nbsp;&nbsp;<embed src="https://img.shields.io/badge/IntelliJ%20IDEA-2019.03-blueviolet" style="display:inline-block;*display:inline;width:132px;height:20px" /></p>
<p>🌾 依赖版本：<embed src="https://img.shields.io/badge/Resilience4j-v0.13.2-green" style="display:inline-block;*display:inline;width:128px;height:20px" /></p>
<p>🍃 知识依赖：<code>JUC</code>，<code>位图</code></p>
</blockquote>
<a id="more"></a>

<h2 id="一、什么是熔断"><a href="#一、什么是熔断" class="headerlink" title="一、什么是熔断"></a>一、什么是熔断</h2><p>在分布式系统中，各服务间的相互调用更加频繁，上下游调用中充满了可能性，一个服务可能会被很多其他服务依赖并调用，在这个过程中如果某个服务由于某种原因出错（业务出错、负载过高），可能会导致整个分布式调用链路失败：</p>
<p><img src="http://myblog.sharemer.com/2019/12/10/20191210-1-1.png?imageView2/0/w/700" alt="图1" title="图1"></p>
<p>上面这个过程最终可能会导致全链路瘫痪（服务雪崩），此时需要一种可以解决上述问题的策略，此策略设计目标为：</p>
<ol>
<li>在发现有服务调用失败后，及时计算失败率</li>
<li>失败率达到某种阈值时，切断与该服务的所有交互，服务走切断后的自定义逻辑</li>
<li>切断并且不再调用该服务后主动监听被切断的服务是否已经恢复了处理能力，若恢复，则继续让其提供服务</li>
</ol>
<p>这个策略被放进<code>图1</code>中，就变成了下面这样：</p>
<p><img src="http://myblog.sharemer.com/2019/12/10/20191210-1-2.png?imageView2/0/w/1024" alt="图2" title="图2"></p>
<p>这个过程中，C服务在自己出问题的情况下，并不会像<code>图1</code>里那样仍然有大量流量打进来，也不会影响到上游服务，这个结果让调用链看起来比<code>图1</code>更加的稳定，这个过程就叫<code>熔断</code>。</p>
<p>针对这个过程，可以看到在C不可用时，B走了熔断后的降级逻辑，这个逻辑可以自定义，如果C在整个调用链里属于那种必须要成功的服务，那么这里的逻辑就可以是直接抛错，如果C属于那种失败了也无所谓，不影响整个业务处理，那么降级逻辑里就可以不做处理，例如下面的场景：</p>
<p><img src="http://myblog.sharemer.com/2019/12/10/20191210-1-3.png?imageView2/0/w/900" alt="图3" title="图3"></p>
<p>类似这种接口，降级策略很适合不做处理，返回空信息即可，这样最坏的情况就是页面少了某个板块的信息，可能会对用户造成不太好的体验，但是不影响其对外服务，被熔断的服务恢复后页面也会重新回归正常。熔断后的降级处理方式是件值得思考的事情，熔断和降级是相互独立的概念，熔断后必然会有降级操作（哪怕直接抛异常也是一种降级策略），这个降级操作是熔断这个动作导致的，所以很多时候会把熔断和降级放在一起说，其实降级还可以由其他动作触发，比如限流后抛出“<code>系统繁忙</code>”，这也是一种降级策略，只不过它是由限流触发的，再比如通过开关埋点在系统负载过高时主动关停一些次要服务来提升核心功能的响应速度，这也是一种降级策略，降级是最终产物，而产生它的方式有很多种。</p>
<h2 id="二、Resilience4j中的熔断器"><a href="#二、Resilience4j中的熔断器" class="headerlink" title="二、Resilience4j中的熔断器"></a>二、Resilience4j中的熔断器</h2><h3 id="2-1：Resilience4j是什么？"><a href="#2-1：Resilience4j是什么？" class="headerlink" title="2.1：Resilience4j是什么？"></a>2.1：Resilience4j是什么？</h3><p>它是一个轻量、易用、可组装的高可用框架，支持<code>熔断</code>、<code>高频控制</code>、<code>隔离</code>、<code>限流</code>、<code>限时</code>、<code>重试</code>等多种高可用机制。本篇文章只关注其<code>熔断部分</code>。</p>
<h3 id="2-2：如何使用？"><a href="#2-2：如何使用？" class="headerlink" title="2.2：如何使用？"></a>2.2：如何使用？</h3><p>通过第一部分的介绍，可以认为一个熔断器必须要具备统计单位请求内的错误率、全熔断、半熔断放量、恢复这几个流程，带着这个流程，下面来介绍下<code>Resilience4j</code>里熔断器的用法。</p>
<p>通过<code>图2</code>里服务B调用服务C的例子，现在利用java类来进行简单模拟下这个流程。</p>
<p>首先定义ServerC类，用于模拟服务C：</p>
<figure class="highlight java"><figcaption><span>代码块1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerC</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用该方法模拟服务C获取C信息的方法，假设现在服务C的getCInfo方法里有个bug，当输入的id为0时报错，其他情况正常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCInfo</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"输入0异常"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"id="</span> + id + <span class="string">"的C信息"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再定义ServerB类，用于模拟服务B，这里给服务B调用服务C方法那里加上熔断器处理，注意这个类里的注释，会详细说明熔断器的主要配置项以及其使用方法：</p>
<figure class="highlight java"><figcaption><span>代码块2</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CircuitBreakerRegistry breakerRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerC serverC = <span class="keyword">new</span> ServerC(); <span class="comment">//让服务B持有一个服务C的引用，用来表示正常服务间调用里的一个连接引用</span></span><br><span class="line"></span><br><span class="line">    ServerB() &#123;</span><br><span class="line">        <span class="comment">//初始化breaker注册器，可以利用该对象生产各种breaker对象（注：凡是用同一个注册器生产出来的breaker，都会继承注册器的配置属性）</span></span><br><span class="line">        breakerRegistry = CircuitBreakerRegistry.of(CircuitBreakerConfig.custom() <span class="comment">//of方法里面放的就是breaker的配置属性对象</span></span><br><span class="line">                .enableAutomaticTransitionFromOpenToHalfOpen() <span class="comment">//开启从全开状态经过下面的waitDurationInOpenState时间后自动切换到半开状态</span></span><br><span class="line">                .failureRateThreshold(<span class="number">50</span>) <span class="comment">//熔断器闭合状态下的错误率阈值，50表示50%，如果错误率达到这个阈值，那么熔断器将进入全熔断状态</span></span><br><span class="line">                .ringBufferSizeInClosedState(<span class="number">100</span>) <span class="comment">//熔断器闭合状态下，以该值为单位请求数，计算错误率，跟上面错误率阈值综合理解，这个值表示至少有100个请求，且错误50个以上才会触发全熔断</span></span><br><span class="line">                .ringBufferSizeInHalfOpenState(<span class="number">10</span>) <span class="comment">//熔断器半熔断状态下，以该值为单位请求数，计算错误率，跟上面错误率阈值综合理解，这个值表示至少有10个请求，且错误5个以上会再次触发全熔断，相比闭合状态，半熔断状态下更容易再次进入全熔断状态</span></span><br><span class="line">                .waitDurationInOpenState(Duration.ofMillis(<span class="number">1000L</span>)) <span class="comment">//熔断器全熔断状态持续的时间，全熔断后经过该时间后进入半熔断状态</span></span><br><span class="line">                .build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务B通过服务C来获取到C的info信息，该方法就是用来干这个的，它会发起对服务C的调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCInfo</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//breaker对象是按照name划分全局单例的</span></span><br><span class="line">        CircuitBreaker breaker = breakerRegistry.circuitBreaker(<span class="string">"getCInfo"</span>); <span class="comment">//这里给熔断器取个名，一般情况就是一个服务的path或方法名</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> breaker.executeCallable(() -&gt; serverC.getCInfo(id));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CircuitBreakerOpenException e) &#123; <span class="comment">//一旦抛出该异常说明已经进入全熔断状态</span></span><br><span class="line">            <span class="comment">//被熔断后的降级逻辑</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"服务C出错，触发服务B的降级逻辑"</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//熔断关闭或者半熔断状态下，C抛出的错误会被catch到这里</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"调用服务C出错"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CircuitBreaker <span class="title">getBreaker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> breakerRegistry.circuitBreaker(<span class="string">"getCInfo"</span>); <span class="comment">//为了方便做测试，这里返回对应的breaker对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述配置的熔断器解释如下：</p>
<p>在熔断器<code>闭合</code>的情况下（也即是正常情况下），以100个请求为<code>单位窗口</code>计算错误率，一旦错误率达到50%，立刻进入<code>全熔断</code>状态，该状态下服务B不会再发生对服务C的调用，直接走自己的降级逻辑，经过1000ms后恢复为<code>半熔断</code>状态，此时流量开始打进服务C，此时仍然会计算错误率，只是<code>半熔断</code>状态下，是以10个请求为单位窗口计算的错误率，这个可以保证在服务C没有恢复正常的情况下可以更快速的进入<code>全熔断</code>状态。</p>
<h3 id="2-3：测试-熔断器状态切换"><a href="#2-3：测试-熔断器状态切换" class="headerlink" title="2.3：测试-熔断器状态切换"></a>2.3：测试-熔断器状态切换</h3><p>然后开始编写测试方法，下面会通过测试方法来详细解析该熔断器的状态变迁：</p>
<figure class="highlight java"><figcaption><span>代码块3</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBreak</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//按照B服务里熔断器的配置，如果进行100次请求，有50次失败了，则对ServerC的调用进入全熔断状态</span></span><br><span class="line">        <span class="comment">//1000ms后恢复为半熔断状态，半熔断状态下进行10次请求，如果有5次依然失败，则再次进入全熔断状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">50</span>) &#123;</span><br><span class="line">                serverB.getCInfo(<span class="number">0</span>); <span class="comment">//前50次全部报错</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverB.getCInfo(<span class="number">1</span>); <span class="comment">//后50次全部成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//断言：此时熔断器为全熔断状态</span></span><br><span class="line">        System.out.println(serverB.getBreaker().getState().equals(CircuitBreaker.State.OPEN));</span><br><span class="line">        <span class="comment">//全熔断状态下并不会实际调用C，而是会走服务B的降级逻辑，即便我们输入的参数是对的，也一样会被降级</span></span><br><span class="line">        System.out.println(serverB.getCInfo(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">500L</span>);</span><br><span class="line">        <span class="comment">//断言：由于全熔断状态配置的持续时间时1000ms，所以500ms过去后，仍然是全熔断状态</span></span><br><span class="line">        System.out.println(serverB.getBreaker().getState().equals(CircuitBreaker.State.OPEN));</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">500L</span>);</span><br><span class="line">        <span class="comment">//断言：1000ms过后，熔断器处于半熔断状态</span></span><br><span class="line">        System.out.println(serverB.getBreaker().getState().equals(CircuitBreaker.State.HALF_OPEN));</span><br><span class="line">        <span class="comment">//半熔断状态下会尝试恢复，所以会实际调用C，分别输入正确和错误的参数进行测试</span></span><br><span class="line">        System.out.println(serverB.getCInfo(<span class="number">1</span>));</span><br><span class="line">        System.out.println(serverB.getCInfo(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//半熔断状态下，只需要请求10次，有5次出错即可再次进入全熔断状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">4</span>) &#123; <span class="comment">//因为上面传过一次0了，所以这里只需要4次便可以重新回到全开状态</span></span><br><span class="line">                serverB.getCInfo(<span class="number">0</span>); <span class="comment">//前5次全部报错</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverB.getCInfo(<span class="number">1</span>); <span class="comment">//后5次全部成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//断言：此时熔断器为全熔断状态</span></span><br><span class="line">        System.out.println(serverB.getBreaker().getState().equals(CircuitBreaker.State.OPEN));</span><br><span class="line">        <span class="comment">//同样的，全熔断状态下并不会实际调用C，而是会走服务B的降级逻辑</span></span><br><span class="line">        System.out.println(serverB.getCInfo(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//这时静待1000ms，再次进入半熔断状态，我们尝试恢复服务C的调用</span></span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这时我们让其10次请求里有6次成功</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">6</span>) &#123; <span class="comment">//前6次成功</span></span><br><span class="line">                serverB.getCInfo(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//后4次失败</span></span><br><span class="line">                serverB.getCInfo(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//由于10次请求里只失败了4次，达不到50%的全开阈值，所以此时会恢复</span></span><br><span class="line">        <span class="comment">//断言：此时熔断器为闭合状态</span></span><br><span class="line">        System.out.println(serverB.getBreaker().getState().equals(CircuitBreaker.State.CLOSED));</span><br><span class="line">        System.out.println(serverB.getCInfo(<span class="number">1</span>)); <span class="comment">//正常输出</span></span><br><span class="line">        System.out.println(serverB.getCInfo(<span class="number">0</span>)); <span class="comment">//走普通异常逻辑</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最终输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">服务C出错，触发服务B的降级逻辑</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">id=1的C信息</span><br><span class="line">调用服务C出错</span><br><span class="line">true</span><br><span class="line">服务C出错，触发服务B的降级逻辑</span><br><span class="line">true</span><br><span class="line">id=1的C信息</span><br><span class="line">调用服务C出错</span><br></pre></td></tr></table></figure>

<p>可以看到，单位请求内达到错误率阈值后熔断器会进入<code>全开状态</code>（<code>全熔断</code>），全开状态下走<code>降级逻辑</code>，此时不再会实际请求服务C，一段时间后（全开持续时间），进入<code>半开状态</code>（<code>半熔断</code>），半开时仍然正常打入服务C，只是由于单位请求量相比闭合时更小，若服务还没恢复，计算错误率会更快达到错误率阈值而迅速进入全开状态，以此类推。如果服务已经恢复，那么将会从半开状态进入闭合状态。</p>
<h3 id="2-4：测试-错误率统计方式"><a href="#2-4：测试-错误率统计方式" class="headerlink" title="2.4：测试-错误率统计方式"></a>2.4：测试-错误率统计方式</h3><p>通过上面的测试用例可以知道触发熔断器状态切换的时机，而且闭合状态下和半熔断状态下统计错误率的单位请求数不相同，那么这个请求数量又是怎么统计的呢？如果一个请求先错误了49次，然后在第101次请求的时候再错误1次是否可以成功触发熔断器全开？如果把这49次失败往后挪一位呢？现在再来按照设想测试下其错误率的统计方式：</p>
<figure class="highlight java"><figcaption><span>代码块4</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先闭合状态下单位请求仍然是100，现在让前49次全部失败</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">49</span>) &#123;</span><br><span class="line">                serverB.getCInfo(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverB.getCInfo(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//断言：虽然请求了100次，但是错误率并没有达到阈值（50%），所以这里仍然是闭合状态的</span></span><br><span class="line">        System.out.println(serverB.getBreaker().getState().equals(CircuitBreaker.State.CLOSED));</span><br><span class="line">        <span class="comment">//这里再让其失败一次</span></span><br><span class="line">        serverB.getCInfo(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//断言：这里应该还是闭合状态的，按照100次单位请求来看，第一次失败的那个请求会被这次失败这个请求顶替掉（这里不理解没关系，下面有图）</span></span><br><span class="line">        System.out.println(serverB.getBreaker().getState().equals(CircuitBreaker.State.CLOSED));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>然后我们让第一次失败的那次请求和其后面出错的请求后移一位：</p>
<figure class="highlight java"><figcaption><span>代码块5</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先闭合状态下单位请求仍然是100，仍然让其错误49次，但现在让第2~50次失败</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i &lt; <span class="number">50</span>) &#123; <span class="comment">//第2~50次请求失败，总计失败49次</span></span><br><span class="line">                serverB.getCInfo(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverB.getCInfo(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//断言：跟上面例子一样，错误率并没有达到阈值，仍然是闭合状态</span></span><br><span class="line">        System.out.println(serverB.getBreaker().getState().equals(CircuitBreaker.State.CLOSED));</span><br><span class="line">        <span class="comment">//这里再让其失败一次</span></span><br><span class="line">        serverB.getCInfo(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//断言：这里应该是全开状态，按照100次单位请求来看，第一次成功的那个请求会被这次失败这个请求顶替掉，然后凑够50次失败请求（参考图4）</span></span><br><span class="line">        System.out.println(serverB.getBreaker().getState().equals(CircuitBreaker.State.OPEN));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>用图来描述下导致这两种情况发生的流程：</p>
<p><img src="http://myblog.sharemer.com/2019/12/10/20191210-1-4.png?imageView2/0/w/800" alt="图4" title="图4"></p>
<p>所以<code>Resilience4j</code>在计算失败率的时候，是会发生滑动的，错误率是根据当前<code>滑动窗口</code>内的请求进行计算得出的，每次请求都会导致<code>窗口移动</code>，都会重新计算当前失败率，这个在源码解析里会说明这是怎样的一种结构，这里简单了解即可。 </p>
<h2 id="三、源码解析"><a href="#三、源码解析" class="headerlink" title="三、源码解析"></a>三、源码解析</h2><h3 id="3-1：注册器入口"><a href="#3-1：注册器入口" class="headerlink" title="3.1：注册器入口"></a>3.1：注册器入口</h3><p>通过上面ServerB类里的使用，首先会通过<code>CircuitBreakerRegistry.of</code>生成一个注册器对象，然后利用注册器对象的<code>circuitBreaker</code>方法来生成一个实际的<code>breaker对象</code>，代码如下：</p>
<figure class="highlight java"><figcaption><span>代码块6</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CircuitBreakerRegistry</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态方法返回了InMemoryCircuitBreakerRegistry的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> CircuitBreakerRegistry <span class="title">of</span><span class="params">(CircuitBreakerConfig circuitBreakerConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InMemoryCircuitBreakerRegistry(circuitBreakerConfig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>InMemoryCircuitBreakerRegistry</code>类代码如下（已简化处理，只展示流程相关代码）：</p>
<figure class="highlight java"><figcaption><span>代码块7</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InMemoryCircuitBreakerRegistry</span> <span class="keyword">implements</span> <span class="title">CircuitBreakerRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有的breaker被存方在这个map里，breaker按照name不同而不同，每个breaker里都有自己的一份错误率统计数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, CircuitBreaker&gt; circuitBreakers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CircuitBreakerConfig defaultCircuitBreakerConfig; <span class="comment">//开始的配置对象，闭合状态单位请求量、半开状态单位请求量、错误率阈值等都会放在这里面</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InMemoryCircuitBreakerRegistry</span><span class="params">(CircuitBreakerConfig defaultCircuitBreakerConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultCircuitBreakerConfig = Objects.requireNonNull(defaultCircuitBreakerConfig, <span class="string">"CircuitBreakerConfig must not be null"</span>);</span><br><span class="line">        <span class="keyword">this</span>.circuitBreakers = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CircuitBreaker <span class="title">circuitBreaker</span><span class="params">(String name)</span> </span>&#123; <span class="comment">//添加一个breaker，若存在，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> circuitBreakers.computeIfAbsent(Objects.requireNonNull(name, <span class="string">"Name must not be null"</span>),</span><br><span class="line">                (k) -&gt; CircuitBreaker.of(name, defaultCircuitBreakerConfig));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个流程很简单，就是用一个map来维护所有breaker的，所以需要注意的是，命名breaker的时候，不要携带一些id之类的字段，很容易把map撑爆。</p>
<h3 id="3-2：Breaker实体-CircuitBreaker"><a href="#3-2：Breaker实体-CircuitBreaker" class="headerlink" title="3.2：Breaker实体-CircuitBreaker"></a>3.2：Breaker实体-CircuitBreaker</h3><p>拿到breaker实体后首先会通过其executeCallable方法执行需要被熔断的逻辑块，之前提到的所有的错误率统计、状态切换都发生在这个实体内。</p>
<figure class="highlight java"><figcaption><span>代码块8</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CircuitBreaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span>  T <span class="title">executeCallable</span><span class="params">(Callable callable)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> decorateCallable(<span class="keyword">this</span>, callable).call(); <span class="comment">//包装原始的callable</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法包装，返回一个Callable对象，真正的业务逻辑callable在这里被执行</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span>  Callable <span class="title">decorateCallable</span><span class="params">(CircuitBreaker circuitBreaker, Callable callable)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">            <span class="comment">//全熔断状态下，这里返回false，会抛出CircuitBreakerOpenException类型的异常，ServerB里判定是否走降级逻辑就是通过catch该异常来决定的</span></span><br><span class="line">            <span class="keyword">if</span>(!circuitBreaker.isCallPermitted()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> CircuitBreakerOpenException(String.format(<span class="string">"CircuitBreaker '%s' is open"</span>, circuitBreaker.getName()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//非全熔断状态触发下面的逻辑</span></span><br><span class="line">            <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                T returnValue = callable.call(); <span class="comment">//执行实际的业务逻辑</span></span><br><span class="line">                <span class="keyword">long</span> durationInNanos = System.nanoTime() - start;</span><br><span class="line">                circuitBreaker.onSuccess(durationInNanos); <span class="comment">//非常关键的方法，用来累计执行成功的数量，计算错误率</span></span><br><span class="line">                <span class="keyword">return</span> returnValue;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123; <span class="comment">//执行异常，调用onError累计出错数</span></span><br><span class="line">                <span class="keyword">long</span> durationInNanos = System.nanoTime() - start;</span><br><span class="line">                circuitBreaker.onError(durationInNanos, throwable); <span class="comment">//非常关键的方法，用来累计执行失败的数量，计算错误率</span></span><br><span class="line">                <span class="keyword">throw</span> throwable;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CircuitBreaker</code>是一个接口，<code>CircuitBreakerStateMachine</code>是它的实现类，上述代码里比较关键的<code>isCallPermitted</code>、<code>onSuccess</code>、<code>onError</code>都是在这个<code>CircuitBreakerStateMachine</code>类里实现的。 <code>CircuitBreakerStateMachine</code>类比较复杂，牵扯到整个熔断器的状态切换、错误统计触发等，精简一下该类，只关注核心部分：</p>
<figure class="highlight java"><figcaption><span>代码块9</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CircuitBreakerStateMachine</span> <span class="keyword">implements</span> <span class="title">CircuitBreaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//熔断器的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非常非常关键的一个属性，它是一个引用对象，CircuitBreakerState一共有以下子类：ClosedState、HalfOpenState、OpenState、DisabledState、ForcedOpenState</span></span><br><span class="line"><span class="comment">     * 熔断器每次发生状态切换，都会new出一个新的XXState对象，让下面的引用指向新的状态对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference stateReference;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始设置的熔断器配置，通过该对象可以拿到错误率阈值、全熔断持续状态等信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CircuitBreakerConfig circuitBreakerConfig;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&amp;&amp;&amp; 事件处理器，这里不是重点，放到第四部分说，可以先忽略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CircuitBreakerEventProcessor eventProcessor;</span><br><span class="line"></span><br><span class="line">　　 <span class="comment">//构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircuitBreakerStateMachine</span><span class="params">(String name, CircuitBreakerConfig circuitBreakerConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.circuitBreakerConfig = circuitBreakerConfig;</span><br><span class="line">        <span class="keyword">this</span>.stateReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="keyword">new</span> ClosedState(<span class="keyword">this</span>)); <span class="comment">//初始化的时候，熔断器状态都是闭合状态，所以首先new一个ClosedState并让stateReference指向它</span></span><br><span class="line">        <span class="keyword">this</span>.eventProcessor = <span class="keyword">new</span> CircuitBreakerEventProcessor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切换到闭合状态，new ClosedState，可以看到每个XXState对象都持有当前CircuitBreakerStateMachine对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transitionToClosedState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stateTransition(CLOSED, currentState -&gt; <span class="keyword">new</span> ClosedState(<span class="keyword">this</span>, currentState.getMetrics()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切换到全熔断状态，new OpenState，</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transitionToOpenState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stateTransition(OPEN, currentState -&gt; <span class="keyword">new</span> OpenState(<span class="keyword">this</span>, currentState.getMetrics()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切换到半熔断状态，new HalfOpenState，</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transitionToHalfOpenState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stateTransition(HALF_OPEN, currentState -&gt; <span class="keyword">new</span> HalfOpenState(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态切换方法（也即是XXState对象切换的地方）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stateTransition</span><span class="params">(State newState, Function&lt;CircuitBreakerState, CircuitBreakerState&gt; newStateGenerator)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//引用指向新的XXState对象</span></span><br><span class="line">        CircuitBreakerState previousState = stateReference.getAndUpdate(currentState -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (currentState.getState() == newState) &#123;</span><br><span class="line">                <span class="keyword">return</span> currentState;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> newStateGenerator.apply(currentState);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (previousState.getState() != newState) &#123;</span><br><span class="line">            <span class="comment">//&amp;&amp;&amp; 状态切换事件发布，本部分忽略，参考第四部分</span></span><br><span class="line">            publishStateTransitionEvent(StateTransition.transitionBetween(previousState.getState(), newState));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代码块8里的isCallPermitted方法，这个方法决定了是否抛出"已熔断"异常</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCallPermitted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可以看到，这个解决取决于对应XXState里isCallPermitted方法的返回结果</span></span><br><span class="line">        <span class="keyword">boolean</span> callPermitted = stateReference.get().isCallPermitted();</span><br><span class="line">        <span class="keyword">if</span> (!callPermitted) &#123;</span><br><span class="line">            <span class="comment">//&amp;&amp;&amp; 已熔断异常事件发布，本部分忽略，参考第四部分</span></span><br><span class="line">            publishCallNotPermittedEvent();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> callPermitted;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代码块8里的onError方法，业务处理错误后会触发这个方法的调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="keyword">long</span> durationInNanos, Throwable throwable)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这个判断是过滤需要忽略的异常处理，一般情况下没配置的话所有异常都会走下面实际的onError逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (circuitBreakerConfig.getRecordFailurePredicate().test(throwable)) &#123;</span><br><span class="line">            <span class="comment">//&amp;&amp;&amp; 处理错误事件发布，参考第四部分</span></span><br><span class="line">            publishCircuitErrorEvent(name, durationInNanos, throwable);</span><br><span class="line">            <span class="comment">//可以看到，实际上onError也是调用的XXState里的onError方法</span></span><br><span class="line">            stateReference.get().onError(throwable);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//&amp;&amp;&amp; 命中了可忽略的异常，忽略错误事件发布，本部分忽略，参考第四部分</span></span><br><span class="line">            publishCircuitIgnoredErrorEvent(name, durationInNanos, throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代码块8里的onSuccess方法，业务处理正常会触发这个方法的调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(<span class="keyword">long</span> durationInNanos)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//&amp;&amp;&amp; 处理正常事件发布，本部分忽略，参考第四部分</span></span><br><span class="line">        publishSuccessEvent(durationInNanos);</span><br><span class="line">        <span class="comment">//同样的，onSuccess也是调用的XXState里的onError方法</span></span><br><span class="line">        stateReference.get().onSuccess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3：状态类"><a href="#3-3：状态类" class="headerlink" title="3.3：状态类"></a>3.3：状态类</h3><p>通过上面的代码可以知道<code>isCallPermitted</code>、<code>onSuccess</code>、<code>onError</code>这三个方法实际上都是调用对应<code>XXState</code>对象里的方法，下面来看下<code>ClosedState</code>、<code>OpenState</code>、<code>HalfOpenState</code>这三个状态对象里有关这三个方法的实现（因为上面的测试用例只涉及这三种状态的互转，实际上这三种状态也是最常用的，所以为了避免混乱，只展示这三种，所有状态类均继承自<code>CircuitBreakerState抽象类</code>）</p>
<h3 id="3-3-1：ClosedState"><a href="#3-3-1：ClosedState" class="headerlink" title="3.3.1：ClosedState"></a>3.3.1：ClosedState</h3><p>闭合状态时初始状态，中途只会由半熔断状态切换而来，正常情况下都是闭合状态，代码如下：</p>
<figure class="highlight java"><figcaption><span>代码块10</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ClosedState</span> <span class="keyword">extends</span> <span class="title">CircuitBreakerState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来度量错误率的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CircuitBreakerMetrics circuitBreakerMetrics;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//就是配置里的failureRateThreshold属性，闭合状态时的错误率阈值（第二部分的测试用例中是50）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> failureRateThreshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参考代码块9的CircuitBreakerStateMachine构造器中初始化stateReference时，初始态都是闭合状态，最初都是通过该方法完成初始化的</span></span><br><span class="line">    ClosedState(CircuitBreakerStateMachine stateMachine) &#123;</span><br><span class="line">        <span class="keyword">this</span>(stateMachine, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个构造器是状态转换时触发的，参考代码块9里的transitionToClosedState方法</span></span><br><span class="line">    ClosedState(CircuitBreakerStateMachine stateMachine, CircuitBreakerMetrics circuitBreakerMetrics) &#123;</span><br><span class="line">        <span class="keyword">super</span>(stateMachine);</span><br><span class="line">        <span class="comment">//拿到熔断器的配置</span></span><br><span class="line">        CircuitBreakerConfig circuitBreakerConfig = stateMachine.getCircuitBreakerConfig();</span><br><span class="line">        <span class="keyword">if</span>(circuitBreakerMetrics == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//初始化metrics对象，传进去的是闭合状态时计算错误率的单位请求数（第二部分的测试用例中是100）</span></span><br><span class="line">            <span class="keyword">this</span>.circuitBreakerMetrics = <span class="keyword">new</span> CircuitBreakerMetrics(</span><br><span class="line">                    circuitBreakerConfig.getRingBufferSizeInClosedState());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//中途进行状态转换，调用的都是这里的逻辑，利用circuitBreakerMetrics的copy方法，重新赋值给circuitBreakerMetrics属性，暂时忽略，参考第3.4部分</span></span><br><span class="line">            <span class="keyword">this</span>.circuitBreakerMetrics = circuitBreakerMetrics.copy(circuitBreakerConfig.getRingBufferSizeInClosedState());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//赋值错误率阈值</span></span><br><span class="line">        <span class="keyword">this</span>.failureRateThreshold = stateMachine.getCircuitBreakerConfig().getFailureRateThreshold();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCallPermitted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//闭合状态下返回true，不会触发降级逻辑（ps：只有在全熔断状态下才会返回true）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 闭合状态下，onerror需要记录错误率，注：circuitBreakerMetrics的onError方法会记录一笔错误的记录，并把当前的错误率返回</span></span><br><span class="line">        checkFailureRate(circuitBreakerMetrics.onError());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 闭合状态下，onerror需要记录成功数，注：circuitBreakerMetrics的onSuccess方法会记录一笔正确的记录，并把当前的错误率返回</span></span><br><span class="line">        checkFailureRate(circuitBreakerMetrics.onSuccess());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据当前的错误率，决定是否切到半熔断状态</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkFailureRate</span><span class="params">(<span class="keyword">float</span> currentFailureRate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentFailureRate &gt;= failureRateThreshold) &#123; <span class="comment">//这里判断当前错误率是否超过阈值</span></span><br><span class="line">            <span class="comment">// 利用CircuitBreakerStateMachine的transitionToOpenState方法，将状态对象转换成OpenState</span></span><br><span class="line">            stateMachine.transitionToOpenState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2：OpenState"><a href="#3-3-2：OpenState" class="headerlink" title="3.3.2：OpenState"></a>3.3.2：OpenState</h3><p>一般全熔断状态会从闭合或者半熔断状态里切换而来，它的代码如下：</p>
<figure class="highlight java"><figcaption><span>代码块11</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenState</span> <span class="keyword">extends</span> <span class="title">CircuitBreakerState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据全熔断持续时间推出的进入半熔断状态的时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Instant retryAfterWaitDuration;</span><br><span class="line">    <span class="comment">//同样是用来度量错误率的对象，该对象就是上一个State对象里的Metrics对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CircuitBreakerMetrics circuitBreakerMetrics;</span><br><span class="line"></span><br><span class="line">    OpenState(CircuitBreakerStateMachine stateMachine, CircuitBreakerMetrics circuitBreakerMetrics) &#123;</span><br><span class="line">        <span class="keyword">super</span>(stateMachine);</span><br><span class="line">        <span class="comment">//就是配置里的waitDurationInOpenState属性，全熔断持续时间（第二部分的测试用例中是100ms）</span></span><br><span class="line">        <span class="keyword">final</span> Duration waitDurationInOpenState = stateMachine.getCircuitBreakerConfig().getWaitDurationInOpenState();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前时间加上持续时间，就是切换至半熔断状态的时机</span></span><br><span class="line">        <span class="keyword">this</span>.retryAfterWaitDuration = Instant.now().plus(waitDurationInOpenState);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接用之前的circuitBreakerMetrics对象</span></span><br><span class="line">        <span class="keyword">this</span>.circuitBreakerMetrics = circuitBreakerMetrics;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果配置了自动切换半熔断状态的开关为true，则会发起一个延时任务，用来主动切换状态</span></span><br><span class="line">        <span class="keyword">if</span> (stateMachine.getCircuitBreakerConfig().isAutomaticTransitionFromOpenToHalfOpenEnabled()) &#123;</span><br><span class="line">            AutoTransitioner.scheduleAutoTransition(stateMachine::transitionToHalfOpenState, waitDurationInOpenState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCallPermitted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果全熔断状态持续时间超出目标范围，则认为现在可以切换为半熔断状态，然后返回true</span></span><br><span class="line">        <span class="keyword">if</span> (Instant.now().isAfter(retryAfterWaitDuration)) &#123;</span><br><span class="line">            stateMachine.transitionToHalfOpenState();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        circuitBreakerMetrics.onCallNotPermitted(); <span class="comment">//记录一次NotPermitted（简单的累加）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//全熔断状态，直接返回false，表示已被熔断，让调用方抛出CircuitBreakerOpenException异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//理论上处于全熔断状态，isCallPermitted返回false，onError不会被触发（参考代码块8里的decorateCallable方法）</span></span><br><span class="line">        <span class="comment">//但是存在一种特殊的情况，假设有俩线程，线程1执行的时候还是闭合状态，isCallPermitted返回true，这时线程2里触发了熔断阈值</span></span><br><span class="line">        <span class="comment">//线程2把stateReference的指向置为OpenState，这时线程1继续往下执行，触发的onError其实是OpenState里的onError（也即是本例中的这个方法）</span></span><br><span class="line">        <span class="comment">//全熔断状态下即便是上面这种临界情况发生，这次失败也会被统计上去</span></span><br><span class="line">        circuitBreakerMetrics.onError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Should never be called when isCallPermitted returns false.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//跟onError一样，有概率会访问到</span></span><br><span class="line">        circuitBreakerMetrics.onSuccess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-3：HalfOpenState"><a href="#3-3-3：HalfOpenState" class="headerlink" title="3.3.3：HalfOpenState"></a>3.3.3：HalfOpenState</h3><p>半熔断状态一定是由全熔断切换出来的，来看下它的代码：</p>
<figure class="highlight java"><figcaption><span>代码块12</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HalfOpenState</span> <span class="keyword">extends</span> <span class="title">CircuitBreakerState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同样是用来度量错误率的对象</span></span><br><span class="line">    <span class="keyword">private</span> CircuitBreakerMetrics circuitBreakerMetrics;</span><br><span class="line">    <span class="comment">//同样是配置里的failureRateThreshold属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> failureRateThreshold;</span><br><span class="line"></span><br><span class="line">    HalfOpenState(CircuitBreakerStateMachine stateMachine) &#123;</span><br><span class="line">        <span class="keyword">super</span>(stateMachine);</span><br><span class="line">        CircuitBreakerConfig circuitBreakerConfig = stateMachine.getCircuitBreakerConfig();</span><br><span class="line">        <span class="comment">//初始化度量对象，相比闭合状态，这里传入的是ringBufferSizeInHalfOpenState（第二部分的测试用例中是10）</span></span><br><span class="line">        <span class="keyword">this</span>.circuitBreakerMetrics = <span class="keyword">new</span> CircuitBreakerMetrics(</span><br><span class="line">                circuitBreakerConfig.getRingBufferSizeInHalfOpenState());</span><br><span class="line">        <span class="comment">//闭合状态和半开状态共用同一个错误率阈值（第二部分的测试用例中是50）</span></span><br><span class="line">        <span class="keyword">this</span>.failureRateThreshold = stateMachine.getCircuitBreakerConfig().getFailureRateThreshold();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCallPermitted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//跟闭合状态一样，返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 跟闭合状态一样，要记录和判断当前的错误率（来决定是恢复闭合状态还是进入全熔断状态）</span></span><br><span class="line">        checkFailureRate(circuitBreakerMetrics.onError());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 同上</span></span><br><span class="line">        checkFailureRate(circuitBreakerMetrics.onSuccess());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过该方法，判断错误率，决定是否恢复为闭合状态或者再次进入全熔断状态</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkFailureRate</span><span class="params">(<span class="keyword">float</span> currentFailureRate)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Metrics返回-1表示请求量表示还没有达到单位请求量（ringBufferSizeInHalfOpenState）</span></span><br><span class="line">        <span class="comment">//下面的逻辑可以看出，在半熔断状态下，经过ringBufferSizeInHalfOpenState次请求后根据错误率判断，就可以决定出下一步切换到哪个状态了</span></span><br><span class="line">        <span class="keyword">if</span> (currentFailureRate != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//当前错误率如果再次超出阈值，则再次进入全熔断状态</span></span><br><span class="line">            <span class="keyword">if</span> (currentFailureRate &gt;= failureRateThreshold) &#123;</span><br><span class="line">                stateMachine.transitionToOpenState();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则恢复为闭合状态</span></span><br><span class="line">                stateMachine.transitionToClosedState();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-4：状态间的切换关系"><a href="#3-3-4：状态间的切换关系" class="headerlink" title="3.3.4：状态间的切换关系"></a>3.3.4：状态间的切换关系</h3><p>上面三种状态的切换关系如下：</p>
<p><img src="http://myblog.sharemer.com/2019/12/10/20191210-1-5.png?imageView2/0/w/750" alt="图5" title="图5"></p>
<p>在这些状态中，最初为熔断闭合状态，ServerB的所有请求正常访问ServerC，ServerC报错，错误率累计达到50%后触发熔断全开状态，此时Server对ServerC发出的请求将走ServerB的降级逻辑，不再实际访问ServerC的方法，这个状态会持续<code>waitDurationInOpenState</code>这么久（测试用例中是1000ms），然后进入熔断半开状态，此时跟闭合状态一样，ServerB的所有请求仍会正常访问ServerC，不同的是半开状态下只需要满足<code>ringBufferSizeInHalfOpenState</code>次调用（测试用例中是10次），就可以直接判断错误率是否达到阈值，这点可以在<code>代码块12</code>里的<code>checkFailureRate</code>方法体现，<code>图5</code>中可以看到，如果未达到错误阈值表示ServerC已恢复，则可以关闭熔断，否则再次进入全熔断状态。</p>
<h3 id="3-3-5：度量对象（CircuitBreakerMetrics）的传递"><a href="#3-3-5：度量对象（CircuitBreakerMetrics）的传递" class="headerlink" title="3.3.5：度量对象（CircuitBreakerMetrics）的传递"></a>3.3.5：度量对象（CircuitBreakerMetrics）的传递</h3><p>这个对象在<code>3.4</code>中会详细说明，目前只需要知道该类用于做错误统计用，错误率计算的核心，核心方法为<code>onError</code>和<code>onSuccess</code>，这俩方法用于错误/正确请求的触发点，用于触发<code>CircuitBreakerMetrics</code>对象对错误率的统计。</p>
<p>通过<code>代码块10、11、12</code>可以看到<code>CircuitBreakerMetrics</code>对象的流向，首先初始化的时候是调用<code>ClosedState</code>第一个构造器触发第二个构造器，第二个构造器会new一个<code>CircuitBreakerMetrics</code>，传过去的size为<code>ringBufferSizeInClosedState</code>，然后由<code>ClosedState</code>切换至<code>OpenState</code>状态时，其<code>CircuitBreakerMetrics</code>会被传递给<code>OpenState</code>对象，根据<code>代码块11</code>可以知道，<code>OpenState</code>利用该对象统计熔断期间被熔断的次数，然后<code>OpenState</code>切换至<code>HalfOpenState</code>时，<code>HalfOpenState</code>没有接受<code>CircuitBreakerMetrics</code>对象的构造器，不管由谁切换到<code>半开状态</code>，<code>CircuitBreakerMetrics</code>对象都是全新的，由<code>代码块12</code>可知，初始化<code>CircuitBreakerMetrics</code>对象时传过去的size就是<code>ringBufferSizeInHalfOpenState</code>。</p>
<p><code>CircuitBreakerMetrics</code>对象的传递以及传递后在<code>State对象</code>里所做的操作：</p>
<p><img src="http://myblog.sharemer.com/2019/12/10/20191210-1-6.png?imageView2/0/w/1024" alt="图6" title="图6"></p>
<p><code>图6</code>根据<code>代码块10、11、12</code>画出，简单体现了<code>Metrics对象</code>的生成以及流向，以及这个对象在各<code>State对象</code>里所做的主要操作。通过<code>图6</code>可以看出实际产生新的Metrics对象的地方为<code>闭合态</code>和<code>半开态</code>，因为这俩地方是需要做错误统计的，需要全新的Metric对象，全开态下仅接收前一状态的Metrics对象，在命中熔断后对其内部<code>numberOfNotPermittedCalls</code>（不是很懂这个属性，简单的累加，连用到的地方都没，可能仅仅是做个熔断数统计让业务方获取的吧，做监控可以用），在半开态再次进入闭合态时，其Metrics仍然被传递给了闭合态，由<code>代码块10</code>可知，如果传了<code>Metrics对象</code>，<code>闭合态</code>在产生新的<code>Metrics对象</code>时，会通过<code>copy</code>方法来产生，这个方法在<code>3.4</code>会详细说明，简单来说就是把前一个状态（只可能是<code>半开态</code>）的Metrics里的请求计数同步到它自己的Metrics里，这样做有一个好处，就是新的闭合态不用重新累计错误率了，以单元测试所配的参数试想一下，如果在半开态下，进行了10次请求，发生了4次错误，此时会切回闭合态，闭合态<code>copy</code>了这10次请求的数据，那么只需要再经过90次请求和46次错误便可以再次进入全熔断状态（其实就是保证了状态的<code>平滑切换</code>，不丢失之前已经统计了的数据）。</p>
<h3 id="3-4：错误统计"><a href="#3-4：错误统计" class="headerlink" title="3.4：错误统计"></a>3.4：错误统计</h3><h3 id="3-4-1：CircuitBreakerMetrics"><a href="#3-4-1：CircuitBreakerMetrics" class="headerlink" title="3.4.1：CircuitBreakerMetrics"></a>3.4.1：CircuitBreakerMetrics</h3><p>通过<code>3.3</code>的了解，闭合和半开时的请求状态计数都是通过<code>CircuitBreakerMetrics</code>对象来完成的，现在来看下这个类里都干了些什么：</p>
<figure class="highlight java"><figcaption><span>代码块13</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircuitBreakerMetrics</span> <span class="keyword">implements</span> <span class="title">CircuitBreaker</span>.<span class="title">Metrics</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过3.3的代码块可知，该值就是闭合或者半开状态下设置的ringBufferSizeInClosedState和ringBufferSizeInHalfOpenState</span></span><br><span class="line">    <span class="comment">//表示一次请求窗口的大小，测试用例中就是闭合时的100以及半开时的10，通过图4和下方的getFailureRate方法可以知道，</span></span><br><span class="line">    <span class="comment">//至少要累计完成一个请求窗口的请求量后才会实际计算错误率</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ringBufferSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实际用来记录一个请求窗口的请求统计数据的结构，本节不深究，详细参考3.4.2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RingBitSet ringBitSet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全开状态下累计被熔断的请求个数，触发点参考图6以及代码块11</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongAdder numberOfNotPermittedCalls;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器1，参考图6，在最开始的闭合状态以及后续的半开状态下初始化Metrics对象用的就是该构造器</span></span><br><span class="line">    CircuitBreakerMetrics(<span class="keyword">int</span> ringBufferSize) &#123;</span><br><span class="line">        <span class="keyword">this</span>(ringBufferSize, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参考图6，由半开转到闭合态的时候，是通过该方法进行初始化的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CircuitBreakerMetrics <span class="title">copy</span><span class="params">(<span class="keyword">int</span> targetRingBufferSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CircuitBreakerMetrics(targetRingBufferSize, <span class="keyword">this</span>.ringBitSet); <span class="comment">//这里会把当前Metrics对象里的ringBitSet传递下去</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器2</span></span><br><span class="line">    CircuitBreakerMetrics(<span class="keyword">int</span> ringBufferSize, RingBitSet sourceSet) &#123;</span><br><span class="line">        <span class="keyword">this</span>.ringBufferSize = ringBufferSize;</span><br><span class="line">        <span class="keyword">if</span>(sourceSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//通过copy初始化会走这里（每次的半开态转闭合态），将原来Metrics对象里的ringBitSet传递下去（用来初始化新的请求窗口）</span></span><br><span class="line">            <span class="keyword">this</span>.ringBitSet = <span class="keyword">new</span> RingBitSet(<span class="keyword">this</span>.ringBufferSize, sourceSet);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//非copy新建Metrics对象（每次的半开态和最初的闭合态）</span></span><br><span class="line">            <span class="keyword">this</span>.ringBitSet = <span class="keyword">new</span> RingBitSet(<span class="keyword">this</span>.ringBufferSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.numberOfNotPermittedCalls = <span class="keyword">new</span> LongAdder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//onError和onSuccess的触发点参考3.3里的State类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当请求发生错误时触发该方法，该方法用于记一次失败，然后把当前错误率返回</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">onError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> currentNumberOfFailedCalls = ringBitSet.setNextBit(<span class="keyword">true</span>); <span class="comment">//通过ringBitSet的setNextBit置为true，算作一笔失败的记录</span></span><br><span class="line">        <span class="keyword">return</span> getFailureRate(currentNumberOfFailedCalls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当请求正常时触发该方法，该方法用于记一次成功，然后把当前错误率返回</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">onSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> currentNumberOfFailedCalls = ringBitSet.setNextBit(<span class="keyword">false</span>); <span class="comment">//通过ringBitSet的setNextBit置为false，算作一笔成功的记录</span></span><br><span class="line">        <span class="keyword">return</span> getFailureRate(currentNumberOfFailedCalls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全开状态下累计被熔断的请求个数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCallNotPermitted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        numberOfNotPermittedCalls.increment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过getFailureRate计算错误率并返回</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getFailureRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getFailureRate(getNumberOfFailedCalls());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下方注释中的窗口大小就是ringBufferSize属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法通过ringBitSet对象返回当前请求窗口内发生请求的总次数，如果达到了ringBufferSize次，则这个值就恒等于ringBufferSize</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberOfBufferedCalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.ringBitSet.length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该方法通过ringBitSet对象返回当前请求窗口内发生错误的次数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumberOfFailedCalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.ringBitSet.cardinality();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误率计算方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">getFailureRate</span><span class="params">(<span class="keyword">int</span> numberOfFailedCalls)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//若请求还没有完成一个请求窗口，则返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (getNumberOfBufferedCalls() &lt; ringBufferSize) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//完成了一次请求窗口，才会真正计算错误率</span></span><br><span class="line">        <span class="keyword">return</span> numberOfFailedCalls * <span class="number">100.0f</span> / ringBufferSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码可以知道最终统计错误数的是在<code>RingBitSet</code>结构中，下面来仔细了解下这个类~</p>
<h3 id="3-4-2：位图-amp-BitSetMod"><a href="#3-4-2：位图-amp-BitSetMod" class="headerlink" title="3.4.2：位图&amp;BitSetMod"></a>3.4.2：位图&amp;BitSetMod</h3><p>了解<code>RingBitSet</code>之前，先来了解一种数据结构-<code>位图</code>，如果已经了解过位图，那么可以直接去看RingBitSet。</p>
<p>RingBitSet持有一个<code>BitSetMod</code>对象，BitSetMod基于位图实现，位图是怎样的一种结构呢？先看下<code>图7</code>，然后再去解析它的源码实现。</p>
<p><img src="http://myblog.sharemer.com/2019/12/10/20191210-1-7.png?imageView2/0/w/700" alt="图7" title="图7"></p>
<p>通过上图可知，位图就是利用数组内每个元素的bit位存入一个标记，标记只有存在或者不存在（对应二进制的0和1），这样就可以做到用一个long型的数字就可以产生出64个标记信息，非常适合数据量庞大而判断状态少的应用场景，比如判断一个词语是否是屏蔽词，首先屏蔽词状态只有两种：命中or不命中，但是屏蔽词可能是个非常庞大的集合，如果一个个拿来比较，效率完全保证不了，那么就可以利用这个数据结构来解决这类问题，可以首先把所有的屏蔽词放到一个位图结构里，如果有相同的词语，只需要简单的两部运算就可以拿到是否命中结果，构建这个位图结构的过程如下：</p>
<p><img src="http://myblog.sharemer.com/2019/12/10/20191210-1-8.png?imageView2/0/w/1024" alt="图8" title="图8"></p>
<p>通过上图，屏蔽词位图结构就构建好了，如果有个词语需要判定是否命中屏蔽词，只需要让这个词语通过上面的哈希算法计算出哈希值，然后找到对应的数组下标，通过位运算算出其所在位置，将该位置的值取出，如果是0，则认为没有命中，1则认为命中。</p>
<p>以上就是位图结构，通过上面的例子，可以认为同一个值一定命中位图里的同一个位置，那么抽象成熔断器的错误率，错误状态只有0和1，1表示错误，0表示正确，给每次请求编号，当成是图8中的哈希值，相同编号的请求一定会落到同一个位置，现在不理解没关系，这个要结合RingBitSet一起看，目前只需要理解位图特性即可。</p>
<p>Resilience4j里通过BitSetMod简单实现了一个位图结构，来看下代码（注：代码里有大量位运算，过程说明都写在了注释里）：</p>
<figure class="highlight java"><figcaption><span>代码块14</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下方为源码注释↓↓</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> io.github.resilience4j.circuitbreaker.internal.BitSetMod&#125; is simplified version of &#123;<span class="doctag">@link</span> java.util.BitSet&#125;.</span></span><br><span class="line"><span class="comment"> * It has no dynamic allocation, expanding logic, boundary checks</span></span><br><span class="line"><span class="comment"> * and it's set method returns previous bit state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitSetMod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.此类是一种怎样的数据结构？</span></span><br><span class="line"><span class="comment">     * 根据原有注释，可知这是一个简易版的BitSet，即位图结构，可以通过图7更为直观的了解下该结构</span></span><br><span class="line"><span class="comment">     * 由图7可知，位图分为x，y轴，y轴就是本类的long型的数组（words），其中内部每一个元素都包括64个bit，因此bit位横向扩展就是x轴（x轴大小恒等于64）</span></span><br><span class="line"><span class="comment">     * 如果要标记一个数字是否存在于图中，只需要先找到所属的y轴位置（即对应的words下标），然后再计算出它应该出现的x轴long型数字中哪个bit位，</span></span><br><span class="line"><span class="comment">     * 然后判断该bit位是否已被标记为true，若是，则返回已存在，否则返回不存在。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 2.位运算</span></span><br><span class="line"><span class="comment">     * 简单了解下本类中出现的位运算，任意两个数的乘法或除法都可以用&lt;&lt;（左移）或&gt;&gt;（右移）来表示</span></span><br><span class="line"><span class="comment">     * 例：</span></span><br><span class="line"><span class="comment">     * a * b == a &lt;&lt; log2(b)</span></span><br><span class="line"><span class="comment">     * a / b == a &gt;&gt; log2(b)</span></span><br><span class="line"><span class="comment">     * 本例中的ADDRESS_BITS_PER_WORD属性，其实就是long型位数以2为底的对数，即log2(64) = 6</span></span><br><span class="line"><span class="comment">     * 那么接下来代码中针对ADDRESS_BITS_PER_WORD的位运算就可以简单理解为乘以/除以64了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//long类型bit位的对数，即log2(64)＝6，利用该值可以进行简单的乘除法的位运算</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> ADDRESS_BITS_PER_WORD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终可以存放的总位数，计算方式：words.length * 64（每个long型有64位，利用数组长度乘以位数，就计算出了位图的总位数）</span></span><br><span class="line">    <span class="comment">//用位运算表示为：words.length &lt;&lt; 6（右移表示乘法，右移6位表示乘以2^6，即words.length * 64）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//位图数组，long型，64个bit位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span>[] words;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器，传入位图的容量大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BitSetMod</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算数组大小（即y轴大小），根据上面对位图的基本解释，可以知道，y轴是一个long型数组，</span></span><br><span class="line">        <span class="comment">//而每次一个数字进来，会首先找到y轴所属的位置，那么这个数组得多大才合适呢？我们知道x轴固定为64个，</span></span><br><span class="line">        <span class="comment">//也就是说正常情况下，任意数字进来后都会被分到某个y轴对应的long型数字里的某一位，那么y轴大小就很好推算了，</span></span><br><span class="line">        <span class="comment">//利用给出的容量大小（这个表示任意数最大时为多大），除以64进行平均分组，这样不管传的任意数为多大，始终都可以找到对应的[x,y]，且不会越界</span></span><br><span class="line">        <span class="keyword">int</span> countOfWordsRequired = wordIndex(capacity - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上面说过，size就是位图里所有位数，即x * y，也就是words.length * 64，用位运算表示为：words.length &lt;&lt; 6</span></span><br><span class="line">        size = countOfWordsRequired &lt;&lt; ADDRESS_BITS_PER_WORD;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最终((capacity - 1)/64)+1就是y轴数组大小，初始化数组即可</span></span><br><span class="line">        words = <span class="keyword">new</span> <span class="keyword">long</span>[countOfWordsRequired];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//到这里，一个位图对象就被我们创建好了，数组（y轴）是它实际的实体，x轴是数组里long型数字的二进制位（64）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">wordIndex</span><span class="params">(<span class="keyword">int</span> bitIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//下面这个位运算等同于：bitIndex/64</span></span><br><span class="line">        <span class="keyword">return</span> bitIndex &gt;&gt; ADDRESS_BITS_PER_WORD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始设置数字信息，bitIndex为目标放置位置，value为值（0或1）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> bitIndex, <span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 利用位置数字除以64，推算出它对应的y轴下标</span></span><br><span class="line">        <span class="keyword">int</span> wordIndex = wordIndex(bitIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注：下面的代码都是位运算，开始前先来了解一下如何定位某个数字的二进制第n位上的数字是0还是1</span></span><br><span class="line">        <span class="comment">// 将1右移bitIndex位，可以得到一个类似1000000的二进制数字，利用这个数字跟原来的数字本身做位与运算，可以推算出原数第bitIndex位上的数字是1还是0</span></span><br><span class="line">        <span class="comment">// 举个例子，我想知道下面这个二进制数字中第5位的数字是0还是1（跟十进制一样，位数是从右往左数，位数最高的在最左边，下标从0开始算起）</span></span><br><span class="line">        <span class="comment">// 假设该二进制数为λ，设：λ=101010101</span></span><br><span class="line">        <span class="comment">// 现在将1右移5位得到bitMask，它用二进制表示为：100000，1的位置正好位于第5位（从右往左，下标从0算起）</span></span><br><span class="line">        <span class="comment">// 利用λ跟bitMask进行位与运算：</span></span><br><span class="line">        <span class="comment">//    101010101（λ）</span></span><br><span class="line">        <span class="comment">//    &amp;</span></span><br><span class="line">        <span class="comment">//    000100000（bitMask）</span></span><br><span class="line">        <span class="comment">//    ------------------</span></span><br><span class="line">        <span class="comment">//    000000000（位与结果）</span></span><br><span class="line">        <span class="comment">// 由这个过程可以发现，λ的第5位如果是0，位与后的结果也是0，如果是1，那么位与运算后的结果肯定是不等于0的，通过这种方式，我们就可以利用1右移的方式，</span></span><br><span class="line">        <span class="comment">// 知道λ的第n位是0还是1</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 通过上面的例子，可以知道，任意数与1右移后的数字（bitMask）进行位与运算的结果要么不等于0，要么等于0，因为1右移n位后生成的二进制数在其n位上一定为1，</span></span><br><span class="line">        <span class="comment">// 其余位置一定为0，0&amp;0、0&amp;1均为0，所以最后的结果要么是000000000，要么还等于1右移后的那个数：000010000，这取决于原始数字里第n位上是否是1，</span></span><br><span class="line">        <span class="comment">// 如果是1，则相与后的结果值一定不等于0，反之则等于0</span></span><br><span class="line">	<span class="comment">// 结合上面所有的描述，这里可以再思考一个问题，为什么位不会相互覆盖？比如我传了一个bitIndex为100，long型1&lt;&lt;100等价于1&lt;&lt;36（以64为模轮回），那么当我传100的时候岂不是会覆盖掉传36时那次做标记？</span></span><br><span class="line">	<span class="comment">// 这个问题答案是否定的，因为在最初的时候就已经把bitIndex按照64为单位进行相除计算出下标了，也就是说bitIndex等于100那次，跟bitIndex等于36那次，不在一个下标里（不在一个次元）</span></span><br><span class="line">        <span class="comment">// 根据这些规则，下面的代码就好理解了。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> bitMask = <span class="number">1L</span> &lt;&lt; bitIndex;</span><br><span class="line">        <span class="keyword">int</span> previous = (words[wordIndex] &amp; bitMask) != <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">//把该位置上当前的值（0或1）赋值给previous（也就是最后返回出去的结果）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            <span class="comment">// 重新赋值，注意，这里是原值跟bitMask进行或运算，意味着目标位的值会直接变成1，其余位置的值均不变</span></span><br><span class="line">            words[wordIndex] = words[wordIndex] | bitMask;</span><br><span class="line">            <span class="comment">// 结合例子，参考下面这个过程更容易理解</span></span><br><span class="line">            <span class="comment">//    101010101</span></span><br><span class="line">            <span class="comment">//    |</span></span><br><span class="line">            <span class="comment">//    000100000</span></span><br><span class="line">            <span class="comment">//    ---------</span></span><br><span class="line">            <span class="comment">//    101110101</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// value等于false的时候，bitMask取反后跟原值进行与运算，跟上面相反，这是把目标位变成0</span></span><br><span class="line">            words[wordIndex] = words[wordIndex] &amp; ~bitMask;</span><br><span class="line">            <span class="comment">// 结合例子，参考下面这个过程更容易理解</span></span><br><span class="line">            <span class="comment">//    101010101</span></span><br><span class="line">            <span class="comment">//    &amp;</span></span><br><span class="line">            <span class="comment">//    111011111（bitMask的反码）</span></span><br><span class="line">            <span class="comment">//    ---------</span></span><br><span class="line">            <span class="comment">//    101010101</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> previous;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回位图里的总位数</span></span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> bitIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 注：如果对下方的右移等操作还不是很了解，请先看set方法里的注释</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先还是利用位置数字除以64，推算出它对应的y轴下标</span></span><br><span class="line">        <span class="keyword">int</span> wordIndex = wordIndex(bitIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果set里的位运算理解了，下面这个很容易理解，这个流程跟set方法里获取previous一样</span></span><br><span class="line">        <span class="keyword">long</span> bitMask = <span class="number">1L</span> &lt;&lt; bitIndex;</span><br><span class="line">        <span class="keyword">return</span> (words[wordIndex] &amp; bitMask) != <span class="number">0</span>; <span class="comment">//大于0时返回true，表示目标位是1，否则返回false，目标位是0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是Resilience4j针对位图的简单实现，它负责存储单位请求内的<code>错误/成功</code>标志。</p>
<h3 id="3-4-3：RingBitSet"><a href="#3-4-3：RingBitSet" class="headerlink" title="3.4.3：RingBitSet"></a>3.4.3：RingBitSet</h3><p>之前说过，最终请求被放到了一个环形结构里才对，沿着环执行一周就是一次单位请求，回看下图4，其实第101次请求就是顶替掉第一次请求的结果罢了，现在把图4中以100为请求窗口弯曲成一个环，假如第一次请求是失败的，第101次请求是成功的（绿色背景表示成功的请求，红色背景表示失败的请求）：</p>
<p><img src="http://myblog.sharemer.com/2019/12/10/20191210-1-9.png?imageView2/0/w/650" alt="图9" title="图9"></p>
<p>如何利用位图结构记录每次请求的<code>错误/成功</code>标记然后再实现<code>图9</code>里的<code>环形结构</code>呢？Resilience4j通过<code>RingBitSet</code>来实现，来看下它的代码：</p>
<figure class="highlight java"><figcaption><span>代码块15</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RingBitSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单位请求数，根据State类初始化RingSet时给的size值，可以确定该值就是各种ringBufferSize</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//真正存放错误率的位图结构</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BitSetMod bitSet;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在完成一个请求窗口后，该值为false，表示请求已满一次请求窗口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> notFull;</span><br><span class="line">    <span class="comment">//给请求编号，方便位图计算位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求数量，最终等于size</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> length;</span><br><span class="line">    <span class="comment">//当前请求窗口内的错误数，就是利用这个数实时计算错误率的（参考CircuitBreakerMetrics.getNumberOfFailedCalls）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cardinality = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    RingBitSet(<span class="keyword">int</span> bitSetSize) &#123;</span><br><span class="line">        notFull = <span class="keyword">true</span>;</span><br><span class="line">        size = bitSetSize;</span><br><span class="line">        bitSet = <span class="keyword">new</span> BitSetMod(bitSetSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//携带RingBitSet参数的构造器会把sourceSet里的统计数据赋值给新的RingBitSet（继承其请求数、错误率等）</span></span><br><span class="line">    <span class="comment">//调用该构造器的触发点在CircuitBreakerMetrics.copy中触发，通过图6可知，每次由半开状态转到闭合状态时，都会调用copy方法，</span></span><br><span class="line">    <span class="comment">//让新的闭合态继承上次半开态的请求量和错误率，这是合理的，比较平滑无损的过度到闭合态。</span></span><br><span class="line">    RingBitSet(<span class="keyword">int</span> bitSetSize, RingBitSet sourceSet) &#123;</span><br><span class="line">        <span class="keyword">this</span>(bitSetSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> targetLength = Integer.min(bitSetSize, sourceSet.length);</span><br><span class="line">        <span class="keyword">int</span> sourceIndex = sourceSet.index;</span><br><span class="line">        <span class="keyword">int</span> forwardIndex = sourceSet.size - sourceIndex;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; targetLength; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.setNextBit(sourceSet.bitSet.get(sourceIndex));</span><br><span class="line">            <span class="comment">// looping sourceIndex backwards without conditional statements</span></span><br><span class="line">            forwardIndex = (forwardIndex + <span class="number">1</span>) % sourceSet.size;</span><br><span class="line">            sourceIndex = (sourceSet.size - forwardIndex) % sourceSet.size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非常非常重要的方法，它的触发点在CircuitBreakerMetrics的onError和onSuccess，主要用于记录错误率</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">setNextBit</span><span class="params">(<span class="keyword">boolean</span> value)</span> </span>&#123;</span><br><span class="line">        increaseLength();</span><br><span class="line">        <span class="comment">//环形结构依靠这里来实现，index永远在0~size间循环累加，类似：[0,1,2,3...99,0,1,2,3...99]</span></span><br><span class="line">        index = (index + <span class="number">1</span>) % size;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用位图，将本次的错误/成功标记设置到对应index的位置上，</span></span><br><span class="line">　　　　 <span class="comment">//并且拿到当前index对应上次请求窗口中同样为index位置的请求结果previous，至于为啥要拿到这个值，参考下方的逻辑</span></span><br><span class="line">        <span class="keyword">int</span> previous = bitSet.set(index, value);</span><br><span class="line">        <span class="comment">//本次请求结果</span></span><br><span class="line">        <span class="keyword">int</span> current = value ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//下面这一步就是刷新错误数的，计算方式为：减去同位置上个请求窗口的请求结果，然后加上这次的请求结果</span></span><br><span class="line">        <span class="comment">//举个例子，假设单位请求窗口是100，第一个请求窗口的第一次请求错误，index=0的位置被标为1，第101次请求，也就是第二个请求窗口的第一次请求，</span></span><br><span class="line">        <span class="comment">//意味着index仍然为0，那么第101次请求的结果就会覆盖掉第1次请求的那个结果，以此来完成窗口滚动（参考图9）</span></span><br><span class="line">        cardinality = cardinality - previous + current;</span><br><span class="line">        <span class="keyword">return</span> cardinality;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前请求窗口内的错误总量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cardinality</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cardinality;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bitSet.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            result.append(bitSet.get(i) ? <span class="string">'1'</span> : <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//累加当前请求窗口内的请求量，当完成一次单位请求窗口时，length恒等于单位请求窗口大小（size）</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">increaseLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (notFull) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextLength = length + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nextLength &lt; size) &#123;</span><br><span class="line">                length = nextLength;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                length = size;</span><br><span class="line">                notFull = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>Resilience4j通过<code>CircuitBreakerStateMachine</code>来独立出一个熔断器，其内部持有一个<code>CircuitBreakerState</code>对象的引用，在错误率达到某个阈值时，会发生状态切换，CircuitBreakerState的引用会指向新的状态对象。每个状态对象持有一个<code>CircuitBreakerMetrics</code>对象，用于做实时统计和错误率监听使用，CircuitBreakerMetrics对象通过<code>RingBitSet</code>来完成单位请求窗口的错误率统计，这个统计是实时的，每次请求都会触发一次错误率的判断。RingBitSet通过Resilience4j自己实现的一个轻量级的<code>位图</code>结构<code>BitSetMod</code>来标记请求<code>错误/成功</code>，顺便说下，这里通过RingBitSet来保证<code>环形结构</code>，而位图只负责存储请求结果，那么既然这样，我用普通的数组或者其他的可以通过下标获取数值的集合结构也可以实现啊，为什么一定要用位图呢？猜测是位图既可以保证跟数组一样高效，都是<code>O(1)</code>的复杂度，又可以节省存储空间，比如我的单位请求是1w次，如果是数组结构，虽然效率跟位图一样高，但是数组却需要存1w个0或1这样的数组，即便用byte类型的数组，每个数组元素都浪费了7个bit位。其他集合就更不用说了，效率无法保证，其次他们浪费的内存比单纯数组要高，所以，类似这种只有true或false的数据的存储，位图再适合不过了。</p>
<p>感觉有些地方说的不太清晰，待后续改进描述方式。</p>
</div><div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="http://myblog.sharemer.com/alipay_qrcode.png" alt="支付宝"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="http://myblog.sharemer.com/wx_qrcode.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/12/13/IDEA%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%A1%A8%E5%8D%95demo/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">IDEA插件开发（一）一个简单的表单demo</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/10/24/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%9C%89%E5%85%B3%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98%E6%A2%B3%E7%90%86/"><span class="level-item">工作中有关分布式缓存的使用和需要注意的问题梳理</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            id: 'fb64c509b42ca2eac1afe562ca02f822',
            repo: 'exceting.github.io',
            owner: 'exceting',
            clientID: '17297b562584b5cec3d7',
            clientSecret: '46c7652ed4f09fb1d847d15df81500a5a2ceeae8',
            admin: ["exceting"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: 'last',
            
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget toc-scroll" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-一、什么是熔断" href="#一、什么是熔断"><span>一、什么是熔断</span></a></li><li><a class="is-flex toc-item" id="toc-item-二、Resilience4j中的熔断器" href="#二、Resilience4j中的熔断器"><span>二、Resilience4j中的熔断器</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-2-1：Resilience4j是什么？" href="#2-1：Resilience4j是什么？"><span>2.1：Resilience4j是什么？</span></a></li><li><a class="is-flex toc-item" id="toc-item-2-2：如何使用？" href="#2-2：如何使用？"><span>2.2：如何使用？</span></a></li><li><a class="is-flex toc-item" id="toc-item-2-3：测试-熔断器状态切换" href="#2-3：测试-熔断器状态切换"><span>2.3：测试-熔断器状态切换</span></a></li><li><a class="is-flex toc-item" id="toc-item-2-4：测试-错误率统计方式" href="#2-4：测试-错误率统计方式"><span>2.4：测试-错误率统计方式</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-三、源码解析" href="#三、源码解析"><span>三、源码解析</span></a><ul class="menu-list toc"><li><a class="is-flex toc-item" id="toc-item-3-1：注册器入口" href="#3-1：注册器入口"><span>3.1：注册器入口</span></a></li><li><a class="is-flex toc-item" id="toc-item-3-2：Breaker实体-CircuitBreaker" href="#3-2：Breaker实体-CircuitBreaker"><span>3.2：Breaker实体-CircuitBreaker</span></a></li><li><a class="is-flex toc-item" id="toc-item-3-3：状态类" href="#3-3：状态类"><span>3.3：状态类</span></a></li><li><a class="is-flex toc-item" id="toc-item-3-3-1：ClosedState" href="#3-3-1：ClosedState"><span>3.3.1：ClosedState</span></a></li><li><a class="is-flex toc-item" id="toc-item-3-3-2：OpenState" href="#3-3-2：OpenState"><span>3.3.2：OpenState</span></a></li><li><a class="is-flex toc-item" id="toc-item-3-3-3：HalfOpenState" href="#3-3-3：HalfOpenState"><span>3.3.3：HalfOpenState</span></a></li><li><a class="is-flex toc-item" id="toc-item-3-3-4：状态间的切换关系" href="#3-3-4：状态间的切换关系"><span>3.3.4：状态间的切换关系</span></a></li><li><a class="is-flex toc-item" id="toc-item-3-3-5：度量对象（CircuitBreakerMetrics）的传递" href="#3-3-5：度量对象（CircuitBreakerMetrics）的传递"><span>3.3.5：度量对象（CircuitBreakerMetrics）的传递</span></a></li><li><a class="is-flex toc-item" id="toc-item-3-4：错误统计" href="#3-4：错误统计"><span>3.4：错误统计</span></a></li><li><a class="is-flex toc-item" id="toc-item-3-4-1：CircuitBreakerMetrics" href="#3-4-1：CircuitBreakerMetrics"><span>3.4.1：CircuitBreakerMetrics</span></a></li><li><a class="is-flex toc-item" id="toc-item-3-4-2：位图-amp-BitSetMod" href="#3-4-2：位图-amp-BitSetMod"><span>3.4.2：位图&amp;amp;BitSetMod</span></a></li><li><a class="is-flex toc-item" id="toc-item-3-4-3：RingBitSet" href="#3-4-3：RingBitSet"><span>3.4.3：RingBitSet</span></a></li></ul></li><li><a class="is-flex toc-item" id="toc-item-四、总结" href="#四、总结"><span>四、总结</span></a></li></ul></div></div><script type="text/javascript" async>
        $(document).ready(function () { //参考自 https://github.com/ppoffice/hexo-theme-icarus/pull/616/files
            var observerTopMargin;
            var scrollObserver;
            var headerElems = $(".headerlink");
            var activeTocItem;
        
            function initIntersectionObserver(docHeight) {
                observerTopMargin = docHeight;
                scrollObserver = new IntersectionObserver(scrollCallBack,
                    {
                        root: null,  // viewpoint
                        rootMargin: docHeight + "px 0px -80% 0px"  // cover top 30% of viewport to the top of document
                    })
            }
        
            function scrollCallBack(entries, observer) {
                if ($(window).scrollTop() > observerTopMargin * 0.7) { 
                    // User somehow scroll to 70% of observerTopMargin (which is inited as 200% document height)
                    // Observer top margin need to extend to cover all the space to the top of the document
                    initIntersectionObserver(observerTopMargin * 2)
                    observer.disconnect();
                    return;
                }
                let toActive;
                if (entries[0].intersectionRatio == 1) {  // enter viewed area
                    let entry = entries.reduce((u, v) => (u.target.toc_id > v.target.toc_id ? u : v));  // get the lowest item
                    toActive = $("#toc-item-" + $(entry.target).attr("href").substr(1));
                } else {
                    let entry = entries.reduce((u, v) => (u.target.toc_id < v.target.toc_id ? u : v));  // get the highest item
                    let idx = Math.max(entry.target.toc_id - 1, 0);
                    toActive = $("#toc-item-" + $(headerElems[idx]).attr("href").substr(1));
                }
                if (activeTocItem) activeTocItem.removeClass("is-current");
                activeTocItem = toActive
                activeTocItem.addClass("is-current");
            }
        
            initIntersectionObserver($(document).height() * 2);
            headerElems.each(function (index, obj) {
                obj.toc_id = index;
                scrollObserver.observe(obj);
            })
        });</script></div><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="" src="http://myblog.sharemer.com/avatar_2.png" alt="S-Virus"></figure><p class="title is-size-4 is-block line-height-inherit">S-Virus</p><p class="is-size-6 is-block">随机和因果，命运与无常，兼而有之</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>上海</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">72</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">35</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">65</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/exceting" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/exceting"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="bilibili" href="https://www.bilibili.com"><i class="fas fa-tv"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:1807301715@qq.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-08T01:38:00.000Z">2020-06-08</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/08/%E6%B5%8E%E6%BA%90%E6%B8%B8%E8%AE%B0/">济源游记-20200517</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E6%97%A5%E5%B8%B8/">日常</a> / <a class="link-muted" href="/categories/%E6%97%A5%E5%B8%B8/%E6%97%85%E8%A1%8C/">旅行</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-01T16:11:00.000Z">2020-06-02</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/02/%E8%AF%A6%E8%A7%A3JDBC%E7%9A%84Loadbalance%E6%A8%A1%E5%BC%8F/">详解JDBC的Loadbalance模式</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/DB/">DB</a> / <a class="link-muted" href="/categories/DB/MySQL/">MySQL</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-05-06T00:27:00.000Z">2020-05-06</time></p><p class="title is-6"><a class="link-muted" href="/2020/05/06/JVM%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%E8%AE%B0%E5%BD%95%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E7%B1%BB%E6%96%87%E4%BB%B6/">JVM基础回顾记录（四）：类文件</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/JAVA%E5%9F%BA%E7%A1%80/">JAVA基础</a> / <a class="link-muted" href="/categories/JAVA%E5%9F%BA%E7%A1%80/JVM/">JVM</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-02T07:47:00.000Z">2020-04-02</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/02/LV5-6%EF%BC%9Ajava%E5%B9%B6%E5%8F%91%E5%8C%85-juc%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/">LV5-6：java并发包-juc的简单介绍</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/JAVA%E5%9F%BA%E7%A1%80/">JAVA基础</a> / <a class="link-muted" href="/categories/JAVA%E5%9F%BA%E7%A1%80/JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA/">JAVA进化论</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-02T06:40:00.000Z">2020-04-02</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/02/LV5-5%EF%BC%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%9Ajoin%E3%80%81yield%E3%80%81sleep%E3%80%81interrupt/">LV5-5：线程调度：join、yield、sleep、interrupt</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/JAVA%E5%9F%BA%E7%A1%80/">JAVA基础</a> / <a class="link-muted" href="/categories/JAVA%E5%9F%BA%E7%A1%80/JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA/">JAVA进化论</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/DB/"><span class="level-start"><span class="level-item">DB</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/DB/InfluxDB/"><span class="level-start"><span class="level-item">InfluxDB</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/DB/MySQL/"><span class="level-start"><span class="level-item">MySQL</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/DB/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"><span class="level-start"><span class="level-item">分布式缓存</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/JAVA%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">JAVA基础</span></span><span class="level-end"><span class="level-item tag">31</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/JAVA%E5%9F%BA%E7%A1%80/JAVA%E8%BF%9B%E5%8C%96%E8%AE%BA/"><span class="level-start"><span class="level-item">JAVA进化论</span></span><span class="level-end"><span class="level-item tag">28</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/JAVA%E5%9F%BA%E7%A1%80/JVM/"><span class="level-start"><span class="level-item">JVM</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">并发编程</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC/"><span class="level-start"><span class="level-item">JUC</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadLocal/"><span class="level-start"><span class="level-item">ThreadLocal</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><span class="tag">基础知识</span><span class="tag is-grey-lightest">27</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%99%E7%A8%8B/"><span class="tag">教程</span><span class="tag is-grey-lightest">27</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span class="tag">并发编程</span><span class="tag is-grey-lightest">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"><span class="tag">网络编程</span><span class="tag is-grey-lightest">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NIO/"><span class="tag">NIO</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JVM/"><span class="tag">JVM</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ThreadLocal/"><span class="tag">ThreadLocal</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/juc/"><span class="tag">juc</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B1%A0%E5%8C%96%E6%8A%80%E6%9C%AF/"><span class="tag">池化技术</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"><span class="tag">连接池</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Druid/"><span class="tag">Druid</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/OpenTracing/"><span class="tag">OpenTracing</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/aop/"><span class="tag">aop</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ioc/"><span class="tag">ioc</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/map/"><span class="tag">map</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BD%8D%E5%9B%BE/"><span class="tag">位图</span><span class="tag is-grey-lightest">2</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=removeifFeedsId&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="removeifFeedsId" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div><p class="help">如果需要订阅，可以尝试留下你的邮箱</p></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="http://myblog.sharemer.com/logooo.png" alt="S-Virus" height="28"></a><p class="size-small"><span>&copy; 2020 S-Virus</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>,Modify by <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">removeif</a> <br><span>© 版权说明：[本博客所有文档均由博主创作，作为博主本人记录生活和学习之用，站内文档禁止转载，如有关于本站的疑问，请<a href="/message" target="_blank">留言</a>]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2018/12/29 00:00:00')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/exceting"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="2755914162" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.12/js/lightgallery-all.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><!--!--><!--!--><!--!--><script src="/js/toc.js" defer></script><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('17297b562584b5cec3d7','46c7652ed4f09fb1d847d15df81500a5a2ceeae8','exceting','exceting.github.io',false);})</script><link rel="stylesheet" href="/css/insight.css"><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="想要查找什么..."><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>(function (window) {
            var INSIGHT_CONFIG = {
                TRANSLATION: {
                    POSTS: '文章',
                    PAGES: '页面',
                    CATEGORIES: '分类',
                    TAGS: '标签',
                    UNTITLED: '(无标题)',
                },
                CONTENT_URL: '/content.json',
            };
            window.INSIGHT_CONFIG = INSIGHT_CONFIG;
        })(window);</script><script src="/js/insight.js" defer></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('17297b562584b5cec3d7','46c7652ed4f09fb1d847d15df81500a5a2ceeae8','exceting','exceting.github.io',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>